{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"en/","title":"Project Documentation","text":"<p>Documentation for civic-exchange-protocol.</p> <p>Use the navigation menu to explore available modules and APIs.</p> <ul> <li>The API Reference section includes autogenerated docs from the source code.</li> <li>This home page will always be served at <code>/</code>.</li> </ul> <p>To learn more, visit the GitHub repository.</p>"},{"location":"en/api/","title":"API Reference","text":"<p>Auto-generated code documentation.</p>"},{"location":"en/api/#civic_exchange_protocol","title":"civic_exchange_protocol","text":"<p>Civic Exchange Protocol (CEP) - Python Implementation.</p> <p>A protocol for transparent, verifiable civic data exchange.</p> Submodules <p>core: Core types (timestamps, hashes, attestations) core_linker: SNFEI generation and entity normalization entity: Entity records and identifiers relationship: Relationship records exchange: Exchange records</p>"},{"location":"en/api/#civic_exchange_protocol.api","title":"api","text":"<p>CEP Entity Canonicalization Service.</p> <p>This service generates the Canonical String and Entity Hash for a CEP Entity Record, enforcing strict field ordering and temporal rules.</p> <p>Dependencies: fastapi, uvicorn, pydantic, hashlib, datetime, decimal To run: uvicorn cep_entity_service:app --reload</p>"},{"location":"en/api/#civic_exchange_protocol.api.CanonicalResponse","title":"CanonicalResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the structure of the API's successful output.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>class CanonicalResponse(BaseModel):\n    \"\"\"Defines the structure of the API's successful output.\"\"\"\n\n    c_string: str = Field(\n        ..., description=\"The Canonical String (C-String) used as the hash input.\"\n    )\n    entity_hash: str = Field(..., description=\"The final 64-character SHA-256 Entity Hash.\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.EntityPayload","title":"EntityPayload","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the structure for the CEP Entity Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>class EntityPayload(BaseModel):\n    \"\"\"Defines the structure for the CEP Entity Record.\"\"\"\n\n    # Section 1: Identity and Attestation\n    entity_uei: str = Field(..., pattern=r\"^[A-Z0-9]{12}$\", alias=\"entityUei\")\n    record_id: str = Field(..., max_length=64, alias=\"recordId\")\n    attesting_uei: str = Field(..., pattern=r\"^[A-Z0-9]{12}$\", alias=\"attestingUei\")\n    attestation_timestamp: datetime = Field(\n        ..., description=\"ISO 8601 UTC with microsecond precision.\", alias=\"attestationTimestamp\"\n    )\n\n    # Section 2: Temporal Status and Governance (The critical fields)\n    # Section 2: Temporal Status and Governance (The critical fields)\n    status_effective_date: datetime = Field(\n        ...,\n        description=\"The 'As-of' date/time when this record became valid.\",\n        alias=\"statusEffectiveDate\",\n    )\n    status_termination_date: datetime | None = Field(\n        None,\n        description=\"The date/time the record ceased to be valid (omitted if null).\",\n        alias=\"statusTerminationDate\",\n    )\n    legal_status: str = Field(\n        ..., description=\"e.g., ACTIVE, DISSOLVED, SUSPENDED.\", alias=\"legalStatus\"\n    )\n    status_suspension_date: datetime | None = Field(\n        None,\n        description=\"Date/time the entity was suspended (omitted if null).\",\n        alias=\"statusSuspensionDate\",\n    )\n    # Section 3: Core Attributes\n    legal_name: str = Field(..., max_length=256, alias=\"legalName\")\n    tax_id: str = Field(..., max_length=32, alias=\"taxId\")\n    physical_address_line1: str = Field(..., max_length=128, alias=\"physicalAddressLine1\")\n    physical_address_city: str = Field(..., max_length=64, alias=\"physicalAddressCity\")\n    physical_address_postal_code: str = Field(..., max_length=16, alias=\"physicalAddressPostalCode\")\n    is_government: bool = Field(\n        ..., description=\"True if a recognized government body.\", alias=\"isGovernment\"\n    )\n    naics_code: str | None = Field(None, max_length=10, alias=\"naicsCode\")\n\n    class Config:\n        \"\"\"Pydantic model configuration for JSON serialization and schema examples.\"\"\"\n\n        json_encoders = {datetime: lambda v: v.isoformat().replace(\"+00:00\", \"Z\")}\n        populate_by_name = True\n        # Example for API documentation\n        schema_extra = {\n            \"example\": {\n                \"entityUei\": \"1A2B3C4D5E6F\",\n                \"recordId\": \"CEP-2025-001\",\n                \"attestingUei\": \"GOV-0000000001\",\n                \"attestationTimestamp\": \"2025-11-27T17:52:30.123456Z\",\n                \"statusEffectiveDate\": \"2024-01-01T00:00:00Z\",\n                # statusTerminationDate is None/omitted, implying current validity\n                \"legalStatus\": \"ACTIVE\",\n                \"statusSuspensionDate\": None,  # Omitted\n                \"legalName\": \"Acme Data Solutions LLC\",\n                \"taxId\": \"99-1234567\",\n                \"physicalAddressLine1\": \"123 Main St.\",\n                \"physicalAddressCity\": \"Springfield\",\n                \"physicalAddressPostalCode\": \"62704\",\n                \"isGovernment\": False,\n                \"naicsCode\": \"541512\",\n            }\n        }\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.EntityPayload.Config","title":"Config","text":"<p>Pydantic model configuration for JSON serialization and schema examples.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>class Config:\n    \"\"\"Pydantic model configuration for JSON serialization and schema examples.\"\"\"\n\n    json_encoders = {datetime: lambda v: v.isoformat().replace(\"+00:00\", \"Z\")}\n    populate_by_name = True\n    # Example for API documentation\n    schema_extra = {\n        \"example\": {\n            \"entityUei\": \"1A2B3C4D5E6F\",\n            \"recordId\": \"CEP-2025-001\",\n            \"attestingUei\": \"GOV-0000000001\",\n            \"attestationTimestamp\": \"2025-11-27T17:52:30.123456Z\",\n            \"statusEffectiveDate\": \"2024-01-01T00:00:00Z\",\n            # statusTerminationDate is None/omitted, implying current validity\n            \"legalStatus\": \"ACTIVE\",\n            \"statusSuspensionDate\": None,  # Omitted\n            \"legalName\": \"Acme Data Solutions LLC\",\n            \"taxId\": \"99-1234567\",\n            \"physicalAddressLine1\": \"123 Main St.\",\n            \"physicalAddressCity\": \"Springfield\",\n            \"physicalAddressPostalCode\": \"62704\",\n            \"isGovernment\": False,\n            \"naicsCode\": \"541512\",\n        }\n    }\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.canonicalize_entity","title":"canonicalize_entity  <code>async</code>","text":"<pre><code>canonicalize_entity(payload: EntityPayload)\n</code></pre> <p>Receives an Entity Record, performs canonical serialization (CAOS), and returns the cryptographic entity hash.</p> <p>Performs canonical serialization (CAOS) on the entity record.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>@app.post(\"/api/v1/entity/canonicalize\", response_model=CanonicalResponse, status_code=200)\nasync def canonicalize_entity(payload: EntityPayload):\n    \"\"\"Receives an Entity Record, performs canonical serialization (CAOS), and returns the cryptographic entity hash.\n\n    Performs canonical serialization (CAOS) on the entity record.\n    \"\"\"\n    try:\n        # 1. Generate the Canonical String (C-String)\n        c_string = generate_canonical_string(payload)\n\n        # 2. Generate the Entity Hash\n        entity_hash = generate_entity_hash(c_string)\n\n        return CanonicalResponse(c_string=c_string, entity_hash=entity_hash)\n\n    except Exception as e:\n        print(f\"Error during canonicalization: {e}\")\n        # In a production system, detailed logs would be captured here.\n        raise HTTPException(status_code=500, detail=\"Internal canonicalization error.\") from e\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.generate_canonical_string","title":"generate_canonical_string","text":"<pre><code>generate_canonical_string(data: EntityPayload) -&gt; str\n</code></pre> <p>Generate the pipe-delimited Canonical String (C-String) based on CAOS.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>def generate_canonical_string(data: EntityPayload) -&gt; str:\n    \"\"\"Generate the pipe-delimited Canonical String (C-String) based on CAOS.\"\"\"\n    parts = []\n\n    # Convert Pydantic model to a dictionary. Use by_alias=False to use the Python field names.\n    # Exclude None is handled explicitly in the loop for consistency with CEP Rule 1.2\n    data_dict = data.dict(exclude_none=False)\n\n    for field_name in CANONICAL_ATTRIBUTE_ORDER:\n        value = data_dict.get(field_name)\n\n        # Rule 1.2: Field Omission (Null/Empty Exclusion)\n        if value is None or (isinstance(value, str) and value == \"\"):\n            continue\n\n        formatted_value = \"\"\n\n        # Specific rule for microsecond precision on attestationTimestamp\n        if field_name == \"attestationTimestamp\":\n            if not isinstance(value, datetime):\n                raise TypeError(f\"attestationTimestamp must be datetime, got {type(value)!r}\")\n            formatted_value = _format_datetime(value)\n\n        # Standard ISO 8601 for other temporal fields\n        elif field_name in [\"statusEffectiveDate\", \"statusTerminationDate\", \"statusSuspensionDate\"]:\n            # These are date-like; accept both date and datetime\n            if not isinstance(value, datetime | date):\n                raise TypeError(f\"{field_name} must be date/datetime, got {type(value)!r}\")\n            formatted_value = value.isoformat().replace(\"+00:00\", \"Z\")\n\n        # Standard Boolean Formatting\n        elif field_name == \"isGovernment\":\n            formatted_value = \"true\" if value else \"false\"\n\n        # Standard String/Integer Fields\n        else:\n            formatted_value = str(value)\n\n        parts.append(formatted_value)\n\n    # Rule 1.3: Join all parts with the pipe delimiter\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.generate_entity_hash","title":"generate_entity_hash","text":"<pre><code>generate_entity_hash(c_string: str) -&gt; str\n</code></pre> <p>Generate the final SHA-256 Entity Hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>def generate_entity_hash(c_string: str) -&gt; str:\n    \"\"\"Generate the final SHA-256 Entity Hash.\"\"\"\n    return hashlib.sha256(c_string.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.cli","title":"cli","text":""},{"location":"en/api/#civic_exchange_protocol.cli.cli","title":"cli","text":"<p>Command-line interface for the Civic Exchange Protocol.</p> <p>This module provides CLI commands for: - snfei: Generate an SNFEI for an entity name and country - version: Display the package version - validate-json: Validate JSON files against CEP schemas</p>"},{"location":"en/api/#civic_exchange_protocol.cli.cli.snfei","title":"snfei","text":"<pre><code>snfei(\n    legal_name: str = typer.Argument(\n        ..., help='Raw legal name'\n    ),\n    country_code: str = typer.Option(\n        'US',\n        '--country-code',\n        '-c',\n        help='ISO country code',\n    ),\n) -&gt; None\n</code></pre> <p>Generate an SNFEI for an entity name and country.</p> Source code in <code>src/python/src/civic_exchange_protocol/cli/cli.py</code> <pre><code>@app.command()\ndef snfei(\n    legal_name: str = typer.Argument(..., help=\"Raw legal name\"),\n    country_code: str = typer.Option(\"US\", \"--country-code\", \"-c\", help=\"ISO country code\"),\n) -&gt; None:\n    \"\"\"Generate an SNFEI for an entity name and country.\"\"\"\n    result = generate_snfei_with_confidence(\n        legal_name=legal_name,\n        country_code=country_code,\n    )\n    typer.echo(f\"SNFEI: {result.snfei.value}\")\n    typer.echo(f\"Tier: {result.tier}, confidence: {result.confidence_score}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.cli.cli.validate_json","title":"validate_json","text":"<pre><code>validate_json(\n    path: Path | None = None,\n    schema: str = typer.Option(\n        ...,\n        '--schema',\n        '-s',\n        help='Schema name (for example: entity, exchange, relationship, snfei).',\n    ),\n    recursive: bool = typer.Option(\n        False,\n        '--recursive',\n        '-r',\n        help='Recurse into subdirectories when validating a directory.',\n    ),\n) -&gt; None\n</code></pre> <p>Validate JSON file(s) against a CEP JSON Schema.</p> <p>Behavior: - If PATH is a file, validates that single JSON file. - If PATH is a directory, validates all *.json files within it.   Use --recursive to walk subdirectories.</p> Source code in <code>src/python/src/civic_exchange_protocol/cli/cli.py</code> <pre><code>@app.command()\ndef validate_json(\n    path: Path | None = None,\n    schema: str = typer.Option(\n        ...,\n        \"--schema\",\n        \"-s\",\n        help=\"Schema name (for example: entity, exchange, relationship, snfei).\",\n    ),\n    recursive: bool = typer.Option(\n        False,\n        \"--recursive\",\n        \"-r\",\n        help=\"Recurse into subdirectories when validating a directory.\",\n    ),\n) -&gt; None:\n    \"\"\"Validate JSON file(s) against a CEP JSON Schema.\n\n    Behavior:\n    - If PATH is a file, validates that single JSON file.\n    - If PATH is a directory, validates all *.json files within it.\n      Use --recursive to walk subdirectories.\n    \"\"\"\n    if path is None:\n        typer.echo(\"Error: Path argument is required.\")\n        raise typer.Exit(code=1)\n\n    summary: ValidationSummary = validate_json_path(\n        path=path,\n        schema_name=schema,\n        recursive=recursive,\n    )\n\n    if not summary.results:\n        typer.echo(\"No JSON files found to validate.\")\n        raise typer.Exit(code=1)\n\n    errors_found = False\n\n    for result in summary.results:\n        if result.ok:\n            typer.echo(f\"[OK] {result.path}\")\n        else:\n            errors_found = True\n            typer.echo(f\"[ERROR] {result.path}\")\n            for err in result.errors:\n                typer.echo(f\"  - {err}\")\n\n    if errors_found:\n        typer.echo(\"Validation completed with errors.\")\n        raise typer.Exit(code=1)\n\n    typer.echo(\"All files validated successfully.\")\n    raise typer.Exit(code=0)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.cli.cli.version","title":"version","text":"<pre><code>version() -&gt; None\n</code></pre> <p>Show package version.</p> Source code in <code>src/python/src/civic_exchange_protocol/cli/cli.py</code> <pre><code>@app.command()\ndef version() -&gt; None:\n    \"\"\"Show package version.\"\"\"\n    from civic_exchange_protocol import __version__\n\n    typer.echo(__version__)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core","title":"core","text":"<p>CEP Core - Core primitives for the Civic Exchange Protocol.</p> <p>This package provides the foundational types used by all CEP record types:</p> <ul> <li>CanonicalTimestamp: Microsecond-precision UTC timestamps</li> <li>CanonicalHash: SHA-256 hash values</li> <li>Canonicalize: Base class for deterministic serialization</li> <li>Attestation: Cryptographic proof of record integrity</li> <li>Schema Registry: Central schema loading and validation support</li> </ul>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation","title":"Attestation  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Cryptographic attestation proving record authenticity and integrity.</p> <p>This structure aligns with W3C Verifiable Credentials Data Integrity.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>@dataclass\nclass Attestation(Canonicalize):\n    \"\"\"Cryptographic attestation proving record authenticity and integrity.\n\n    This structure aligns with W3C Verifiable Credentials Data Integrity.\n    \"\"\"\n\n    # Verifiable ID of the entity or node attesting to this record\n    attestor_id: str\n\n    # When the attestation was created\n    attestation_timestamp: CanonicalTimestamp\n\n    # The proof algorithm identifier\n    # Examples: \"Ed25519Signature2020\", \"EcdsaSecp256k1Signature2019\", \"DataIntegrityProof\"\n    proof_type: str\n\n    # The cryptographic signature or proof value\n    proof_value: str\n\n    # URI resolving to the public key or DID document for verification\n    verification_method_uri: str\n\n    # The purpose of the proof\n    proof_purpose: ProofPurpose = field(default=ProofPurpose.ASSERTION_METHOD)\n\n    # Optional URI to a timestamping authority or DLT anchor\n    anchor_uri: str | None = None\n\n    @classmethod\n    def new(\n        cls,\n        attestor_id: str,\n        attestation_timestamp: CanonicalTimestamp,\n        proof_type: str,\n        proof_value: str,\n        verification_method_uri: str,\n    ) -&gt; \"Attestation\":\n        \"\"\"Create a new Attestation with required fields.\"\"\"\n        return cls(\n            attestor_id=attestor_id,\n            attestation_timestamp=attestation_timestamp,\n            proof_type=proof_type,\n            proof_value=proof_value,\n            verification_method_uri=verification_method_uri,\n        )\n\n    def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=purpose,\n            anchor_uri=self.anchor_uri,\n        )\n\n    def with_anchor(self, uri: str) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=self.proof_purpose,\n            anchor_uri=uri,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Fields in alphabetical order\n        insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n        insert_required(\n            fields,\n            \"attestationTimestamp\",\n            self.attestation_timestamp.to_canonical_string(),\n        )\n        insert_required(fields, \"attestorId\", self.attestor_id)\n        insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n        insert_required(fields, \"proofType\", self.proof_type)\n        insert_required(fields, \"proofValue\", self.proof_value)\n        insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Fields in alphabetical order\n    insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n    insert_required(\n        fields,\n        \"attestationTimestamp\",\n        self.attestation_timestamp.to_canonical_string(),\n    )\n    insert_required(fields, \"attestorId\", self.attestor_id)\n    insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n    insert_required(fields, \"proofType\", self.proof_type)\n    insert_required(fields, \"proofValue\", self.proof_value)\n    insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; Attestation\n</code></pre> <p>Create a new Attestation with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; \"Attestation\":\n    \"\"\"Create a new Attestation with required fields.\"\"\"\n    return cls(\n        attestor_id=attestor_id,\n        attestation_timestamp=attestation_timestamp,\n        proof_type=proof_type,\n        proof_value=proof_value,\n        verification_method_uri=verification_method_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation.with_anchor","title":"with_anchor","text":"<pre><code>with_anchor(uri: str) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified anchor URI.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def with_anchor(self, uri: str) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=self.proof_purpose,\n        anchor_uri=uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation.with_purpose","title":"with_purpose","text":"<pre><code>with_purpose(purpose: ProofPurpose) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified proof purpose.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=purpose,\n        anchor_uri=self.anchor_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash","title":"CanonicalHash","text":"<p>A SHA-256 hash value represented as a 64-character lowercase hex string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>class CanonicalHash:\n    \"\"\"A SHA-256 hash value represented as a 64-character lowercase hex string.\"\"\"\n\n    __slots__ = (\"_hex\",)\n\n    def __init__(self, hex_value: str) -&gt; None:\n        \"\"\"Create a CanonicalHash from a hex string.\n\n        Args:\n            hex_value: A 64-character hexadecimal string.\n\n        Raises:\n            ValueError: If the string is not valid.\n        \"\"\"\n        if len(hex_value) != 64:\n            raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n        if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n            raise ValueError(\"Hash must contain only hexadecimal characters\")\n        self._hex = hex_value.lower()\n\n    @classmethod\n    def from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n        \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n        Args:\n            canonical: The canonical string to hash.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        hasher = hashlib.sha256()\n        hasher.update(canonical.encode(\"utf-8\"))\n        return cls(hasher.hexdigest())\n\n    @classmethod\n    def from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n        \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n        Args:\n            hex_value: A hexadecimal string.\n\n        Returns:\n            A CanonicalHash instance, or None if invalid.\n        \"\"\"\n        try:\n            return cls(hex_value)\n        except ValueError:\n            return None\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Return the hash as a lowercase hex string.\"\"\"\n        return self._hex\n\n    def as_bytes(self) -&gt; bytes:\n        \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n        return bytes.fromhex(self._hex)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the hash.\"\"\"\n        return self._hex\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a detailed string representation of the hash.\"\"\"\n        return f\"CanonicalHash({self._hex!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n        if isinstance(other, CanonicalHash):\n            return self._hex == other._hex\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n        return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n    if isinstance(other, CanonicalHash):\n        return self._hex == other._hex\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n    return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__init__","title":"__init__","text":"<pre><code>__init__(hex_value: str) -&gt; None\n</code></pre> <p>Create a CanonicalHash from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A 64-character hexadecimal string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not valid.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __init__(self, hex_value: str) -&gt; None:\n    \"\"\"Create a CanonicalHash from a hex string.\n\n    Args:\n        hex_value: A 64-character hexadecimal string.\n\n    Raises:\n        ValueError: If the string is not valid.\n    \"\"\"\n    if len(hex_value) != 64:\n        raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n    if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n        raise ValueError(\"Hash must contain only hexadecimal characters\")\n    self._hex = hex_value.lower()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a detailed string representation of the hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a detailed string representation of the hash.\"\"\"\n    return f\"CanonicalHash({self._hex!r})\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the hash.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Return the hash as bytes (32 bytes).</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def as_bytes(self) -&gt; bytes:\n    \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n    return bytes.fromhex(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Return the hash as a lowercase hex string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Return the hash as a lowercase hex string.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.from_canonical_string","title":"from_canonical_string  <code>classmethod</code>","text":"<pre><code>from_canonical_string(canonical: str) -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the given canonical string.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical string to hash.</p> required <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>@classmethod\ndef from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n    \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n    Args:\n        canonical: The canonical string to hash.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(canonical.encode(\"utf-8\"))\n    return cls(hasher.hexdigest())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(hex_value: str) -&gt; Optional[CanonicalHash]\n</code></pre> <p>Create a CanonicalHash from a pre-computed hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Optional[CanonicalHash]</code> <p>A CanonicalHash instance, or None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n    \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n    Args:\n        hex_value: A hexadecimal string.\n\n    Returns:\n        A CanonicalHash instance, or None if invalid.\n    \"\"\"\n    try:\n        return cls(hex_value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp","title":"CanonicalTimestamp","text":"<p>A canonical CEP timestamp with mandatory microsecond precision.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>class CanonicalTimestamp:\n    \"\"\"A canonical CEP timestamp with mandatory microsecond precision.\"\"\"\n\n    __slots__ = (\"_dt\",)\n\n    def __init__(self, dt: datetime) -&gt; None:\n        \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n        Args:\n            dt: A datetime object. If naive, assumed to be UTC.\n                If aware, will be converted to UTC.\n        \"\"\"\n        if dt.tzinfo is None:\n            # Naive datetime - assume UTC\n            self._dt = dt.replace(tzinfo=UTC)\n        else:\n            # Convert to UTC\n            self._dt = dt.astimezone(UTC)\n\n    @classmethod\n    def now(cls) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n        return cls(datetime.now(UTC))\n\n    @classmethod\n    def parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Parse an ISO 8601 timestamp string.\n\n        Accepts formats:\n        - 2025-11-28T14:30:00.123456Z\n        - 2025-11-28T14:30:00.123456+00:00\n        - 2025-11-28T14:30:00Z (will add .000000)\n\n        Args:\n            s: The timestamp string to parse.\n\n        Returns:\n            A CanonicalTimestamp instance.\n\n        Raises:\n            ValueError: If the string cannot be parsed.\n        \"\"\"\n        # Handle Z suffix\n        if s.endswith(\"Z\"):\n            s = s[:-1] + \"+00:00\"\n\n        # Try parsing with microseconds\n        try:\n            dt = datetime.fromisoformat(s)\n            return cls(dt)\n        except ValueError:\n            pass\n\n        # Try without microseconds and add them\n        try:\n            # Remove timezone for parsing, then add back\n            if \"+\" in s:\n                base, tz = s.rsplit(\"+\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n            if s.count(\"-\") &gt; 2:  # Has negative offset\n                base, tz = s.rsplit(\"-\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n        except ValueError:\n            pass\n\n        raise ValueError(f\"Cannot parse timestamp: {s}\")\n\n    def as_datetime(self) -&gt; datetime:\n        \"\"\"Return the underlying datetime object (UTC).\"\"\"\n        return self._dt\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\n\n        Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n        This format is REQUIRED for hash stability across all CEP implementations.\n        \"\"\"\n        return self._dt.strftime(CANONICAL_FORMAT)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n        return self.to_canonical_string()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n        return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt == other._dt\n        return NotImplemented\n\n    def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt; other._dt\n        return NotImplemented\n\n    def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt;= other._dt\n        return NotImplemented\n\n    def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt; other._dt\n        return NotImplemented\n\n    def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt;= other._dt\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the timestamp.\"\"\"\n        return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt == other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than or equal to another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return the hash of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the timestamp.\"\"\"\n    return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__init__","title":"__init__","text":"<pre><code>__init__(dt: datetime) -&gt; None\n</code></pre> <p>Create a new CanonicalTimestamp from a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A datetime object. If naive, assumed to be UTC. If aware, will be converted to UTC.</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __init__(self, dt: datetime) -&gt; None:\n    \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n    Args:\n        dt: A datetime object. If naive, assumed to be UTC.\n            If aware, will be converted to UTC.\n    \"\"\"\n    if dt.tzinfo is None:\n        # Naive datetime - assume UTC\n        self._dt = dt.replace(tzinfo=UTC)\n    else:\n        # Convert to UTC\n        self._dt = dt.astimezone(UTC)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__le__","title":"__le__","text":"<pre><code>__le__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than or equal to another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the developer-friendly representation of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n    return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the canonical string representation of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n    return self.to_canonical_string()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.as_datetime","title":"as_datetime","text":"<pre><code>as_datetime() -&gt; datetime\n</code></pre> <p>Return the underlying datetime object (UTC).</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def as_datetime(self) -&gt; datetime:\n    \"\"\"Return the underlying datetime object (UTC).\"\"\"\n    return self._dt\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.now","title":"now  <code>classmethod</code>","text":"<pre><code>now() -&gt; CanonicalTimestamp\n</code></pre> <p>Return the current UTC time as a CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n    return cls(datetime.now(UTC))\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(s: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse an ISO 8601 timestamp string.</p> <p>Accepts formats: - 2025-11-28T14:30:00.123456Z - 2025-11-28T14:30:00.123456+00:00 - 2025-11-28T14:30:00Z (will add .000000)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The timestamp string to parse.</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>A CanonicalTimestamp instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string cannot be parsed.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Parse an ISO 8601 timestamp string.\n\n    Accepts formats:\n    - 2025-11-28T14:30:00.123456Z\n    - 2025-11-28T14:30:00.123456+00:00\n    - 2025-11-28T14:30:00Z (will add .000000)\n\n    Args:\n        s: The timestamp string to parse.\n\n    Returns:\n        A CanonicalTimestamp instance.\n\n    Raises:\n        ValueError: If the string cannot be parsed.\n    \"\"\"\n    # Handle Z suffix\n    if s.endswith(\"Z\"):\n        s = s[:-1] + \"+00:00\"\n\n    # Try parsing with microseconds\n    try:\n        dt = datetime.fromisoformat(s)\n        return cls(dt)\n    except ValueError:\n        pass\n\n    # Try without microseconds and add them\n    try:\n        # Remove timezone for parsing, then add back\n        if \"+\" in s:\n            base, tz = s.rsplit(\"+\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n        if s.count(\"-\") &gt; 2:  # Has negative offset\n            base, tz = s.rsplit(\"-\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n    except ValueError:\n        pass\n\n    raise ValueError(f\"Cannot parse timestamp: {s}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> <p>Format: YYYY-MM-DDTHH:MM:SS.ffffffZ</p> <p>This format is REQUIRED for hash stability across all CEP implementations.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\n\n    Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n    This format is REQUIRED for hash stability across all CEP implementations.\n    \"\"\"\n    return self._dt.strftime(CANONICAL_FORMAT)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for types that can be serialized to a canonical string for hashing.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>class Canonicalize(ABC):\n    \"\"\"Base class for types that can be serialized to a canonical string for hashing.\"\"\"\n\n    @abstractmethod\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the ordered map of field names to their canonical string values.\n\n        Fields with None/null/empty values should NOT be included in the dict.\n        The dict will be sorted alphabetically by key.\n\n        Returns:\n            A dictionary of field names to string values.\n        \"\"\"\n        pass\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Generate the canonical string representation for hashing.\n\n        Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n        Fields are ordered alphabetically by key.\n\n        Returns:\n            The canonical string.\n        \"\"\"\n        fields = self.canonical_fields()\n        # Sort by key alphabetically\n        sorted_items = sorted(fields.items(), key=lambda x: x[0])\n        parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n        return \",\".join(parts)\n\n    def calculate_hash(self) -&gt; CanonicalHash:\n        \"\"\"Compute the SHA-256 hash of the canonical string.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Canonicalize.calculate_hash","title":"calculate_hash","text":"<pre><code>calculate_hash() -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the canonical string.</p> <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def calculate_hash(self) -&gt; CanonicalHash:\n    \"\"\"Compute the SHA-256 hash of the canonical string.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Canonicalize.canonical_fields","title":"canonical_fields  <code>abstractmethod</code>","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the ordered map of field names to their canonical string values.</p> <p>Fields with None/null/empty values should NOT be included in the dict. The dict will be sorted alphabetically by key.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of field names to string values.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>@abstractmethod\ndef canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the ordered map of field names to their canonical string values.\n\n    Fields with None/null/empty values should NOT be included in the dict.\n    The dict will be sorted alphabetically by key.\n\n    Returns:\n        A dictionary of field names to string values.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Canonicalize.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Generate the canonical string representation for hashing.</p> <p>Format: \"field1\":\"value1\",\"field2\":\"value2\",...</p> <p>Fields are ordered alphabetically by key.</p> <p>Returns:</p> Type Description <code>str</code> <p>The canonical string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Generate the canonical string representation for hashing.\n\n    Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n    Fields are ordered alphabetically by key.\n\n    Returns:\n        The canonical string.\n    \"\"\"\n    fields = self.canonical_fields()\n    # Sort by key alphabetically\n    sorted_items = sorted(fields.items(), key=lambda x: x[0])\n    parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n    return \",\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CepError","title":"CepError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for CEP operations.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class CepError(Exception):\n    \"\"\"Base exception for CEP operations.\"\"\"\n\n    pass\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.HashMismatchError","title":"HashMismatchError","text":"<p>               Bases: <code>CepError</code></p> <p>Hash verification failed.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class HashMismatchError(CepError):\n    \"\"\"Hash verification failed.\"\"\"\n\n    def __init__(self, expected: str, actual: str) -&gt; None:\n        \"\"\"Initialize with expected and actual hash values.\"\"\"\n        super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n        self.expected = expected\n        self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.HashMismatchError.__init__","title":"__init__","text":"<pre><code>__init__(expected: str, actual: str) -&gt; None\n</code></pre> <p>Initialize with expected and actual hash values.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, expected: str, actual: str) -&gt; None:\n    \"\"\"Initialize with expected and actual hash values.\"\"\"\n    super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidHashError","title":"InvalidHashError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid hash format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidHashError(CepError):\n    \"\"\"Invalid hash format.\"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Initialize with the invalid hash value.\"\"\"\n        super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidHashError.__init__","title":"__init__","text":"<pre><code>__init__(value: str) -&gt; None\n</code></pre> <p>Initialize with the invalid hash value.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize with the invalid hash value.\"\"\"\n    super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidIdentifierError","title":"InvalidIdentifierError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid identifier format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidIdentifierError(CepError):\n    \"\"\"Invalid identifier format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid identifier.\"\"\"\n        super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidIdentifierError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid identifier.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid identifier.\"\"\"\n    super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidTimestampError","title":"InvalidTimestampError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid timestamp format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidTimestampError(CepError):\n    \"\"\"Invalid timestamp format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n        super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidTimestampError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n    super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.MissingFieldError","title":"MissingFieldError","text":"<p>               Bases: <code>CepError</code></p> <p>Missing required field.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class MissingFieldError(CepError):\n    \"\"\"Missing required field.\"\"\"\n\n    def __init__(self, field: str) -&gt; None:\n        \"\"\"Initialize with the name of the missing field.\"\"\"\n        super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.MissingFieldError.__init__","title":"__init__","text":"<pre><code>__init__(field: str) -&gt; None\n</code></pre> <p>Initialize with the name of the missing field.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, field: str) -&gt; None:\n    \"\"\"Initialize with the name of the missing field.\"\"\"\n    super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.ProofPurpose","title":"ProofPurpose","text":"<p>               Bases: <code>Enum</code></p> <p>The purpose of a cryptographic proof.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>class ProofPurpose(Enum):\n    \"\"\"The purpose of a cryptographic proof.\"\"\"\n\n    ASSERTION_METHOD = \"assertionMethod\"\n    AUTHENTICATION = \"authentication\"\n    CAPABILITY_DELEGATION = \"capabilityDelegation\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.ProofPurpose.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.RevisionChainError","title":"RevisionChainError","text":"<p>               Bases: <code>CepError</code></p> <p>Revision chain error.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class RevisionChainError(CepError):\n    \"\"\"Revision chain error.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about revision chain.\"\"\"\n        super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.RevisionChainError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about revision chain.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about revision chain.\"\"\"\n    super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.UnsupportedVersionError","title":"UnsupportedVersionError","text":"<p>               Bases: <code>CepError</code></p> <p>Schema version mismatch.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class UnsupportedVersionError(CepError):\n    \"\"\"Schema version mismatch.\"\"\"\n\n    def __init__(self, version: str) -&gt; None:\n        \"\"\"Initialize with the unsupported version string.\"\"\"\n        super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.UnsupportedVersionError.__init__","title":"__init__","text":"<pre><code>__init__(version: str) -&gt; None\n</code></pre> <p>Initialize with the unsupported version string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, version: str) -&gt; None:\n    \"\"\"Initialize with the unsupported version string.\"\"\"\n    super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.format_amount","title":"format_amount","text":"<pre><code>format_amount(amount: float) -&gt; str\n</code></pre> <p>Format a monetary amount with exactly 2 decimal places.</p> <p>This ensures consistent formatting across all implementations: - 100 becomes \"100.00\" - 100.5 becomes \"100.50\" - 100.756 becomes \"100.76\" (rounded)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The monetary amount.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted string with exactly 2 decimal places.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def format_amount(amount: float) -&gt; str:\n    \"\"\"Format a monetary amount with exactly 2 decimal places.\n\n    This ensures consistent formatting across all implementations:\n    - 100 becomes \"100.00\"\n    - 100.5 becomes \"100.50\"\n    - 100.756 becomes \"100.76\" (rounded)\n\n    Args:\n        amount: The monetary amount.\n\n    Returns:\n        The formatted string with exactly 2 decimal places.\n    \"\"\"\n    # Use Decimal for precise rounding\n    d = Decimal(str(amount))\n    rounded = d.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n    return f\"{rounded:.2f}\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.get_registry","title":"get_registry","text":"<pre><code>get_registry() -&gt; Registry\n</code></pre> <p>Get the shared registry for validation.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/schema_registry.py</code> <pre><code>def get_registry() -&gt; Registry:\n    \"\"\"Get the shared registry for validation.\"\"\"\n    registry, _ = _build_global_registry()\n    return registry\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.get_schema","title":"get_schema","text":"<pre><code>get_schema(name: str, version: str | None = None) -&gt; dict\n</code></pre> <p>Get a schema by logical name and optional version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Schema name (e.g., 'entity', 'exchange').</p> required <code>version</code> <code>str | None</code> <p>Schema version. Defaults to current SCHEMA_VERSION.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Schema as a dict.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schema name or version is unknown.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/schema_registry.py</code> <pre><code>def get_schema(name: str, version: str | None = None) -&gt; dict:\n    \"\"\"Get a schema by logical name and optional version.\n\n    Args:\n        name: Schema name (e.g., 'entity', 'exchange').\n        version: Schema version. Defaults to current SCHEMA_VERSION.\n\n    Returns:\n        Schema as a dict.\n\n    Raises:\n        ValueError: If schema name or version is unknown.\n    \"\"\"\n    if version is None:\n        version = _schema_version()\n\n    _, schemas = _build_global_registry()\n    key = (name, version)\n    if key not in schemas:\n        available = [f\"{n} v{v}\" for (n, v) in schemas if n == name]\n        if available:\n            raise ValueError(\n                f\"Unknown version {version!r} for schema {name!r}. Available: {available}\"\n            )\n        raise ValueError(f\"Unknown schema: {name!r}\")\n    return schemas[key]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.insert_if_present","title":"insert_if_present","text":"<pre><code>insert_if_present(\n    fields: dict[str, str], key: str, value: str | None\n) -&gt; None\n</code></pre> <p>Add a field to the dict only if the value is not None and not empty.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str | None</code> <p>The field value (may be None or empty).</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def insert_if_present(fields: dict[str, str], key: str, value: str | None) -&gt; None:\n    \"\"\"Add a field to the dict only if the value is not None and not empty.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value (may be None or empty).\n    \"\"\"\n    if value is not None and value != \"\":\n        fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.insert_required","title":"insert_required","text":"<pre><code>insert_required(\n    fields: dict[str, str], key: str, value: str\n) -&gt; None\n</code></pre> <p>Add a required field to the dict.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str</code> <p>The field value.</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def insert_required(fields: dict[str, str], key: str, value: str) -&gt; None:\n    \"\"\"Add a required field to the dict.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value.\n    \"\"\"\n    fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.list_schemas","title":"list_schemas","text":"<pre><code>list_schemas() -&gt; list[tuple[str, str]]\n</code></pre> <p>List all available (name, version) pairs.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/schema_registry.py</code> <pre><code>def list_schemas() -&gt; list[tuple[str, str]]:\n    \"\"\"List all available (name, version) pairs.\"\"\"\n    return list(SCHEMA_CATALOG.keys())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation","title":"attestation","text":"<p>Attestation and cryptographic proof types for CEP records.</p> <p>Every CEP record includes an attestation block that proves: - Who attested to the record (attestor_id) - When it was attested (attestation_timestamp) - Cryptographic proof of integrity (proof_type, proof_value, verification_method_uri)</p>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation","title":"Attestation  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Cryptographic attestation proving record authenticity and integrity.</p> <p>This structure aligns with W3C Verifiable Credentials Data Integrity.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>@dataclass\nclass Attestation(Canonicalize):\n    \"\"\"Cryptographic attestation proving record authenticity and integrity.\n\n    This structure aligns with W3C Verifiable Credentials Data Integrity.\n    \"\"\"\n\n    # Verifiable ID of the entity or node attesting to this record\n    attestor_id: str\n\n    # When the attestation was created\n    attestation_timestamp: CanonicalTimestamp\n\n    # The proof algorithm identifier\n    # Examples: \"Ed25519Signature2020\", \"EcdsaSecp256k1Signature2019\", \"DataIntegrityProof\"\n    proof_type: str\n\n    # The cryptographic signature or proof value\n    proof_value: str\n\n    # URI resolving to the public key or DID document for verification\n    verification_method_uri: str\n\n    # The purpose of the proof\n    proof_purpose: ProofPurpose = field(default=ProofPurpose.ASSERTION_METHOD)\n\n    # Optional URI to a timestamping authority or DLT anchor\n    anchor_uri: str | None = None\n\n    @classmethod\n    def new(\n        cls,\n        attestor_id: str,\n        attestation_timestamp: CanonicalTimestamp,\n        proof_type: str,\n        proof_value: str,\n        verification_method_uri: str,\n    ) -&gt; \"Attestation\":\n        \"\"\"Create a new Attestation with required fields.\"\"\"\n        return cls(\n            attestor_id=attestor_id,\n            attestation_timestamp=attestation_timestamp,\n            proof_type=proof_type,\n            proof_value=proof_value,\n            verification_method_uri=verification_method_uri,\n        )\n\n    def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=purpose,\n            anchor_uri=self.anchor_uri,\n        )\n\n    def with_anchor(self, uri: str) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=self.proof_purpose,\n            anchor_uri=uri,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Fields in alphabetical order\n        insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n        insert_required(\n            fields,\n            \"attestationTimestamp\",\n            self.attestation_timestamp.to_canonical_string(),\n        )\n        insert_required(fields, \"attestorId\", self.attestor_id)\n        insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n        insert_required(fields, \"proofType\", self.proof_type)\n        insert_required(fields, \"proofValue\", self.proof_value)\n        insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Fields in alphabetical order\n    insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n    insert_required(\n        fields,\n        \"attestationTimestamp\",\n        self.attestation_timestamp.to_canonical_string(),\n    )\n    insert_required(fields, \"attestorId\", self.attestor_id)\n    insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n    insert_required(fields, \"proofType\", self.proof_type)\n    insert_required(fields, \"proofValue\", self.proof_value)\n    insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; Attestation\n</code></pre> <p>Create a new Attestation with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; \"Attestation\":\n    \"\"\"Create a new Attestation with required fields.\"\"\"\n    return cls(\n        attestor_id=attestor_id,\n        attestation_timestamp=attestation_timestamp,\n        proof_type=proof_type,\n        proof_value=proof_value,\n        verification_method_uri=verification_method_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation.with_anchor","title":"with_anchor","text":"<pre><code>with_anchor(uri: str) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified anchor URI.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def with_anchor(self, uri: str) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=self.proof_purpose,\n        anchor_uri=uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation.with_purpose","title":"with_purpose","text":"<pre><code>with_purpose(purpose: ProofPurpose) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified proof purpose.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=purpose,\n        anchor_uri=self.anchor_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.ProofPurpose","title":"ProofPurpose","text":"<p>               Bases: <code>Enum</code></p> <p>The purpose of a cryptographic proof.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>class ProofPurpose(Enum):\n    \"\"\"The purpose of a cryptographic proof.\"\"\"\n\n    ASSERTION_METHOD = \"assertionMethod\"\n    AUTHENTICATION = \"authentication\"\n    CAPABILITY_DELEGATION = \"capabilityDelegation\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.ProofPurpose.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical","title":"canonical","text":"<p>Canonical serialization for CEP records.</p> <p>This module provides the base class and utilities for generating deterministic canonical strings from CEP records. The canonical string is the input to SHA-256 hashing for record integrity verification.</p> <p>Canonicalization Rules: 1. Field Order: Fields MUST be serialized in alphabetical order. 2. Null/Empty Omission: Fields with None or empty string values    MUST be omitted entirely from the canonical string. 3. Timestamp Format: All timestamps MUST use YYYY-MM-DDTHH:MM:SS.ffffffZ    with exactly 6 decimal places for microseconds. 4. Numeric Format: Monetary amounts MUST use exactly 2 decimal places.    Integers MUST NOT have decimal points. 5. String Escaping: Strings are NOT JSON-escaped in the canonical form.    The canonical string is a simple key:value concatenation. 6. Encoding: The canonical string MUST be UTF-8 encoded.</p>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for types that can be serialized to a canonical string for hashing.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>class Canonicalize(ABC):\n    \"\"\"Base class for types that can be serialized to a canonical string for hashing.\"\"\"\n\n    @abstractmethod\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the ordered map of field names to their canonical string values.\n\n        Fields with None/null/empty values should NOT be included in the dict.\n        The dict will be sorted alphabetically by key.\n\n        Returns:\n            A dictionary of field names to string values.\n        \"\"\"\n        pass\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Generate the canonical string representation for hashing.\n\n        Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n        Fields are ordered alphabetically by key.\n\n        Returns:\n            The canonical string.\n        \"\"\"\n        fields = self.canonical_fields()\n        # Sort by key alphabetically\n        sorted_items = sorted(fields.items(), key=lambda x: x[0])\n        parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n        return \",\".join(parts)\n\n    def calculate_hash(self) -&gt; CanonicalHash:\n        \"\"\"Compute the SHA-256 hash of the canonical string.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.Canonicalize.calculate_hash","title":"calculate_hash","text":"<pre><code>calculate_hash() -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the canonical string.</p> <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def calculate_hash(self) -&gt; CanonicalHash:\n    \"\"\"Compute the SHA-256 hash of the canonical string.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.Canonicalize.canonical_fields","title":"canonical_fields  <code>abstractmethod</code>","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the ordered map of field names to their canonical string values.</p> <p>Fields with None/null/empty values should NOT be included in the dict. The dict will be sorted alphabetically by key.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of field names to string values.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>@abstractmethod\ndef canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the ordered map of field names to their canonical string values.\n\n    Fields with None/null/empty values should NOT be included in the dict.\n    The dict will be sorted alphabetically by key.\n\n    Returns:\n        A dictionary of field names to string values.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.Canonicalize.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Generate the canonical string representation for hashing.</p> <p>Format: \"field1\":\"value1\",\"field2\":\"value2\",...</p> <p>Fields are ordered alphabetically by key.</p> <p>Returns:</p> Type Description <code>str</code> <p>The canonical string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Generate the canonical string representation for hashing.\n\n    Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n    Fields are ordered alphabetically by key.\n\n    Returns:\n        The canonical string.\n    \"\"\"\n    fields = self.canonical_fields()\n    # Sort by key alphabetically\n    sorted_items = sorted(fields.items(), key=lambda x: x[0])\n    parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n    return \",\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.format_amount","title":"format_amount","text":"<pre><code>format_amount(amount: float) -&gt; str\n</code></pre> <p>Format a monetary amount with exactly 2 decimal places.</p> <p>This ensures consistent formatting across all implementations: - 100 becomes \"100.00\" - 100.5 becomes \"100.50\" - 100.756 becomes \"100.76\" (rounded)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The monetary amount.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted string with exactly 2 decimal places.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def format_amount(amount: float) -&gt; str:\n    \"\"\"Format a monetary amount with exactly 2 decimal places.\n\n    This ensures consistent formatting across all implementations:\n    - 100 becomes \"100.00\"\n    - 100.5 becomes \"100.50\"\n    - 100.756 becomes \"100.76\" (rounded)\n\n    Args:\n        amount: The monetary amount.\n\n    Returns:\n        The formatted string with exactly 2 decimal places.\n    \"\"\"\n    # Use Decimal for precise rounding\n    d = Decimal(str(amount))\n    rounded = d.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n    return f\"{rounded:.2f}\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.insert_if_present","title":"insert_if_present","text":"<pre><code>insert_if_present(\n    fields: dict[str, str], key: str, value: str | None\n) -&gt; None\n</code></pre> <p>Add a field to the dict only if the value is not None and not empty.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str | None</code> <p>The field value (may be None or empty).</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def insert_if_present(fields: dict[str, str], key: str, value: str | None) -&gt; None:\n    \"\"\"Add a field to the dict only if the value is not None and not empty.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value (may be None or empty).\n    \"\"\"\n    if value is not None and value != \"\":\n        fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.insert_required","title":"insert_required","text":"<pre><code>insert_required(\n    fields: dict[str, str], key: str, value: str\n) -&gt; None\n</code></pre> <p>Add a required field to the dict.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str</code> <p>The field value.</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def insert_required(fields: dict[str, str], key: str, value: str) -&gt; None:\n    \"\"\"Add a required field to the dict.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value.\n    \"\"\"\n    fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error","title":"error","text":"<p>Error types for CEP operations.</p>"},{"location":"en/api/#civic_exchange_protocol.core.error.CepError","title":"CepError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for CEP operations.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class CepError(Exception):\n    \"\"\"Base exception for CEP operations.\"\"\"\n\n    pass\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.HashMismatchError","title":"HashMismatchError","text":"<p>               Bases: <code>CepError</code></p> <p>Hash verification failed.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class HashMismatchError(CepError):\n    \"\"\"Hash verification failed.\"\"\"\n\n    def __init__(self, expected: str, actual: str) -&gt; None:\n        \"\"\"Initialize with expected and actual hash values.\"\"\"\n        super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n        self.expected = expected\n        self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.HashMismatchError.__init__","title":"__init__","text":"<pre><code>__init__(expected: str, actual: str) -&gt; None\n</code></pre> <p>Initialize with expected and actual hash values.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, expected: str, actual: str) -&gt; None:\n    \"\"\"Initialize with expected and actual hash values.\"\"\"\n    super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidHashError","title":"InvalidHashError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid hash format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidHashError(CepError):\n    \"\"\"Invalid hash format.\"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Initialize with the invalid hash value.\"\"\"\n        super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidHashError.__init__","title":"__init__","text":"<pre><code>__init__(value: str) -&gt; None\n</code></pre> <p>Initialize with the invalid hash value.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize with the invalid hash value.\"\"\"\n    super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidIdentifierError","title":"InvalidIdentifierError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid identifier format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidIdentifierError(CepError):\n    \"\"\"Invalid identifier format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid identifier.\"\"\"\n        super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidIdentifierError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid identifier.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid identifier.\"\"\"\n    super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidTimestampError","title":"InvalidTimestampError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid timestamp format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidTimestampError(CepError):\n    \"\"\"Invalid timestamp format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n        super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidTimestampError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n    super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.MissingFieldError","title":"MissingFieldError","text":"<p>               Bases: <code>CepError</code></p> <p>Missing required field.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class MissingFieldError(CepError):\n    \"\"\"Missing required field.\"\"\"\n\n    def __init__(self, field: str) -&gt; None:\n        \"\"\"Initialize with the name of the missing field.\"\"\"\n        super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.MissingFieldError.__init__","title":"__init__","text":"<pre><code>__init__(field: str) -&gt; None\n</code></pre> <p>Initialize with the name of the missing field.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, field: str) -&gt; None:\n    \"\"\"Initialize with the name of the missing field.\"\"\"\n    super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.RevisionChainError","title":"RevisionChainError","text":"<p>               Bases: <code>CepError</code></p> <p>Revision chain error.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class RevisionChainError(CepError):\n    \"\"\"Revision chain error.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about revision chain.\"\"\"\n        super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.RevisionChainError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about revision chain.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about revision chain.\"\"\"\n    super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.UnsupportedVersionError","title":"UnsupportedVersionError","text":"<p>               Bases: <code>CepError</code></p> <p>Schema version mismatch.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class UnsupportedVersionError(CepError):\n    \"\"\"Schema version mismatch.\"\"\"\n\n    def __init__(self, version: str) -&gt; None:\n        \"\"\"Initialize with the unsupported version string.\"\"\"\n        super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.UnsupportedVersionError.__init__","title":"__init__","text":"<pre><code>__init__(version: str) -&gt; None\n</code></pre> <p>Initialize with the unsupported version string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, version: str) -&gt; None:\n    \"\"\"Initialize with the unsupported version string.\"\"\"\n    super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash","title":"hash","text":"<p>Cryptographic hashing utilities for CEP records.</p> <p>All CEP hashes are SHA-256, represented as lowercase hexadecimal strings.</p>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash","title":"CanonicalHash","text":"<p>A SHA-256 hash value represented as a 64-character lowercase hex string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>class CanonicalHash:\n    \"\"\"A SHA-256 hash value represented as a 64-character lowercase hex string.\"\"\"\n\n    __slots__ = (\"_hex\",)\n\n    def __init__(self, hex_value: str) -&gt; None:\n        \"\"\"Create a CanonicalHash from a hex string.\n\n        Args:\n            hex_value: A 64-character hexadecimal string.\n\n        Raises:\n            ValueError: If the string is not valid.\n        \"\"\"\n        if len(hex_value) != 64:\n            raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n        if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n            raise ValueError(\"Hash must contain only hexadecimal characters\")\n        self._hex = hex_value.lower()\n\n    @classmethod\n    def from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n        \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n        Args:\n            canonical: The canonical string to hash.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        hasher = hashlib.sha256()\n        hasher.update(canonical.encode(\"utf-8\"))\n        return cls(hasher.hexdigest())\n\n    @classmethod\n    def from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n        \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n        Args:\n            hex_value: A hexadecimal string.\n\n        Returns:\n            A CanonicalHash instance, or None if invalid.\n        \"\"\"\n        try:\n            return cls(hex_value)\n        except ValueError:\n            return None\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Return the hash as a lowercase hex string.\"\"\"\n        return self._hex\n\n    def as_bytes(self) -&gt; bytes:\n        \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n        return bytes.fromhex(self._hex)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the hash.\"\"\"\n        return self._hex\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a detailed string representation of the hash.\"\"\"\n        return f\"CanonicalHash({self._hex!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n        if isinstance(other, CanonicalHash):\n            return self._hex == other._hex\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n        return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n    if isinstance(other, CanonicalHash):\n        return self._hex == other._hex\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n    return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__init__","title":"__init__","text":"<pre><code>__init__(hex_value: str) -&gt; None\n</code></pre> <p>Create a CanonicalHash from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A 64-character hexadecimal string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not valid.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __init__(self, hex_value: str) -&gt; None:\n    \"\"\"Create a CanonicalHash from a hex string.\n\n    Args:\n        hex_value: A 64-character hexadecimal string.\n\n    Raises:\n        ValueError: If the string is not valid.\n    \"\"\"\n    if len(hex_value) != 64:\n        raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n    if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n        raise ValueError(\"Hash must contain only hexadecimal characters\")\n    self._hex = hex_value.lower()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a detailed string representation of the hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a detailed string representation of the hash.\"\"\"\n    return f\"CanonicalHash({self._hex!r})\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the hash.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Return the hash as bytes (32 bytes).</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def as_bytes(self) -&gt; bytes:\n    \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n    return bytes.fromhex(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Return the hash as a lowercase hex string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Return the hash as a lowercase hex string.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.from_canonical_string","title":"from_canonical_string  <code>classmethod</code>","text":"<pre><code>from_canonical_string(canonical: str) -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the given canonical string.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical string to hash.</p> required <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>@classmethod\ndef from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n    \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n    Args:\n        canonical: The canonical string to hash.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(canonical.encode(\"utf-8\"))\n    return cls(hasher.hexdigest())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(hex_value: str) -&gt; Optional[CanonicalHash]\n</code></pre> <p>Create a CanonicalHash from a pre-computed hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Optional[CanonicalHash]</code> <p>A CanonicalHash instance, or None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n    \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n    Args:\n        hex_value: A hexadecimal string.\n\n    Returns:\n        A CanonicalHash instance, or None if invalid.\n    \"\"\"\n    try:\n        return cls(hex_value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.schema_registry","title":"schema_registry","text":"<p>Central schema registry for CEP validation.</p>"},{"location":"en/api/#civic_exchange_protocol.core.schema_registry.get_registry","title":"get_registry","text":"<pre><code>get_registry() -&gt; Registry\n</code></pre> <p>Get the shared registry for validation.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/schema_registry.py</code> <pre><code>def get_registry() -&gt; Registry:\n    \"\"\"Get the shared registry for validation.\"\"\"\n    registry, _ = _build_global_registry()\n    return registry\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.schema_registry.get_schema","title":"get_schema","text":"<pre><code>get_schema(name: str, version: str | None = None) -&gt; dict\n</code></pre> <p>Get a schema by logical name and optional version.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Schema name (e.g., 'entity', 'exchange').</p> required <code>version</code> <code>str | None</code> <p>Schema version. Defaults to current SCHEMA_VERSION.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Schema as a dict.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schema name or version is unknown.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/schema_registry.py</code> <pre><code>def get_schema(name: str, version: str | None = None) -&gt; dict:\n    \"\"\"Get a schema by logical name and optional version.\n\n    Args:\n        name: Schema name (e.g., 'entity', 'exchange').\n        version: Schema version. Defaults to current SCHEMA_VERSION.\n\n    Returns:\n        Schema as a dict.\n\n    Raises:\n        ValueError: If schema name or version is unknown.\n    \"\"\"\n    if version is None:\n        version = _schema_version()\n\n    _, schemas = _build_global_registry()\n    key = (name, version)\n    if key not in schemas:\n        available = [f\"{n} v{v}\" for (n, v) in schemas if n == name]\n        if available:\n            raise ValueError(\n                f\"Unknown version {version!r} for schema {name!r}. Available: {available}\"\n            )\n        raise ValueError(f\"Unknown schema: {name!r}\")\n    return schemas[key]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.schema_registry.list_schemas","title":"list_schemas","text":"<pre><code>list_schemas() -&gt; list[tuple[str, str]]\n</code></pre> <p>List all available (name, version) pairs.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/schema_registry.py</code> <pre><code>def list_schemas() -&gt; list[tuple[str, str]]:\n    \"\"\"List all available (name, version) pairs.\"\"\"\n    return list(SCHEMA_CATALOG.keys())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp","title":"timestamp","text":"<p>Canonical timestamp handling for CEP records.</p> <p>All CEP timestamps MUST be: - UTC timezone (indicated by 'Z' suffix) - ISO 8601 format - Microsecond precision (exactly 6 decimal places)</p> <p>Example: 2025-11-28T14:30:00.000000Z</p>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp","title":"CanonicalTimestamp","text":"<p>A canonical CEP timestamp with mandatory microsecond precision.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>class CanonicalTimestamp:\n    \"\"\"A canonical CEP timestamp with mandatory microsecond precision.\"\"\"\n\n    __slots__ = (\"_dt\",)\n\n    def __init__(self, dt: datetime) -&gt; None:\n        \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n        Args:\n            dt: A datetime object. If naive, assumed to be UTC.\n                If aware, will be converted to UTC.\n        \"\"\"\n        if dt.tzinfo is None:\n            # Naive datetime - assume UTC\n            self._dt = dt.replace(tzinfo=UTC)\n        else:\n            # Convert to UTC\n            self._dt = dt.astimezone(UTC)\n\n    @classmethod\n    def now(cls) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n        return cls(datetime.now(UTC))\n\n    @classmethod\n    def parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Parse an ISO 8601 timestamp string.\n\n        Accepts formats:\n        - 2025-11-28T14:30:00.123456Z\n        - 2025-11-28T14:30:00.123456+00:00\n        - 2025-11-28T14:30:00Z (will add .000000)\n\n        Args:\n            s: The timestamp string to parse.\n\n        Returns:\n            A CanonicalTimestamp instance.\n\n        Raises:\n            ValueError: If the string cannot be parsed.\n        \"\"\"\n        # Handle Z suffix\n        if s.endswith(\"Z\"):\n            s = s[:-1] + \"+00:00\"\n\n        # Try parsing with microseconds\n        try:\n            dt = datetime.fromisoformat(s)\n            return cls(dt)\n        except ValueError:\n            pass\n\n        # Try without microseconds and add them\n        try:\n            # Remove timezone for parsing, then add back\n            if \"+\" in s:\n                base, tz = s.rsplit(\"+\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n            if s.count(\"-\") &gt; 2:  # Has negative offset\n                base, tz = s.rsplit(\"-\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n        except ValueError:\n            pass\n\n        raise ValueError(f\"Cannot parse timestamp: {s}\")\n\n    def as_datetime(self) -&gt; datetime:\n        \"\"\"Return the underlying datetime object (UTC).\"\"\"\n        return self._dt\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\n\n        Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n        This format is REQUIRED for hash stability across all CEP implementations.\n        \"\"\"\n        return self._dt.strftime(CANONICAL_FORMAT)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n        return self.to_canonical_string()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n        return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt == other._dt\n        return NotImplemented\n\n    def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt; other._dt\n        return NotImplemented\n\n    def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt;= other._dt\n        return NotImplemented\n\n    def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt; other._dt\n        return NotImplemented\n\n    def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt;= other._dt\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the timestamp.\"\"\"\n        return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt == other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than or equal to another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return the hash of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the timestamp.\"\"\"\n    return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__init__","title":"__init__","text":"<pre><code>__init__(dt: datetime) -&gt; None\n</code></pre> <p>Create a new CanonicalTimestamp from a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A datetime object. If naive, assumed to be UTC. If aware, will be converted to UTC.</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __init__(self, dt: datetime) -&gt; None:\n    \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n    Args:\n        dt: A datetime object. If naive, assumed to be UTC.\n            If aware, will be converted to UTC.\n    \"\"\"\n    if dt.tzinfo is None:\n        # Naive datetime - assume UTC\n        self._dt = dt.replace(tzinfo=UTC)\n    else:\n        # Convert to UTC\n        self._dt = dt.astimezone(UTC)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__le__","title":"__le__","text":"<pre><code>__le__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than or equal to another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the developer-friendly representation of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n    return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the canonical string representation of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n    return self.to_canonical_string()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.as_datetime","title":"as_datetime","text":"<pre><code>as_datetime() -&gt; datetime\n</code></pre> <p>Return the underlying datetime object (UTC).</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def as_datetime(self) -&gt; datetime:\n    \"\"\"Return the underlying datetime object (UTC).\"\"\"\n    return self._dt\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.now","title":"now  <code>classmethod</code>","text":"<pre><code>now() -&gt; CanonicalTimestamp\n</code></pre> <p>Return the current UTC time as a CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n    return cls(datetime.now(UTC))\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(s: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse an ISO 8601 timestamp string.</p> <p>Accepts formats: - 2025-11-28T14:30:00.123456Z - 2025-11-28T14:30:00.123456+00:00 - 2025-11-28T14:30:00Z (will add .000000)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The timestamp string to parse.</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>A CanonicalTimestamp instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string cannot be parsed.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Parse an ISO 8601 timestamp string.\n\n    Accepts formats:\n    - 2025-11-28T14:30:00.123456Z\n    - 2025-11-28T14:30:00.123456+00:00\n    - 2025-11-28T14:30:00Z (will add .000000)\n\n    Args:\n        s: The timestamp string to parse.\n\n    Returns:\n        A CanonicalTimestamp instance.\n\n    Raises:\n        ValueError: If the string cannot be parsed.\n    \"\"\"\n    # Handle Z suffix\n    if s.endswith(\"Z\"):\n        s = s[:-1] + \"+00:00\"\n\n    # Try parsing with microseconds\n    try:\n        dt = datetime.fromisoformat(s)\n        return cls(dt)\n    except ValueError:\n        pass\n\n    # Try without microseconds and add them\n    try:\n        # Remove timezone for parsing, then add back\n        if \"+\" in s:\n            base, tz = s.rsplit(\"+\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n        if s.count(\"-\") &gt; 2:  # Has negative offset\n            base, tz = s.rsplit(\"-\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n    except ValueError:\n        pass\n\n    raise ValueError(f\"Cannot parse timestamp: {s}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> <p>Format: YYYY-MM-DDTHH:MM:SS.ffffffZ</p> <p>This format is REQUIRED for hash stability across all CEP implementations.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\n\n    Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n    This format is REQUIRED for hash stability across all CEP implementations.\n    \"\"\"\n    return self._dt.strftime(CANONICAL_FORMAT)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.version","title":"version","text":"<p>CEP version constants.</p>"},{"location":"en/api/#civic_exchange_protocol.entity","title":"entity","text":"<p>CEP Entity - Entity records for the Civic Exchange Protocol.</p> <p>This package defines the EntityRecord type, which represents a verified civic entity. Entities are the foundational primitive in CEP data models, as all relationships and exchanges reference attested entities.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.AdditionalScheme","title":"AdditionalScheme  <code>dataclass</code>","text":"<p>An additional identifier scheme not explicitly defined in the schema.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass\nclass AdditionalScheme:\n    \"\"\"An additional identifier scheme not explicitly defined in the schema.\"\"\"\n\n    scheme_uri: str\n    value: str\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.CanadianBn","title":"CanadianBn  <code>dataclass</code>","text":"<p>Canadian Business Number with program account.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass CanadianBn:\n    \"\"\"Canadian Business Number with program account.\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the Canadian BN format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid Canadian BN: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        # Pattern: 9 digits + 2 letters + 4 digits (e.g., 123456789RC0001)\n        if len(value) != 15:\n            return False\n        digits1 = value[:9]\n        letters = value[9:11]\n        digits2 = value[11:15]\n        return digits1.isdigit() and letters.isalpha() and letters.isupper() and digits2.isdigit()\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"CanadianBn\"]:\n        \"\"\"Create a new Canadian BN, returning None if invalid.\"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the Canadian BN as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.CanadianBn.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the Canadian BN format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the Canadian BN format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid Canadian BN: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.CanadianBn.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the Canadian BN as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the Canadian BN as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.CanadianBn.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[CanadianBn]\n</code></pre> <p>Create a new Canadian BN, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"CanadianBn\"]:\n    \"\"\"Create a new Canadian BN, returning None if invalid.\"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityBuildResult","title":"EntityBuildResult  <code>dataclass</code>","text":"<p>Result of building an entity from raw data.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity_builder.py</code> <pre><code>@dataclass\nclass EntityBuildResult:\n    \"\"\"Result of building an entity from raw data.\"\"\"\n\n    entity: dict[str, Any]\n    snfei_result: SnfeiResult\n    warnings: list[str]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers","title":"EntityIdentifiers  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Collection of all known identifiers for an entity.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass\nclass EntityIdentifiers(Canonicalize):\n    \"\"\"Collection of all known identifiers for an entity.\"\"\"\n\n    sam_uei: SamUei | None = None\n    lei: Lei | None = None\n    snfei: Snfei | None = None\n    canadian_bn: CanadianBn | None = None\n    additional_schemes: list[AdditionalScheme] | None = None\n\n    def with_sam_uei(self, uei: SamUei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the SAM UEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=uei,\n            lei=self.lei,\n            snfei=self.snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def with_lei(self, lei: Lei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the LEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=self.sam_uei,\n            lei=lei,\n            snfei=self.snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def with_snfei(self, snfei: Snfei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the SNFEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=self.sam_uei,\n            lei=self.lei,\n            snfei=snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if at least one identifier is present.\"\"\"\n        return (\n            self.sam_uei is not None\n            or self.lei is not None\n            or self.snfei is not None\n            or self.canadian_bn is not None\n            or (self.additional_schemes is not None and len(self.additional_schemes) &gt; 0)\n        )\n\n    def primary_identifier(self) -&gt; str | None:\n        \"\"\"Return the 'best' identifier for use as the verifiable ID.\n\n        Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional\n        \"\"\"\n        if self.lei is not None:\n            return f\"cep-entity:lei:{self.lei.as_str()}\"\n        if self.sam_uei is not None:\n            return f\"cep-entity:sam-uei:{self.sam_uei.as_str()}\"\n        if self.snfei is not None:\n            return f\"cep-entity:snfei:{self.snfei.as_str()}\"\n        if self.canadian_bn is not None:\n            return f\"cep-entity:canadian-bn:{self.canadian_bn.as_str()}\"\n        if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n            return f\"cep-entity:other:{self.additional_schemes[0].value}\"\n        return None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Additional schemes serialized as JSON array string\n        if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n            sorted_schemes = sorted(self.additional_schemes, key=lambda x: x.scheme_uri)\n            schemes_data = [{\"schemeUri\": s.scheme_uri, \"value\": s.value} for s in sorted_schemes]\n            fields[\"additionalSchemes\"] = json.dumps(schemes_data, separators=(\",\", \":\"))\n\n        insert_if_present(\n            fields, \"canadianBn\", self.canadian_bn.as_str() if self.canadian_bn else None\n        )\n        insert_if_present(fields, \"lei\", self.lei.as_str() if self.lei else None)\n        insert_if_present(fields, \"samUei\", self.sam_uei.as_str() if self.sam_uei else None)\n        insert_if_present(fields, \"snfei\", self.snfei.as_str() if self.snfei else None)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Additional schemes serialized as JSON array string\n    if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n        sorted_schemes = sorted(self.additional_schemes, key=lambda x: x.scheme_uri)\n        schemes_data = [{\"schemeUri\": s.scheme_uri, \"value\": s.value} for s in sorted_schemes]\n        fields[\"additionalSchemes\"] = json.dumps(schemes_data, separators=(\",\", \":\"))\n\n    insert_if_present(\n        fields, \"canadianBn\", self.canadian_bn.as_str() if self.canadian_bn else None\n    )\n    insert_if_present(fields, \"lei\", self.lei.as_str() if self.lei else None)\n    insert_if_present(fields, \"samUei\", self.sam_uei.as_str() if self.sam_uei else None)\n    insert_if_present(fields, \"snfei\", self.snfei.as_str() if self.snfei else None)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if at least one identifier is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if at least one identifier is present.\"\"\"\n    return (\n        self.sam_uei is not None\n        or self.lei is not None\n        or self.snfei is not None\n        or self.canadian_bn is not None\n        or (self.additional_schemes is not None and len(self.additional_schemes) &gt; 0)\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.primary_identifier","title":"primary_identifier","text":"<pre><code>primary_identifier() -&gt; str | None\n</code></pre> <p>Return the 'best' identifier for use as the verifiable ID.</p> <p>Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def primary_identifier(self) -&gt; str | None:\n    \"\"\"Return the 'best' identifier for use as the verifiable ID.\n\n    Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional\n    \"\"\"\n    if self.lei is not None:\n        return f\"cep-entity:lei:{self.lei.as_str()}\"\n    if self.sam_uei is not None:\n        return f\"cep-entity:sam-uei:{self.sam_uei.as_str()}\"\n    if self.snfei is not None:\n        return f\"cep-entity:snfei:{self.snfei.as_str()}\"\n    if self.canadian_bn is not None:\n        return f\"cep-entity:canadian-bn:{self.canadian_bn.as_str()}\"\n    if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n        return f\"cep-entity:other:{self.additional_schemes[0].value}\"\n    return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.with_lei","title":"with_lei","text":"<pre><code>with_lei(lei: Lei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the LEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_lei(self, lei: Lei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the LEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=self.sam_uei,\n        lei=lei,\n        snfei=self.snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.with_sam_uei","title":"with_sam_uei","text":"<pre><code>with_sam_uei(uei: SamUei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the SAM UEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_sam_uei(self, uei: SamUei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the SAM UEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=uei,\n        lei=self.lei,\n        snfei=self.snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.with_snfei","title":"with_snfei","text":"<pre><code>with_snfei(snfei: Snfei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the SNFEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_snfei(self, snfei: Snfei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the SNFEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=self.sam_uei,\n        lei=self.lei,\n        snfei=snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord","title":"EntityRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Entity Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass EntityRecord(Canonicalize):\n    \"\"\"A complete CEP Entity Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    identifiers: EntityIdentifiers\n    legal_name: str\n    jurisdiction_iso: str\n    status: EntityStatus\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    legal_name_normalized: str | None = None\n    entity_type_uri: str | None = None\n    naics_code: str | None = None\n    resolution_confidence: ResolutionConfidence | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new(\n        cls,\n        verifiable_id: str,\n        identifiers: EntityIdentifiers,\n        legal_name: str,\n        jurisdiction_iso: str,\n        status: EntityStatus,\n        attestation: Attestation,\n    ) -&gt; \"EntityRecord\":\n        \"\"\"Create a new EntityRecord with required fields.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            identifiers=identifiers,\n            legal_name=legal_name,\n            jurisdiction_iso=jurisdiction_iso,\n            status=status,\n            attestation=attestation,\n        )\n\n    def with_normalized_name(self, name: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the normalized name set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=name,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_entity_type(self, uri: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the entity type URI set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_naics(self, code: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the NAICS code set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_resolution_confidence(self, confidence: ResolutionConfidence) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with resolution confidence set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the previous hash set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the revision number set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate that the record has all required fields properly set.\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        if self.schema_version != SCHEMA_VERSION:\n            raise ValueError(f\"Unsupported schema version: {self.schema_version}\")\n        if not self.verifiable_id:\n            raise ValueError(\"verifiableId is required\")\n        if not self.identifiers.has_any():\n            raise ValueError(\"At least one identifier is required\")\n        if not self.legal_name:\n            raise ValueError(\"legalName is required\")\n        if not self.jurisdiction_iso:\n            raise ValueError(\"jurisdictionIso is required\")\n        if self.revision_number &lt; 1:\n            raise ValueError(\"revisionNumber must be &gt;= 1\")\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n        insert_if_present(fields, \"entityTypeUri\", self.entity_type_uri)\n\n        # Identifiers is a nested object\n        identifiers_canonical = self.identifiers.to_canonical_string()\n        if identifiers_canonical:\n            insert_required(fields, \"identifiers\", identifiers_canonical)\n\n        insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n        insert_required(fields, \"legalName\", self.legal_name)\n        insert_if_present(fields, \"legalNameNormalized\", self.legal_name_normalized)\n        insert_if_present(fields, \"naicsCode\", self.naics_code)\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n        # Resolution confidence is a nested object\n        if self.resolution_confidence is not None:\n            insert_required(\n                fields, \"resolutionConfidence\", self.resolution_confidence.to_canonical_string()\n            )\n\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Status is a nested object\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n    insert_if_present(fields, \"entityTypeUri\", self.entity_type_uri)\n\n    # Identifiers is a nested object\n    identifiers_canonical = self.identifiers.to_canonical_string()\n    if identifiers_canonical:\n        insert_required(fields, \"identifiers\", identifiers_canonical)\n\n    insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n    insert_required(fields, \"legalName\", self.legal_name)\n    insert_if_present(fields, \"legalNameNormalized\", self.legal_name_normalized)\n    insert_if_present(fields, \"naicsCode\", self.naics_code)\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n    # Resolution confidence is a nested object\n    if self.resolution_confidence is not None:\n        insert_required(\n            fields, \"resolutionConfidence\", self.resolution_confidence.to_canonical_string()\n        )\n\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Status is a nested object\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    verifiable_id: str,\n    identifiers: EntityIdentifiers,\n    legal_name: str,\n    jurisdiction_iso: str,\n    status: EntityStatus,\n    attestation: Attestation,\n) -&gt; EntityRecord\n</code></pre> <p>Create a new EntityRecord with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    verifiable_id: str,\n    identifiers: EntityIdentifiers,\n    legal_name: str,\n    jurisdiction_iso: str,\n    status: EntityStatus,\n    attestation: Attestation,\n) -&gt; \"EntityRecord\":\n    \"\"\"Create a new EntityRecord with required fields.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        identifiers=identifiers,\n        legal_name=legal_name,\n        jurisdiction_iso=jurisdiction_iso,\n        status=status,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate that the record has all required fields properly set.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate that the record has all required fields properly set.\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    if self.schema_version != SCHEMA_VERSION:\n        raise ValueError(f\"Unsupported schema version: {self.schema_version}\")\n    if not self.verifiable_id:\n        raise ValueError(\"verifiableId is required\")\n    if not self.identifiers.has_any():\n        raise ValueError(\"At least one identifier is required\")\n    if not self.legal_name:\n        raise ValueError(\"legalName is required\")\n    if not self.jurisdiction_iso:\n        raise ValueError(\"jurisdictionIso is required\")\n    if self.revision_number &lt; 1:\n        raise ValueError(\"revisionNumber must be &gt;= 1\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_entity_type","title":"with_entity_type","text":"<pre><code>with_entity_type(uri: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the entity type URI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_entity_type(self, uri: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the entity type URI set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_naics","title":"with_naics","text":"<pre><code>with_naics(code: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the NAICS code set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_naics(self, code: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the NAICS code set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_normalized_name","title":"with_normalized_name","text":"<pre><code>with_normalized_name(name: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the normalized name set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_normalized_name(self, name: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the normalized name set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=name,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(hash_val: CanonicalHash) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the previous hash set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_resolution_confidence","title":"with_resolution_confidence","text":"<pre><code>with_resolution_confidence(\n    confidence: ResolutionConfidence,\n) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with resolution confidence set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_resolution_confidence(self, confidence: ResolutionConfidence) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with resolution confidence set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the revision number set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatus","title":"EntityStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Entity status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass EntityStatus(Canonicalize):\n    \"\"\"Entity status information.\"\"\"\n\n    status_code: EntityStatusCode\n    status_effective_date: str  # YYYY-MM-DD format\n    status_termination_date: str | None = None\n    successor_entity_id: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for entity status.\n\n        Returns:\n        dict[str, str]\n            A dictionary containing the canonical representation of status fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(fields, \"statusEffectiveDate\", self.status_effective_date)\n        insert_if_present(fields, \"statusTerminationDate\", self.status_termination_date)\n        insert_if_present(fields, \"successorEntityId\", self.successor_entity_id)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for entity status.</p> <p>dict[str, str]     A dictionary containing the canonical representation of status fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for entity status.\n\n    Returns:\n    dict[str, str]\n        A dictionary containing the canonical representation of status fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(fields, \"statusEffectiveDate\", self.status_effective_date)\n    insert_if_present(fields, \"statusTerminationDate\", self.status_termination_date)\n    insert_if_present(fields, \"successorEntityId\", self.successor_entity_id)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatusCode","title":"EntityStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Entity operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>class EntityStatusCode(Enum):\n    \"\"\"Entity operational status.\"\"\"\n\n    ACTIVE = \"ACTIVE\"\n    INACTIVE = \"INACTIVE\"\n    SUSPENDED = \"SUSPENDED\"\n    DISSOLVED = \"DISSOLVED\"\n    MERGED = \"MERGED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string representation of the status code.\n\n        Returns:\n        -------\n        str\n            The status code value as a string.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string representation of the status code.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatusCode.as_str--returns","title":"Returns:","text":"<p>str     The status code value as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string representation of the status code.\n\n    Returns:\n    -------\n    str\n        The status code value as a string.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Lei","title":"Lei  <code>dataclass</code>","text":"<p>Legal Entity Identifier per ISO 17442 (20 alphanumeric characters).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass Lei:\n    \"\"\"Legal Entity Identifier per ISO 17442 (20 alphanumeric characters).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the LEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid LEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return len(value) == 20 and value.isalnum()\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"Lei\"]:\n        \"\"\"Create a new LEI, returning None if invalid.\"\"\"\n        try:\n            return cls(value.upper())\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the LEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Lei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the LEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the LEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid LEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Lei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the LEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the LEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Lei.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[Lei]\n</code></pre> <p>Create a new LEI, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"Lei\"]:\n    \"\"\"Create a new LEI, returning None if invalid.\"\"\"\n    try:\n        return cls(value.upper())\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.ResolutionConfidence","title":"ResolutionConfidence  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Entity resolution confidence metadata.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass ResolutionConfidence(Canonicalize):\n    \"\"\"Entity resolution confidence metadata.\"\"\"\n\n    score: float  # 0.0 to 1.0\n    method_uri: str | None = None\n    source_record_count: int | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for resolution confidence.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical representation of resolution confidence fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"methodUri\", self.method_uri)\n        # Score formatted to 2 decimal places\n        insert_required(fields, \"score\", f\"{self.score:.2f}\")\n        if self.source_record_count is not None:\n            insert_required(fields, \"sourceRecordCount\", str(self.source_record_count))\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.ResolutionConfidence.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for resolution confidence.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.ResolutionConfidence.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical representation of resolution confidence fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for resolution confidence.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical representation of resolution confidence fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"methodUri\", self.method_uri)\n    # Score formatted to 2 decimal places\n    insert_required(fields, \"score\", f\"{self.score:.2f}\")\n    if self.source_record_count is not None:\n        insert_required(fields, \"sourceRecordCount\", str(self.source_record_count))\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.SamUei","title":"SamUei  <code>dataclass</code>","text":"<p>SAM.gov Unique Entity Identifier (12 alphanumeric characters).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass SamUei:\n    \"\"\"SAM.gov Unique Entity Identifier (12 alphanumeric characters).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the SAM UEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid SAM UEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return (\n            len(value) == 12 and all(c.isupper() or c.isdigit() for c in value) and value.isalnum()\n        )\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"SamUei\"]:\n        \"\"\"Create a new SAM UEI, returning None if invalid.\"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the SAM UEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.SamUei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the SAM UEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the SAM UEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid SAM UEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.SamUei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the SAM UEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the SAM UEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.SamUei.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[SamUei]\n</code></pre> <p>Create a new SAM UEI, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"SamUei\"]:\n    \"\"\"Create a new SAM UEI, returning None if invalid.\"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei","title":"Snfei  <code>dataclass</code>","text":"<p>A validated SNFEI (64-character lowercase hex string).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>@dataclass(frozen=True)\nclass Snfei:\n    \"\"\"A validated SNFEI (64-character lowercase hex string).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate SNFEI format after initialization.\"\"\"\n        if len(self.value) != 64:\n            raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n        if not all(c in \"0123456789abcdef\" for c in self.value):\n            raise ValueError(\"SNFEI must be lowercase hex\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of SNFEI.\"\"\"\n        return self.value\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n        return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the hash value (for API compatibility).\"\"\"\n        return self.value\n\n    def short(self, length: int = 12) -&gt; str:\n        \"\"\"Return a shortened version for display.\"\"\"\n        return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate SNFEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate SNFEI format after initialization.\"\"\"\n    if len(self.value) != 64:\n        raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n    if not all(c in \"0123456789abcdef\" for c in self.value):\n        raise ValueError(\"SNFEI must be lowercase hex\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return abbreviated representation of SNFEI.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n    return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation of SNFEI.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of SNFEI.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the hash value (for API compatibility).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the hash value (for API compatibility).\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.short","title":"short","text":"<pre><code>short(length: int = 12) -&gt; str\n</code></pre> <p>Return a shortened version for display.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def short(self, length: int = 12) -&gt; str:\n    \"\"\"Return a shortened version for display.\"\"\"\n    return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity","title":"entity","text":"<p>CEP Entity Record definition.</p> <p>The Entity Record is the foundational primitive in CEP. It represents a verified civic entity (government agency, contractor, nonprofit, individual). All relationships and exchanges reference attested entities.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord","title":"EntityRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Entity Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass EntityRecord(Canonicalize):\n    \"\"\"A complete CEP Entity Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    identifiers: EntityIdentifiers\n    legal_name: str\n    jurisdiction_iso: str\n    status: EntityStatus\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    legal_name_normalized: str | None = None\n    entity_type_uri: str | None = None\n    naics_code: str | None = None\n    resolution_confidence: ResolutionConfidence | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new(\n        cls,\n        verifiable_id: str,\n        identifiers: EntityIdentifiers,\n        legal_name: str,\n        jurisdiction_iso: str,\n        status: EntityStatus,\n        attestation: Attestation,\n    ) -&gt; \"EntityRecord\":\n        \"\"\"Create a new EntityRecord with required fields.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            identifiers=identifiers,\n            legal_name=legal_name,\n            jurisdiction_iso=jurisdiction_iso,\n            status=status,\n            attestation=attestation,\n        )\n\n    def with_normalized_name(self, name: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the normalized name set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=name,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_entity_type(self, uri: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the entity type URI set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_naics(self, code: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the NAICS code set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_resolution_confidence(self, confidence: ResolutionConfidence) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with resolution confidence set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the previous hash set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the revision number set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate that the record has all required fields properly set.\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        if self.schema_version != SCHEMA_VERSION:\n            raise ValueError(f\"Unsupported schema version: {self.schema_version}\")\n        if not self.verifiable_id:\n            raise ValueError(\"verifiableId is required\")\n        if not self.identifiers.has_any():\n            raise ValueError(\"At least one identifier is required\")\n        if not self.legal_name:\n            raise ValueError(\"legalName is required\")\n        if not self.jurisdiction_iso:\n            raise ValueError(\"jurisdictionIso is required\")\n        if self.revision_number &lt; 1:\n            raise ValueError(\"revisionNumber must be &gt;= 1\")\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n        insert_if_present(fields, \"entityTypeUri\", self.entity_type_uri)\n\n        # Identifiers is a nested object\n        identifiers_canonical = self.identifiers.to_canonical_string()\n        if identifiers_canonical:\n            insert_required(fields, \"identifiers\", identifiers_canonical)\n\n        insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n        insert_required(fields, \"legalName\", self.legal_name)\n        insert_if_present(fields, \"legalNameNormalized\", self.legal_name_normalized)\n        insert_if_present(fields, \"naicsCode\", self.naics_code)\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n        # Resolution confidence is a nested object\n        if self.resolution_confidence is not None:\n            insert_required(\n                fields, \"resolutionConfidence\", self.resolution_confidence.to_canonical_string()\n            )\n\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Status is a nested object\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n    insert_if_present(fields, \"entityTypeUri\", self.entity_type_uri)\n\n    # Identifiers is a nested object\n    identifiers_canonical = self.identifiers.to_canonical_string()\n    if identifiers_canonical:\n        insert_required(fields, \"identifiers\", identifiers_canonical)\n\n    insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n    insert_required(fields, \"legalName\", self.legal_name)\n    insert_if_present(fields, \"legalNameNormalized\", self.legal_name_normalized)\n    insert_if_present(fields, \"naicsCode\", self.naics_code)\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n    # Resolution confidence is a nested object\n    if self.resolution_confidence is not None:\n        insert_required(\n            fields, \"resolutionConfidence\", self.resolution_confidence.to_canonical_string()\n        )\n\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Status is a nested object\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    verifiable_id: str,\n    identifiers: EntityIdentifiers,\n    legal_name: str,\n    jurisdiction_iso: str,\n    status: EntityStatus,\n    attestation: Attestation,\n) -&gt; EntityRecord\n</code></pre> <p>Create a new EntityRecord with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    verifiable_id: str,\n    identifiers: EntityIdentifiers,\n    legal_name: str,\n    jurisdiction_iso: str,\n    status: EntityStatus,\n    attestation: Attestation,\n) -&gt; \"EntityRecord\":\n    \"\"\"Create a new EntityRecord with required fields.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        identifiers=identifiers,\n        legal_name=legal_name,\n        jurisdiction_iso=jurisdiction_iso,\n        status=status,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate that the record has all required fields properly set.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate that the record has all required fields properly set.\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    if self.schema_version != SCHEMA_VERSION:\n        raise ValueError(f\"Unsupported schema version: {self.schema_version}\")\n    if not self.verifiable_id:\n        raise ValueError(\"verifiableId is required\")\n    if not self.identifiers.has_any():\n        raise ValueError(\"At least one identifier is required\")\n    if not self.legal_name:\n        raise ValueError(\"legalName is required\")\n    if not self.jurisdiction_iso:\n        raise ValueError(\"jurisdictionIso is required\")\n    if self.revision_number &lt; 1:\n        raise ValueError(\"revisionNumber must be &gt;= 1\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_entity_type","title":"with_entity_type","text":"<pre><code>with_entity_type(uri: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the entity type URI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_entity_type(self, uri: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the entity type URI set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_naics","title":"with_naics","text":"<pre><code>with_naics(code: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the NAICS code set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_naics(self, code: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the NAICS code set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_normalized_name","title":"with_normalized_name","text":"<pre><code>with_normalized_name(name: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the normalized name set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_normalized_name(self, name: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the normalized name set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=name,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(hash_val: CanonicalHash) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the previous hash set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_resolution_confidence","title":"with_resolution_confidence","text":"<pre><code>with_resolution_confidence(\n    confidence: ResolutionConfidence,\n) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with resolution confidence set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_resolution_confidence(self, confidence: ResolutionConfidence) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with resolution confidence set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the revision number set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatus","title":"EntityStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Entity status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass EntityStatus(Canonicalize):\n    \"\"\"Entity status information.\"\"\"\n\n    status_code: EntityStatusCode\n    status_effective_date: str  # YYYY-MM-DD format\n    status_termination_date: str | None = None\n    successor_entity_id: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for entity status.\n\n        Returns:\n        dict[str, str]\n            A dictionary containing the canonical representation of status fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(fields, \"statusEffectiveDate\", self.status_effective_date)\n        insert_if_present(fields, \"statusTerminationDate\", self.status_termination_date)\n        insert_if_present(fields, \"successorEntityId\", self.successor_entity_id)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for entity status.</p> <p>dict[str, str]     A dictionary containing the canonical representation of status fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for entity status.\n\n    Returns:\n    dict[str, str]\n        A dictionary containing the canonical representation of status fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(fields, \"statusEffectiveDate\", self.status_effective_date)\n    insert_if_present(fields, \"statusTerminationDate\", self.status_termination_date)\n    insert_if_present(fields, \"successorEntityId\", self.successor_entity_id)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatusCode","title":"EntityStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Entity operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>class EntityStatusCode(Enum):\n    \"\"\"Entity operational status.\"\"\"\n\n    ACTIVE = \"ACTIVE\"\n    INACTIVE = \"INACTIVE\"\n    SUSPENDED = \"SUSPENDED\"\n    DISSOLVED = \"DISSOLVED\"\n    MERGED = \"MERGED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string representation of the status code.\n\n        Returns:\n        -------\n        str\n            The status code value as a string.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string representation of the status code.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatusCode.as_str--returns","title":"Returns:","text":"<p>str     The status code value as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string representation of the status code.\n\n    Returns:\n    -------\n    str\n        The status code value as a string.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.ResolutionConfidence","title":"ResolutionConfidence  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Entity resolution confidence metadata.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass ResolutionConfidence(Canonicalize):\n    \"\"\"Entity resolution confidence metadata.\"\"\"\n\n    score: float  # 0.0 to 1.0\n    method_uri: str | None = None\n    source_record_count: int | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for resolution confidence.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical representation of resolution confidence fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"methodUri\", self.method_uri)\n        # Score formatted to 2 decimal places\n        insert_required(fields, \"score\", f\"{self.score:.2f}\")\n        if self.source_record_count is not None:\n            insert_required(fields, \"sourceRecordCount\", str(self.source_record_count))\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.ResolutionConfidence.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for resolution confidence.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.ResolutionConfidence.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical representation of resolution confidence fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for resolution confidence.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical representation of resolution confidence fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"methodUri\", self.method_uri)\n    # Score formatted to 2 decimal places\n    insert_required(fields, \"score\", f\"{self.score:.2f}\")\n    if self.source_record_count is not None:\n        insert_required(fields, \"sourceRecordCount\", str(self.source_record_count))\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity_builder","title":"entity_builder","text":"<p>Entity builder: raw data -&gt; canonical CEP Entity.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.entity_builder.EntityBuildResult","title":"EntityBuildResult  <code>dataclass</code>","text":"<p>Result of building an entity from raw data.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity_builder.py</code> <pre><code>@dataclass\nclass EntityBuildResult:\n    \"\"\"Result of building an entity from raw data.\"\"\"\n\n    entity: dict[str, Any]\n    snfei_result: SnfeiResult\n    warnings: list[str]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity_builder.build_entity","title":"build_entity","text":"<pre><code>build_entity(raw: dict[str, Any]) -&gt; EntityBuildResult\n</code></pre> <p>Build a canonical CEP entity from raw input data.</p> Applies the normalizing functor pipeline <p>Raw -&gt; Localized -&gt; Normalized -&gt; Canonical Entity + SNFEI</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>dict[str, Any]</code> <p>Dictionary with raw entity fields.</p> required <p>Returns:</p> Type Description <code>EntityBuildResult</code> <p>EntityBuildResult with entity, SNFEI result, and warnings.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required fields are missing.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity_builder.py</code> <pre><code>def build_entity(raw: dict[str, Any]) -&gt; EntityBuildResult:\n    \"\"\"Build a canonical CEP entity from raw input data.\n\n    Applies the normalizing functor pipeline:\n        Raw -&gt; Localized -&gt; Normalized -&gt; Canonical Entity + SNFEI\n\n    Args:\n        raw: Dictionary with raw entity fields.\n\n    Returns:\n        EntityBuildResult with entity, SNFEI result, and warnings.\n\n    Raises:\n        ValueError: If required fields are missing.\n    \"\"\"\n    mapped, warnings = map_fields(raw)\n    validate_required(mapped)\n\n    legal_name = localize_name(\n        mapped[\"legal_name\"],\n        mapped.get(\"jurisdiction\"),\n        mapped[\"country_code\"],\n    )\n\n    snfei_result = generate_snfei(\n        legal_name=legal_name,\n        country_code=mapped[\"country_code\"],\n        address=mapped.get(\"address\"),\n        registration_date=mapped.get(\"registration_date\"),\n    )\n\n    entity = build_entity_dict(mapped, legal_name, snfei_result.snfei.value)\n\n    return EntityBuildResult(\n        entity=entity,\n        snfei_result=snfei_result,\n        warnings=warnings,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity_builder.build_entity_dict","title":"build_entity_dict","text":"<pre><code>build_entity_dict(\n    mapped: dict[str, Any],\n    legal_name: str,\n    snfei_value: str,\n) -&gt; dict[str, Any]\n</code></pre> <p>Build the canonical entity dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>mapped</code> <code>dict[str, Any]</code> <p>Canonical field dict.</p> required <code>legal_name</code> <code>str</code> <p>Localized legal name.</p> required <code>snfei_value</code> <code>str</code> <p>Computed SNFEI hash string.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>CEP entity dictionary.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity_builder.py</code> <pre><code>def build_entity_dict(\n    mapped: dict[str, Any],\n    legal_name: str,\n    snfei_value: str,\n) -&gt; dict[str, Any]:\n    \"\"\"Build the canonical entity dictionary.\n\n    Args:\n        mapped: Canonical field dict.\n        legal_name: Localized legal name.\n        snfei_value: Computed SNFEI hash string.\n\n    Returns:\n        CEP entity dictionary.\n    \"\"\"\n    now = CanonicalTimestamp.now()\n\n    entity: dict[str, Any] = {\n        \"@context\": \"https://civic-exchange.org/contexts/entity/v1\",\n        \"@type\": \"CepEntity\",\n        \"snfei\": snfei_value,\n        \"legalName\": legal_name,\n        \"entityType\": normalize_entity_type(mapped.get(\"entity_type\")),\n        \"jurisdiction\": mapped.get(\"jurisdiction\"),\n        \"countryCode\": mapped[\"country_code\"],\n        \"createdAt\": str(now),\n        \"updatedAt\": str(now),\n    }\n\n    if mapped.get(\"address\"):\n        entity[\"address\"] = normalize_address(mapped[\"address\"])\n\n    if mapped.get(\"registration_date\"):\n        entity[\"registrationDate\"] = mapped[\"registration_date\"]\n\n    if mapped.get(\"source_id\"):\n        entity[\"sourceIdentifiers\"] = [{\"system\": \"source\", \"value\": mapped[\"source_id\"]}]\n\n    return entity\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity_builder.localize_name","title":"localize_name","text":"<pre><code>localize_name(\n    legal_name: str,\n    jurisdiction: str | None,\n    country_code: str,\n) -&gt; str\n</code></pre> <p>Apply jurisdiction-specific localization to legal name.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>jurisdiction</code> <code>str | None</code> <p>Jurisdiction code (e.g., \"US-IL\").</p> required <code>country_code</code> <code>str</code> <p>Country code fallback (e.g., \"US\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>Localized legal name.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity_builder.py</code> <pre><code>def localize_name(legal_name: str, jurisdiction: str | None, country_code: str) -&gt; str:\n    \"\"\"Apply jurisdiction-specific localization to legal name.\n\n    Args:\n        legal_name: Raw legal name.\n        jurisdiction: Jurisdiction code (e.g., \"US-IL\").\n        country_code: Country code fallback (e.g., \"US\").\n\n    Returns:\n        Localized legal name.\n    \"\"\"\n    return apply_localization(legal_name, jurisdiction or country_code)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity_builder.map_fields","title":"map_fields","text":"<pre><code>map_fields(\n    raw: dict[str, Any],\n) -&gt; tuple[dict[str, Any], list[str]]\n</code></pre> <p>Map raw field names to canonical names.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>dict[str, Any]</code> <p>Dictionary with raw entity fields.</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, Any], list[str]]</code> <p>Tuple of (mapped fields dict, list of warnings).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity_builder.py</code> <pre><code>def map_fields(raw: dict[str, Any]) -&gt; tuple[dict[str, Any], list[str]]:\n    \"\"\"Map raw field names to canonical names.\n\n    Args:\n        raw: Dictionary with raw entity fields.\n\n    Returns:\n        Tuple of (mapped fields dict, list of warnings).\n    \"\"\"\n    mapped = {}\n    warnings = []\n\n    for raw_key, canonical_key in FIELD_MAP.items():\n        if raw_key in raw:\n            mapped[canonical_key] = raw[raw_key]\n\n    for key in raw:\n        if key not in FIELD_MAP:\n            warnings.append(f\"Unknown field ignored: {key!r}\")\n\n    return mapped, warnings\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity_builder.normalize_entity_type","title":"normalize_entity_type","text":"<pre><code>normalize_entity_type(raw_type: str | None) -&gt; str\n</code></pre> <p>Normalize entity type to CEP vocabulary.</p> <p>Parameters:</p> Name Type Description Default <code>raw_type</code> <code>str | None</code> <p>Raw entity type string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized entity type.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity_builder.py</code> <pre><code>def normalize_entity_type(raw_type: str | None) -&gt; str:\n    \"\"\"Normalize entity type to CEP vocabulary.\n\n    Args:\n        raw_type: Raw entity type string.\n\n    Returns:\n        Normalized entity type.\n    \"\"\"\n    if not raw_type:\n        return \"OTHER\"\n    return ENTITY_TYPE_MAP.get(raw_type.upper(), raw_type.lower())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity_builder.validate_required","title":"validate_required","text":"<pre><code>validate_required(mapped: dict[str, Any]) -&gt; None\n</code></pre> <p>Validate that required fields are present and non-null.</p> <p>Parameters:</p> Name Type Description Default <code>mapped</code> <code>dict[str, Any]</code> <p>Dictionary with canonical field names.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If required fields are missing or null.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity_builder.py</code> <pre><code>def validate_required(mapped: dict[str, Any]) -&gt; None:\n    \"\"\"Validate that required fields are present and non-null.\n\n    Args:\n        mapped: Dictionary with canonical field names.\n\n    Raises:\n        ValueError: If required fields are missing or null.\n    \"\"\"\n    missing = SNFEI_REQUIRED - set(mapped.keys())\n    if missing:\n        raise ValueError(f\"Missing required fields: {missing}\")\n\n    for field in SNFEI_REQUIRED:\n        if mapped.get(field) is None:\n            raise ValueError(f\"Required field {field!r} cannot be null\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers","title":"identifiers","text":"<p>Entity identifier types for CEP.</p> <p>CEP supports multiple identifier schemes organized into tiers:</p> <ul> <li>Tier 1 (Global): LEI (Legal Entity Identifier)</li> <li>Tier 2 (Federal): SAM.gov UEI</li> <li>Tier 3 (Sub-National): SNFEI (generated hash-based identifier)</li> <li>Extended: Canadian BN, UK Companies House, etc.</li> </ul>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.AdditionalScheme","title":"AdditionalScheme  <code>dataclass</code>","text":"<p>An additional identifier scheme not explicitly defined in the schema.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass\nclass AdditionalScheme:\n    \"\"\"An additional identifier scheme not explicitly defined in the schema.\"\"\"\n\n    scheme_uri: str\n    value: str\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.CanadianBn","title":"CanadianBn  <code>dataclass</code>","text":"<p>Canadian Business Number with program account.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass CanadianBn:\n    \"\"\"Canadian Business Number with program account.\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the Canadian BN format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid Canadian BN: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        # Pattern: 9 digits + 2 letters + 4 digits (e.g., 123456789RC0001)\n        if len(value) != 15:\n            return False\n        digits1 = value[:9]\n        letters = value[9:11]\n        digits2 = value[11:15]\n        return digits1.isdigit() and letters.isalpha() and letters.isupper() and digits2.isdigit()\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"CanadianBn\"]:\n        \"\"\"Create a new Canadian BN, returning None if invalid.\"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the Canadian BN as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.CanadianBn.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the Canadian BN format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the Canadian BN format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid Canadian BN: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.CanadianBn.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the Canadian BN as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the Canadian BN as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.CanadianBn.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[CanadianBn]\n</code></pre> <p>Create a new Canadian BN, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"CanadianBn\"]:\n    \"\"\"Create a new Canadian BN, returning None if invalid.\"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers","title":"EntityIdentifiers  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Collection of all known identifiers for an entity.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass\nclass EntityIdentifiers(Canonicalize):\n    \"\"\"Collection of all known identifiers for an entity.\"\"\"\n\n    sam_uei: SamUei | None = None\n    lei: Lei | None = None\n    snfei: Snfei | None = None\n    canadian_bn: CanadianBn | None = None\n    additional_schemes: list[AdditionalScheme] | None = None\n\n    def with_sam_uei(self, uei: SamUei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the SAM UEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=uei,\n            lei=self.lei,\n            snfei=self.snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def with_lei(self, lei: Lei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the LEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=self.sam_uei,\n            lei=lei,\n            snfei=self.snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def with_snfei(self, snfei: Snfei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the SNFEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=self.sam_uei,\n            lei=self.lei,\n            snfei=snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if at least one identifier is present.\"\"\"\n        return (\n            self.sam_uei is not None\n            or self.lei is not None\n            or self.snfei is not None\n            or self.canadian_bn is not None\n            or (self.additional_schemes is not None and len(self.additional_schemes) &gt; 0)\n        )\n\n    def primary_identifier(self) -&gt; str | None:\n        \"\"\"Return the 'best' identifier for use as the verifiable ID.\n\n        Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional\n        \"\"\"\n        if self.lei is not None:\n            return f\"cep-entity:lei:{self.lei.as_str()}\"\n        if self.sam_uei is not None:\n            return f\"cep-entity:sam-uei:{self.sam_uei.as_str()}\"\n        if self.snfei is not None:\n            return f\"cep-entity:snfei:{self.snfei.as_str()}\"\n        if self.canadian_bn is not None:\n            return f\"cep-entity:canadian-bn:{self.canadian_bn.as_str()}\"\n        if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n            return f\"cep-entity:other:{self.additional_schemes[0].value}\"\n        return None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Additional schemes serialized as JSON array string\n        if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n            sorted_schemes = sorted(self.additional_schemes, key=lambda x: x.scheme_uri)\n            schemes_data = [{\"schemeUri\": s.scheme_uri, \"value\": s.value} for s in sorted_schemes]\n            fields[\"additionalSchemes\"] = json.dumps(schemes_data, separators=(\",\", \":\"))\n\n        insert_if_present(\n            fields, \"canadianBn\", self.canadian_bn.as_str() if self.canadian_bn else None\n        )\n        insert_if_present(fields, \"lei\", self.lei.as_str() if self.lei else None)\n        insert_if_present(fields, \"samUei\", self.sam_uei.as_str() if self.sam_uei else None)\n        insert_if_present(fields, \"snfei\", self.snfei.as_str() if self.snfei else None)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Additional schemes serialized as JSON array string\n    if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n        sorted_schemes = sorted(self.additional_schemes, key=lambda x: x.scheme_uri)\n        schemes_data = [{\"schemeUri\": s.scheme_uri, \"value\": s.value} for s in sorted_schemes]\n        fields[\"additionalSchemes\"] = json.dumps(schemes_data, separators=(\",\", \":\"))\n\n    insert_if_present(\n        fields, \"canadianBn\", self.canadian_bn.as_str() if self.canadian_bn else None\n    )\n    insert_if_present(fields, \"lei\", self.lei.as_str() if self.lei else None)\n    insert_if_present(fields, \"samUei\", self.sam_uei.as_str() if self.sam_uei else None)\n    insert_if_present(fields, \"snfei\", self.snfei.as_str() if self.snfei else None)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if at least one identifier is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if at least one identifier is present.\"\"\"\n    return (\n        self.sam_uei is not None\n        or self.lei is not None\n        or self.snfei is not None\n        or self.canadian_bn is not None\n        or (self.additional_schemes is not None and len(self.additional_schemes) &gt; 0)\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.primary_identifier","title":"primary_identifier","text":"<pre><code>primary_identifier() -&gt; str | None\n</code></pre> <p>Return the 'best' identifier for use as the verifiable ID.</p> <p>Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def primary_identifier(self) -&gt; str | None:\n    \"\"\"Return the 'best' identifier for use as the verifiable ID.\n\n    Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional\n    \"\"\"\n    if self.lei is not None:\n        return f\"cep-entity:lei:{self.lei.as_str()}\"\n    if self.sam_uei is not None:\n        return f\"cep-entity:sam-uei:{self.sam_uei.as_str()}\"\n    if self.snfei is not None:\n        return f\"cep-entity:snfei:{self.snfei.as_str()}\"\n    if self.canadian_bn is not None:\n        return f\"cep-entity:canadian-bn:{self.canadian_bn.as_str()}\"\n    if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n        return f\"cep-entity:other:{self.additional_schemes[0].value}\"\n    return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.with_lei","title":"with_lei","text":"<pre><code>with_lei(lei: Lei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the LEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_lei(self, lei: Lei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the LEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=self.sam_uei,\n        lei=lei,\n        snfei=self.snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.with_sam_uei","title":"with_sam_uei","text":"<pre><code>with_sam_uei(uei: SamUei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the SAM UEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_sam_uei(self, uei: SamUei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the SAM UEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=uei,\n        lei=self.lei,\n        snfei=self.snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.with_snfei","title":"with_snfei","text":"<pre><code>with_snfei(snfei: Snfei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the SNFEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_snfei(self, snfei: Snfei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the SNFEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=self.sam_uei,\n        lei=self.lei,\n        snfei=snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Lei","title":"Lei  <code>dataclass</code>","text":"<p>Legal Entity Identifier per ISO 17442 (20 alphanumeric characters).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass Lei:\n    \"\"\"Legal Entity Identifier per ISO 17442 (20 alphanumeric characters).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the LEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid LEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return len(value) == 20 and value.isalnum()\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"Lei\"]:\n        \"\"\"Create a new LEI, returning None if invalid.\"\"\"\n        try:\n            return cls(value.upper())\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the LEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Lei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the LEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the LEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid LEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Lei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the LEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the LEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Lei.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[Lei]\n</code></pre> <p>Create a new LEI, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"Lei\"]:\n    \"\"\"Create a new LEI, returning None if invalid.\"\"\"\n    try:\n        return cls(value.upper())\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.SamUei","title":"SamUei  <code>dataclass</code>","text":"<p>SAM.gov Unique Entity Identifier (12 alphanumeric characters).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass SamUei:\n    \"\"\"SAM.gov Unique Entity Identifier (12 alphanumeric characters).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the SAM UEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid SAM UEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return (\n            len(value) == 12 and all(c.isupper() or c.isdigit() for c in value) and value.isalnum()\n        )\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"SamUei\"]:\n        \"\"\"Create a new SAM UEI, returning None if invalid.\"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the SAM UEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.SamUei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the SAM UEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the SAM UEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid SAM UEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.SamUei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the SAM UEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the SAM UEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.SamUei.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[SamUei]\n</code></pre> <p>Create a new SAM UEI, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"SamUei\"]:\n    \"\"\"Create a new SAM UEI, returning None if invalid.\"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange","title":"exchange","text":"<p>CEP Exchange - Exchange records for the Civic Exchange Protocol.</p> <p>This package defines the ExchangeRecord type, which represents a verifiable value exchange (financial, in-kind, or informational) between entities within an established relationship. This is the atomic unit of civic transparency.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization","title":"ExchangeCategorization  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Categorization codes for reporting and analysis.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass ExchangeCategorization(Canonicalize):\n    \"\"\"Categorization codes for reporting and analysis.\"\"\"\n\n    cfda_number: str | None = None\n    naics_code: str | None = None\n    gtas_account_code: str | None = None\n    local_category_code: str | None = None\n    local_category_label: str | None = None\n\n    def with_cfda(self, cfda: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with CFDA set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=cfda,\n            naics_code=self.naics_code,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_naics(self, naics: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with NAICS set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=naics,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_gtas(self, gtas: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with GTAS set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=self.naics_code,\n            gtas_account_code=gtas,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_local_category(self, code: str, label: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with local category set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=self.naics_code,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=code,\n            local_category_label=label,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if any categorization is present.\"\"\"\n        return (\n            self.cfda_number is not None\n            or self.naics_code is not None\n            or self.gtas_account_code is not None\n            or self.local_category_code is not None\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the exchange categorization.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"cfdaNumber\", self.cfda_number)\n        insert_if_present(fields, \"gtasAccountCode\", self.gtas_account_code)\n        insert_if_present(fields, \"localCategoryCode\", self.local_category_code)\n        insert_if_present(fields, \"localCategoryLabel\", self.local_category_label)\n        insert_if_present(fields, \"naicsCode\", self.naics_code)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the exchange categorization.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the exchange categorization.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"cfdaNumber\", self.cfda_number)\n    insert_if_present(fields, \"gtasAccountCode\", self.gtas_account_code)\n    insert_if_present(fields, \"localCategoryCode\", self.local_category_code)\n    insert_if_present(fields, \"localCategoryLabel\", self.local_category_label)\n    insert_if_present(fields, \"naicsCode\", self.naics_code)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if any categorization is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if any categorization is present.\"\"\"\n    return (\n        self.cfda_number is not None\n        or self.naics_code is not None\n        or self.gtas_account_code is not None\n        or self.local_category_code is not None\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.with_cfda","title":"with_cfda","text":"<pre><code>with_cfda(cfda: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with CFDA set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_cfda(self, cfda: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with CFDA set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=cfda,\n        naics_code=self.naics_code,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.with_gtas","title":"with_gtas","text":"<pre><code>with_gtas(gtas: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with GTAS set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_gtas(self, gtas: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with GTAS set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=self.naics_code,\n        gtas_account_code=gtas,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.with_local_category","title":"with_local_category","text":"<pre><code>with_local_category(\n    code: str, label: str\n) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with local category set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_local_category(self, code: str, label: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with local category set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=self.naics_code,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=code,\n        local_category_label=label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.with_naics","title":"with_naics","text":"<pre><code>with_naics(naics: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with NAICS set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_naics(self, naics: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with NAICS set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=naics,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty","title":"ExchangeParty  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A party in an exchange (source or recipient).</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ExchangeParty(Canonicalize):\n    \"\"\"A party in an exchange (source or recipient).\"\"\"\n\n    entity_id: str\n    role_uri: str | None = None\n    account_identifier: str | None = None\n\n    def with_role(self, role_uri: str) -&gt; \"ExchangeParty\":\n        \"\"\"Return a new ExchangeParty with role set.\"\"\"\n        return ExchangeParty(\n            entity_id=self.entity_id,\n            role_uri=role_uri,\n            account_identifier=self.account_identifier,\n        )\n\n    def with_account(self, account: str) -&gt; \"ExchangeParty\":\n        \"\"\"Return a new ExchangeParty with account identifier set.\"\"\"\n        return ExchangeParty(\n            entity_id=self.entity_id,\n            role_uri=self.role_uri,\n            account_identifier=account,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of this party as a dictionary.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields for this exchange party.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"accountIdentifier\", self.account_identifier)\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_if_present(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of this party as a dictionary.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields for this exchange party.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of this party as a dictionary.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields for this exchange party.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"accountIdentifier\", self.account_identifier)\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_if_present(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty.with_account","title":"with_account","text":"<pre><code>with_account(account: str) -&gt; ExchangeParty\n</code></pre> <p>Return a new ExchangeParty with account identifier set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def with_account(self, account: str) -&gt; \"ExchangeParty\":\n    \"\"\"Return a new ExchangeParty with account identifier set.\"\"\"\n    return ExchangeParty(\n        entity_id=self.entity_id,\n        role_uri=self.role_uri,\n        account_identifier=account,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty.with_role","title":"with_role","text":"<pre><code>with_role(role_uri: str) -&gt; ExchangeParty\n</code></pre> <p>Return a new ExchangeParty with role set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def with_role(self, role_uri: str) -&gt; \"ExchangeParty\":\n    \"\"\"Return a new ExchangeParty with role set.\"\"\"\n    return ExchangeParty(\n        entity_id=self.entity_id,\n        role_uri=role_uri,\n        account_identifier=self.account_identifier,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord","title":"ExchangeRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Exchange Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass ExchangeRecord(Canonicalize):\n    \"\"\"A complete CEP Exchange Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    relationship_id: str\n    exchange_type_uri: str\n    source_entity: ExchangeParty\n    recipient_entity: ExchangeParty\n    value: ExchangeValue\n    occurred_timestamp: CanonicalTimestamp\n    status: ExchangeStatus\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    provenance_chain: ProvenanceChain | None = None\n    categorization: ExchangeCategorization | None = None\n    source_references: list[SourceReference] | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new(\n        cls,\n        verifiable_id: str,\n        relationship_id: str,\n        exchange_type_uri: str,\n        source_entity: ExchangeParty,\n        recipient_entity: ExchangeParty,\n        value: ExchangeValue,\n        occurred_timestamp: CanonicalTimestamp,\n        status: ExchangeStatus,\n        attestation: Attestation,\n    ) -&gt; \"ExchangeRecord\":\n        \"\"\"Create a new ExchangeRecord with required fields.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_id=relationship_id,\n            exchange_type_uri=exchange_type_uri,\n            source_entity=source_entity,\n            recipient_entity=recipient_entity,\n            value=value,\n            occurred_timestamp=occurred_timestamp,\n            status=status,\n            attestation=attestation,\n        )\n\n    def with_provenance(self, chain: ProvenanceChain) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with provenance chain set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_categorization(self, cat: ExchangeCategorization) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with categorization set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=cat,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_source_reference(self, reference: SourceReference) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with a source reference added.\"\"\"\n        refs = list(self.source_references) if self.source_references else []\n        refs.append(reference)\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=refs,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with previous hash set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with revision number set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n\n        if self.categorization is not None and self.categorization.has_any():\n            insert_required(fields, \"categorization\", self.categorization.to_canonical_string())\n\n        insert_required(fields, \"exchangeTypeUri\", self.exchange_type_uri)\n        insert_required(fields, \"occurredTimestamp\", self.occurred_timestamp.to_canonical_string())\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n        if self.provenance_chain is not None and self.provenance_chain.has_any():\n            insert_required(fields, \"provenanceChain\", self.provenance_chain.to_canonical_string())\n\n        insert_required(fields, \"recipientEntity\", self.recipient_entity.to_canonical_string())\n        insert_required(fields, \"relationshipId\", self.relationship_id)\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Source references sorted by sourceSystemUri then sourceRecordId\n        if self.source_references:\n            sorted_refs = sorted(\n                self.source_references,\n                key=lambda r: (r.source_system_uri, r.source_record_id),\n            )\n            refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n            fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n        insert_required(fields, \"sourceEntity\", self.source_entity.to_canonical_string())\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n        insert_required(fields, \"value\", self.value.to_canonical_string())\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n\n    if self.categorization is not None and self.categorization.has_any():\n        insert_required(fields, \"categorization\", self.categorization.to_canonical_string())\n\n    insert_required(fields, \"exchangeTypeUri\", self.exchange_type_uri)\n    insert_required(fields, \"occurredTimestamp\", self.occurred_timestamp.to_canonical_string())\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n    if self.provenance_chain is not None and self.provenance_chain.has_any():\n        insert_required(fields, \"provenanceChain\", self.provenance_chain.to_canonical_string())\n\n    insert_required(fields, \"recipientEntity\", self.recipient_entity.to_canonical_string())\n    insert_required(fields, \"relationshipId\", self.relationship_id)\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Source references sorted by sourceSystemUri then sourceRecordId\n    if self.source_references:\n        sorted_refs = sorted(\n            self.source_references,\n            key=lambda r: (r.source_system_uri, r.source_record_id),\n        )\n        refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n        fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n    insert_required(fields, \"sourceEntity\", self.source_entity.to_canonical_string())\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n    insert_required(fields, \"value\", self.value.to_canonical_string())\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    verifiable_id: str,\n    relationship_id: str,\n    exchange_type_uri: str,\n    source_entity: ExchangeParty,\n    recipient_entity: ExchangeParty,\n    value: ExchangeValue,\n    occurred_timestamp: CanonicalTimestamp,\n    status: ExchangeStatus,\n    attestation: Attestation,\n) -&gt; ExchangeRecord\n</code></pre> <p>Create a new ExchangeRecord with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    verifiable_id: str,\n    relationship_id: str,\n    exchange_type_uri: str,\n    source_entity: ExchangeParty,\n    recipient_entity: ExchangeParty,\n    value: ExchangeValue,\n    occurred_timestamp: CanonicalTimestamp,\n    status: ExchangeStatus,\n    attestation: Attestation,\n) -&gt; \"ExchangeRecord\":\n    \"\"\"Create a new ExchangeRecord with required fields.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_id=relationship_id,\n        exchange_type_uri=exchange_type_uri,\n        source_entity=source_entity,\n        recipient_entity=recipient_entity,\n        value=value,\n        occurred_timestamp=occurred_timestamp,\n        status=status,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_categorization","title":"with_categorization","text":"<pre><code>with_categorization(\n    cat: ExchangeCategorization,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with categorization set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_categorization(self, cat: ExchangeCategorization) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with categorization set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=cat,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(\n    hash_val: CanonicalHash,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with previous hash set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_provenance","title":"with_provenance","text":"<pre><code>with_provenance(chain: ProvenanceChain) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with provenance chain set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_provenance(self, chain: ProvenanceChain) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with provenance chain set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with revision number set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_source_reference","title":"with_source_reference","text":"<pre><code>with_source_reference(\n    reference: SourceReference,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with a source reference added.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_source_reference(self, reference: SourceReference) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with a source reference added.\"\"\"\n    refs = list(self.source_references) if self.source_references else []\n    refs.append(reference)\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=refs,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatus","title":"ExchangeStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Exchange status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass ExchangeStatus(Canonicalize):\n    \"\"\"Exchange status information.\"\"\"\n\n    status_code: ExchangeStatusCode\n    status_effective_timestamp: CanonicalTimestamp\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the exchange status.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(\n            fields,\n            \"statusEffectiveTimestamp\",\n            self.status_effective_timestamp.to_canonical_string(),\n        )\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the exchange status.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatus.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the exchange status.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(\n        fields,\n        \"statusEffectiveTimestamp\",\n        self.status_effective_timestamp.to_canonical_string(),\n    )\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatusCode","title":"ExchangeStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Exchange operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>class ExchangeStatusCode(Enum):\n    \"\"\"Exchange operational status.\"\"\"\n\n    PENDING = \"PENDING\"\n    COMPLETED = \"COMPLETED\"\n    REVERSED = \"REVERSED\"\n    CANCELED = \"CANCELED\"\n    DISPUTED = \"DISPUTED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string value of the exchange status code.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string value of the exchange status code.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string value of the exchange status code.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue","title":"ExchangeValue  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>The value being exchanged.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ExchangeValue(Canonicalize):\n    \"\"\"The value being exchanged.\"\"\"\n\n    amount: float\n    currency_code: str = \"USD\"\n    value_type_uri: str = DEFAULT_VALUE_TYPE_URI\n    in_kind_description: str | None = None\n\n    @classmethod\n    def monetary(cls, amount: float, currency_code: str = \"USD\") -&gt; \"ExchangeValue\":\n        \"\"\"Create a new monetary value.\"\"\"\n        return cls(amount=amount, currency_code=currency_code)\n\n    @classmethod\n    def usd(cls, amount: float) -&gt; \"ExchangeValue\":\n        \"\"\"Create a new USD monetary value.\"\"\"\n        return cls.monetary(amount, \"USD\")\n\n    @classmethod\n    def in_kind(cls, amount: float, description: str) -&gt; \"ExchangeValue\":\n        \"\"\"Create an in-kind value with description.\"\"\"\n        return cls(\n            amount=amount,\n            currency_code=\"USD\",\n            value_type_uri=ValueType.in_kind().type_uri,\n            in_kind_description=description,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of this value as a dictionary.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields for this exchange value.\n        \"\"\"\n        fields: dict[str, str] = {}\n        # Amount formatted to exactly 2 decimal places\n        insert_required(fields, \"amount\", format_amount(self.amount))\n        insert_required(fields, \"currencyCode\", self.currency_code)\n        insert_if_present(fields, \"inKindDescription\", self.in_kind_description)\n        insert_required(fields, \"valueTypeUri\", self.value_type_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of this value as a dictionary.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields for this exchange value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of this value as a dictionary.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields for this exchange value.\n    \"\"\"\n    fields: dict[str, str] = {}\n    # Amount formatted to exactly 2 decimal places\n    insert_required(fields, \"amount\", format_amount(self.amount))\n    insert_required(fields, \"currencyCode\", self.currency_code)\n    insert_if_present(fields, \"inKindDescription\", self.in_kind_description)\n    insert_required(fields, \"valueTypeUri\", self.value_type_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.in_kind","title":"in_kind  <code>classmethod</code>","text":"<pre><code>in_kind(amount: float, description: str) -&gt; ExchangeValue\n</code></pre> <p>Create an in-kind value with description.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef in_kind(cls, amount: float, description: str) -&gt; \"ExchangeValue\":\n    \"\"\"Create an in-kind value with description.\"\"\"\n    return cls(\n        amount=amount,\n        currency_code=\"USD\",\n        value_type_uri=ValueType.in_kind().type_uri,\n        in_kind_description=description,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.monetary","title":"monetary  <code>classmethod</code>","text":"<pre><code>monetary(\n    amount: float, currency_code: str = 'USD'\n) -&gt; ExchangeValue\n</code></pre> <p>Create a new monetary value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef monetary(cls, amount: float, currency_code: str = \"USD\") -&gt; \"ExchangeValue\":\n    \"\"\"Create a new monetary value.\"\"\"\n    return cls(amount=amount, currency_code=currency_code)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.usd","title":"usd  <code>classmethod</code>","text":"<pre><code>usd(amount: float) -&gt; ExchangeValue\n</code></pre> <p>Create a new USD monetary value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef usd(cls, amount: float) -&gt; \"ExchangeValue\":\n    \"\"\"Create a new USD monetary value.\"\"\"\n    return cls.monetary(amount, \"USD\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.IntermediaryEntity","title":"IntermediaryEntity  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>An intermediary entity in the funding chain.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass IntermediaryEntity(Canonicalize):\n    \"\"\"An intermediary entity in the funding chain.\"\"\"\n\n    entity_id: str\n    role_uri: str | None = None\n\n    def with_role(self, role_uri: str) -&gt; \"IntermediaryEntity\":\n        \"\"\"Return a new IntermediaryEntity with role set.\"\"\"\n        return IntermediaryEntity(entity_id=self.entity_id, role_uri=role_uri)\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the intermediary entity.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_if_present(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.IntermediaryEntity.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the intermediary entity.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.IntermediaryEntity.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the intermediary entity.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_if_present(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.IntermediaryEntity.with_role","title":"with_role","text":"<pre><code>with_role(role_uri: str) -&gt; IntermediaryEntity\n</code></pre> <p>Return a new IntermediaryEntity with role set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_role(self, role_uri: str) -&gt; \"IntermediaryEntity\":\n    \"\"\"Return a new IntermediaryEntity with role set.\"\"\"\n    return IntermediaryEntity(entity_id=self.entity_id, role_uri=role_uri)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain","title":"ProvenanceChain  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Provenance chain tracing the flow of funds.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass ProvenanceChain(Canonicalize):\n    \"\"\"Provenance chain tracing the flow of funds.\"\"\"\n\n    funding_chain_tag: str | None = None\n    ultimate_source_entity_id: str | None = None\n    intermediary_entities: list[IntermediaryEntity] | None = None\n    parent_exchange_id: str | None = None\n\n    def with_funding_chain_tag(self, tag: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with funding chain tag set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_ultimate_source(self, entity_id: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with ultimate source set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_intermediary(self, entity: IntermediaryEntity) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with an intermediary added.\"\"\"\n        entities = list(self.intermediary_entities) if self.intermediary_entities else []\n        entities.append(entity)\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_parent_exchange(self, exchange_id: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with parent exchange set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=exchange_id,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if any provenance information is present.\"\"\"\n        return (\n            self.funding_chain_tag is not None\n            or self.ultimate_source_entity_id is not None\n            or (self.intermediary_entities is not None and len(self.intermediary_entities) &gt; 0)\n            or self.parent_exchange_id is not None\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the provenance chain.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n\n        insert_if_present(fields, \"fundingChainTag\", self.funding_chain_tag)\n\n        # Intermediary entities serialized as array\n        if self.intermediary_entities:\n            entities_json = \",\".join(e.to_canonical_string() for e in self.intermediary_entities)\n            fields[\"intermediaryEntities\"] = f\"[{entities_json}]\"\n\n        insert_if_present(fields, \"parentExchangeId\", self.parent_exchange_id)\n        insert_if_present(fields, \"ultimateSourceEntityId\", self.ultimate_source_entity_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the provenance chain.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the provenance chain.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n\n    insert_if_present(fields, \"fundingChainTag\", self.funding_chain_tag)\n\n    # Intermediary entities serialized as array\n    if self.intermediary_entities:\n        entities_json = \",\".join(e.to_canonical_string() for e in self.intermediary_entities)\n        fields[\"intermediaryEntities\"] = f\"[{entities_json}]\"\n\n    insert_if_present(fields, \"parentExchangeId\", self.parent_exchange_id)\n    insert_if_present(fields, \"ultimateSourceEntityId\", self.ultimate_source_entity_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if any provenance information is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if any provenance information is present.\"\"\"\n    return (\n        self.funding_chain_tag is not None\n        or self.ultimate_source_entity_id is not None\n        or (self.intermediary_entities is not None and len(self.intermediary_entities) &gt; 0)\n        or self.parent_exchange_id is not None\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.with_funding_chain_tag","title":"with_funding_chain_tag","text":"<pre><code>with_funding_chain_tag(tag: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with funding chain tag set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_funding_chain_tag(self, tag: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with funding chain tag set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.with_intermediary","title":"with_intermediary","text":"<pre><code>with_intermediary(\n    entity: IntermediaryEntity,\n) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with an intermediary added.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_intermediary(self, entity: IntermediaryEntity) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with an intermediary added.\"\"\"\n    entities = list(self.intermediary_entities) if self.intermediary_entities else []\n    entities.append(entity)\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.with_parent_exchange","title":"with_parent_exchange","text":"<pre><code>with_parent_exchange(exchange_id: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with parent exchange set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_parent_exchange(self, exchange_id: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with parent exchange set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.with_ultimate_source","title":"with_ultimate_source","text":"<pre><code>with_ultimate_source(entity_id: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with ultimate source set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_ultimate_source(self, entity_id: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with ultimate source set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.SourceReference","title":"SourceReference  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Reference to an authoritative source record.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass SourceReference(Canonicalize):\n    \"\"\"Reference to an authoritative source record.\"\"\"\n\n    source_system_uri: str\n    source_record_id: str\n    source_url: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the source reference.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"sourceRecordId\", self.source_record_id)\n        insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n        insert_if_present(fields, \"sourceUrl\", self.source_url)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.SourceReference.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the source reference.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.SourceReference.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the source reference.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"sourceRecordId\", self.source_record_id)\n    insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n    insert_if_present(fields, \"sourceUrl\", self.source_url)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ValueType","title":"ValueType  <code>dataclass</code>","text":"<p>The type of value being exchanged.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ValueType:\n    \"\"\"The type of value being exchanged.\"\"\"\n\n    type_uri: str\n\n    @classmethod\n    def monetary(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for monetary exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#monetary\"\n        )\n\n    @classmethod\n    def in_kind(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for in-kind exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#in-kind\"\n        )\n\n    @classmethod\n    def service_hours(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for service hours exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#service-hours\"\n        )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ValueType.in_kind","title":"in_kind  <code>classmethod</code>","text":"<pre><code>in_kind() -&gt; ValueType\n</code></pre> <p>Return a ValueType for in-kind exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef in_kind(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for in-kind exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#in-kind\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ValueType.monetary","title":"monetary  <code>classmethod</code>","text":"<pre><code>monetary() -&gt; ValueType\n</code></pre> <p>Return a ValueType for monetary exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef monetary(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for monetary exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#monetary\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ValueType.service_hours","title":"service_hours  <code>classmethod</code>","text":"<pre><code>service_hours() -&gt; ValueType\n</code></pre> <p>Return a ValueType for service hours exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef service_hours(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for service hours exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#service-hours\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange","title":"exchange","text":"<p>CEP Exchange Record definition.</p> <p>An Exchange Record represents a verifiable value exchange (financial, in-kind, or informational) between entities within an established relationship. This is the atomic unit of civic transparency.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord","title":"ExchangeRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Exchange Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass ExchangeRecord(Canonicalize):\n    \"\"\"A complete CEP Exchange Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    relationship_id: str\n    exchange_type_uri: str\n    source_entity: ExchangeParty\n    recipient_entity: ExchangeParty\n    value: ExchangeValue\n    occurred_timestamp: CanonicalTimestamp\n    status: ExchangeStatus\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    provenance_chain: ProvenanceChain | None = None\n    categorization: ExchangeCategorization | None = None\n    source_references: list[SourceReference] | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new(\n        cls,\n        verifiable_id: str,\n        relationship_id: str,\n        exchange_type_uri: str,\n        source_entity: ExchangeParty,\n        recipient_entity: ExchangeParty,\n        value: ExchangeValue,\n        occurred_timestamp: CanonicalTimestamp,\n        status: ExchangeStatus,\n        attestation: Attestation,\n    ) -&gt; \"ExchangeRecord\":\n        \"\"\"Create a new ExchangeRecord with required fields.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_id=relationship_id,\n            exchange_type_uri=exchange_type_uri,\n            source_entity=source_entity,\n            recipient_entity=recipient_entity,\n            value=value,\n            occurred_timestamp=occurred_timestamp,\n            status=status,\n            attestation=attestation,\n        )\n\n    def with_provenance(self, chain: ProvenanceChain) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with provenance chain set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_categorization(self, cat: ExchangeCategorization) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with categorization set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=cat,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_source_reference(self, reference: SourceReference) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with a source reference added.\"\"\"\n        refs = list(self.source_references) if self.source_references else []\n        refs.append(reference)\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=refs,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with previous hash set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with revision number set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n\n        if self.categorization is not None and self.categorization.has_any():\n            insert_required(fields, \"categorization\", self.categorization.to_canonical_string())\n\n        insert_required(fields, \"exchangeTypeUri\", self.exchange_type_uri)\n        insert_required(fields, \"occurredTimestamp\", self.occurred_timestamp.to_canonical_string())\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n        if self.provenance_chain is not None and self.provenance_chain.has_any():\n            insert_required(fields, \"provenanceChain\", self.provenance_chain.to_canonical_string())\n\n        insert_required(fields, \"recipientEntity\", self.recipient_entity.to_canonical_string())\n        insert_required(fields, \"relationshipId\", self.relationship_id)\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Source references sorted by sourceSystemUri then sourceRecordId\n        if self.source_references:\n            sorted_refs = sorted(\n                self.source_references,\n                key=lambda r: (r.source_system_uri, r.source_record_id),\n            )\n            refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n            fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n        insert_required(fields, \"sourceEntity\", self.source_entity.to_canonical_string())\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n        insert_required(fields, \"value\", self.value.to_canonical_string())\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n\n    if self.categorization is not None and self.categorization.has_any():\n        insert_required(fields, \"categorization\", self.categorization.to_canonical_string())\n\n    insert_required(fields, \"exchangeTypeUri\", self.exchange_type_uri)\n    insert_required(fields, \"occurredTimestamp\", self.occurred_timestamp.to_canonical_string())\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n    if self.provenance_chain is not None and self.provenance_chain.has_any():\n        insert_required(fields, \"provenanceChain\", self.provenance_chain.to_canonical_string())\n\n    insert_required(fields, \"recipientEntity\", self.recipient_entity.to_canonical_string())\n    insert_required(fields, \"relationshipId\", self.relationship_id)\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Source references sorted by sourceSystemUri then sourceRecordId\n    if self.source_references:\n        sorted_refs = sorted(\n            self.source_references,\n            key=lambda r: (r.source_system_uri, r.source_record_id),\n        )\n        refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n        fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n    insert_required(fields, \"sourceEntity\", self.source_entity.to_canonical_string())\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n    insert_required(fields, \"value\", self.value.to_canonical_string())\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    verifiable_id: str,\n    relationship_id: str,\n    exchange_type_uri: str,\n    source_entity: ExchangeParty,\n    recipient_entity: ExchangeParty,\n    value: ExchangeValue,\n    occurred_timestamp: CanonicalTimestamp,\n    status: ExchangeStatus,\n    attestation: Attestation,\n) -&gt; ExchangeRecord\n</code></pre> <p>Create a new ExchangeRecord with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    verifiable_id: str,\n    relationship_id: str,\n    exchange_type_uri: str,\n    source_entity: ExchangeParty,\n    recipient_entity: ExchangeParty,\n    value: ExchangeValue,\n    occurred_timestamp: CanonicalTimestamp,\n    status: ExchangeStatus,\n    attestation: Attestation,\n) -&gt; \"ExchangeRecord\":\n    \"\"\"Create a new ExchangeRecord with required fields.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_id=relationship_id,\n        exchange_type_uri=exchange_type_uri,\n        source_entity=source_entity,\n        recipient_entity=recipient_entity,\n        value=value,\n        occurred_timestamp=occurred_timestamp,\n        status=status,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_categorization","title":"with_categorization","text":"<pre><code>with_categorization(\n    cat: ExchangeCategorization,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with categorization set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_categorization(self, cat: ExchangeCategorization) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with categorization set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=cat,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(\n    hash_val: CanonicalHash,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with previous hash set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_provenance","title":"with_provenance","text":"<pre><code>with_provenance(chain: ProvenanceChain) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with provenance chain set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_provenance(self, chain: ProvenanceChain) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with provenance chain set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with revision number set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_source_reference","title":"with_source_reference","text":"<pre><code>with_source_reference(\n    reference: SourceReference,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with a source reference added.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_source_reference(self, reference: SourceReference) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with a source reference added.\"\"\"\n    refs = list(self.source_references) if self.source_references else []\n    refs.append(reference)\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=refs,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatus","title":"ExchangeStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Exchange status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass ExchangeStatus(Canonicalize):\n    \"\"\"Exchange status information.\"\"\"\n\n    status_code: ExchangeStatusCode\n    status_effective_timestamp: CanonicalTimestamp\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the exchange status.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(\n            fields,\n            \"statusEffectiveTimestamp\",\n            self.status_effective_timestamp.to_canonical_string(),\n        )\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the exchange status.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatus.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the exchange status.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(\n        fields,\n        \"statusEffectiveTimestamp\",\n        self.status_effective_timestamp.to_canonical_string(),\n    )\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatusCode","title":"ExchangeStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Exchange operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>class ExchangeStatusCode(Enum):\n    \"\"\"Exchange operational status.\"\"\"\n\n    PENDING = \"PENDING\"\n    COMPLETED = \"COMPLETED\"\n    REVERSED = \"REVERSED\"\n    CANCELED = \"CANCELED\"\n    DISPUTED = \"DISPUTED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string value of the exchange status code.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string value of the exchange status code.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string value of the exchange status code.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.SourceReference","title":"SourceReference  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Reference to an authoritative source record.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass SourceReference(Canonicalize):\n    \"\"\"Reference to an authoritative source record.\"\"\"\n\n    source_system_uri: str\n    source_record_id: str\n    source_url: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the source reference.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"sourceRecordId\", self.source_record_id)\n        insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n        insert_if_present(fields, \"sourceUrl\", self.source_url)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.SourceReference.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the source reference.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.SourceReference.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the source reference.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"sourceRecordId\", self.source_record_id)\n    insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n    insert_if_present(fields, \"sourceUrl\", self.source_url)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder","title":"exchange_builder","text":"<p>Exchange builder: raw data -&gt; canonical CEP Exchange Record.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.ExchangeBuildResult","title":"ExchangeBuildResult  <code>dataclass</code>","text":"<p>Result of building an exchange from raw data.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>@dataclass\nclass ExchangeBuildResult:\n    \"\"\"Result of building an exchange from raw data.\"\"\"\n\n    exchange: ExchangeRecord\n    warnings: list[str]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.build_attestation","title":"build_attestation","text":"<pre><code>build_attestation(\n    raw_attestation: dict[str, Any],\n) -&gt; Attestation\n</code></pre> <p>Build an Attestation from raw attestation data.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def build_attestation(raw_attestation: dict[str, Any]) -&gt; Attestation:\n    \"\"\"Build an Attestation from raw attestation data.\"\"\"\n    attested_by = raw_attestation.get(\"attestedBy\", \"unknown\")\n    timestamp_str = raw_attestation.get(\"attestationTimestamp\", \"\")\n    timestamp = CanonicalTimestamp.parse(timestamp_str)\n\n    return Attestation.new(\n        attestor_id=attested_by,\n        attestation_timestamp=timestamp,\n        proof_type=\"ManualAttestation\",\n        proof_value=\"\",  # No cryptographic proof for manual attestations\n        verification_method_uri=f\"urn:cep:attestor:{attested_by.replace(' ', '-').lower()}\",\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.build_categorization","title":"build_categorization","text":"<pre><code>build_categorization(\n    mapped: dict[str, Any],\n) -&gt; ExchangeCategorization | None\n</code></pre> <p>Build categorization from mapped fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def build_categorization(mapped: dict[str, Any]) -&gt; ExchangeCategorization | None:\n    \"\"\"Build categorization from mapped fields.\"\"\"\n    cfda = mapped.get(\"cfda_number\")\n    naics = mapped.get(\"naics_code\")\n    gtas = mapped.get(\"gtas_account_code\")\n    local_code = mapped.get(\"local_category_code\")\n    local_label = mapped.get(\"local_category_label\") or mapped.get(\"description\")\n\n    if not any([cfda, naics, gtas, local_code]):\n        return None\n\n    return ExchangeCategorization(\n        cfda_number=cfda,\n        naics_code=naics,\n        gtas_account_code=gtas,\n        local_category_code=local_code,\n        local_category_label=local_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.build_exchange","title":"build_exchange","text":"<pre><code>build_exchange(raw: dict[str, Any]) -&gt; ExchangeBuildResult\n</code></pre> <p>Build a canonical CEP Exchange Record from raw input data.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def build_exchange(raw: dict[str, Any]) -&gt; ExchangeBuildResult:\n    \"\"\"Build a canonical CEP Exchange Record from raw input data.\"\"\"\n    mapped, warnings = map_fields(raw)\n    validate_required(mapped)\n\n    attestation = build_attestation(mapped[\"attestation\"])\n    occurred_timestamp = parse_timestamp(mapped[\"occurred_date\"])\n    exchange = build_exchange_record(mapped, attestation, occurred_timestamp)\n\n    return ExchangeBuildResult(\n        exchange=exchange,\n        warnings=warnings,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.build_exchange_party","title":"build_exchange_party","text":"<pre><code>build_exchange_party(entity_id: str) -&gt; ExchangeParty\n</code></pre> <p>Build an ExchangeParty from an entity ID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier string.</p> required <p>Returns:</p> Type Description <code>ExchangeParty</code> <p>ExchangeParty object.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def build_exchange_party(entity_id: str) -&gt; ExchangeParty:\n    \"\"\"Build an ExchangeParty from an entity ID.\n\n    Args:\n        entity_id: Entity identifier string.\n\n    Returns:\n        ExchangeParty object.\n    \"\"\"\n    return ExchangeParty(entity_id=entity_id)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.build_exchange_record","title":"build_exchange_record","text":"<pre><code>build_exchange_record(\n    mapped: dict[str, Any],\n    attestation: Attestation,\n    occurred_timestamp: CanonicalTimestamp,\n) -&gt; ExchangeRecord\n</code></pre> <p>Build the canonical ExchangeRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def build_exchange_record(\n    mapped: dict[str, Any],\n    attestation: Attestation,\n    occurred_timestamp: CanonicalTimestamp,\n) -&gt; ExchangeRecord:\n    \"\"\"Build the canonical ExchangeRecord.\"\"\"\n    exchange_type_uri = parse_exchange_type_uri(mapped[\"exchange_type\"])\n    source_party = build_exchange_party(mapped[\"source_entity_id\"])\n    recipient_party = build_exchange_party(mapped[\"recipient_entity_id\"])\n    value = build_exchange_value(mapped[\"amount\"], mapped[\"currency\"])\n\n    status = ExchangeStatus(\n        status_code=ExchangeStatusCode.COMPLETED,\n        status_effective_timestamp=occurred_timestamp,\n    )\n\n    relationship_id = f\"rel:{mapped['source_entity_id']}:{mapped['recipient_entity_id']}\"\n\n    record = ExchangeRecord.new(\n        verifiable_id=mapped[\"exchange_id\"],\n        relationship_id=relationship_id,\n        exchange_type_uri=exchange_type_uri,\n        source_entity=source_party,\n        recipient_entity=recipient_party,\n        value=value,\n        occurred_timestamp=occurred_timestamp,\n        status=status,\n        attestation=attestation,\n    )\n\n    categorization = build_categorization(mapped)\n    if categorization:\n        record = record.with_categorization(categorization)\n\n    source_ref = build_source_reference(mapped)\n    if source_ref:\n        record = record.with_source_reference(source_ref)\n\n    return record\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.build_exchange_value","title":"build_exchange_value","text":"<pre><code>build_exchange_value(\n    amount: float, currency: str\n) -&gt; ExchangeValue\n</code></pre> <p>Build an ExchangeValue from amount and currency.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def build_exchange_value(amount: float, currency: str) -&gt; ExchangeValue:\n    \"\"\"Build an ExchangeValue from amount and currency.\"\"\"\n    return ExchangeValue.monetary(amount, currency)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.build_source_reference","title":"build_source_reference","text":"<pre><code>build_source_reference(\n    mapped: dict[str, Any],\n) -&gt; SourceReference | None\n</code></pre> <p>Build a source reference if data is available.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def build_source_reference(mapped: dict[str, Any]) -&gt; SourceReference | None:\n    \"\"\"Build a source reference if data is available.\"\"\"\n    source_system = mapped.get(\"source_system\")\n    source_record_id = mapped.get(\"source_record_id\")\n    source_url = mapped.get(\"source_url\")\n\n    if not source_system or not source_record_id:\n        return None\n\n    return SourceReference(\n        source_system_uri=source_system,\n        source_record_id=source_record_id,\n        source_url=source_url,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.map_fields","title":"map_fields","text":"<pre><code>map_fields(\n    raw: dict[str, Any],\n) -&gt; tuple[dict[str, Any], list[str]]\n</code></pre> <p>Map raw field names to canonical names.</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>dict[str, Any]</code> <p>Dictionary with raw exchange fields.</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, Any], list[str]]</code> <p>Tuple of (mapped fields dict, list of warnings).</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def map_fields(raw: dict[str, Any]) -&gt; tuple[dict[str, Any], list[str]]:\n    \"\"\"Map raw field names to canonical names.\n\n    Args:\n        raw: Dictionary with raw exchange fields.\n\n    Returns:\n        Tuple of (mapped fields dict, list of warnings).\n    \"\"\"\n    mapped: dict[str, Any] = {}\n    warnings: list[str] = []\n\n    for raw_key, value in raw.items():\n        if raw_key in FIELD_MAP:\n            canonical_key = FIELD_MAP[raw_key]\n            mapped[canonical_key] = value\n        else:\n            warnings.append(f\"Unknown field ignored: {raw_key!r}\")\n\n    return mapped, warnings\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.parse_exchange_type_uri","title":"parse_exchange_type_uri","text":"<pre><code>parse_exchange_type_uri(exchange_type: str) -&gt; str\n</code></pre> <p>Convert exchange type to URI.</p> <p>Parameters:</p> Name Type Description Default <code>exchange_type</code> <code>str</code> <p>Raw exchange type (e.g., \"GRANT\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>Exchange type URI.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def parse_exchange_type_uri(exchange_type: str) -&gt; str:\n    \"\"\"Convert exchange type to URI.\n\n    Args:\n        exchange_type: Raw exchange type (e.g., \"GRANT\").\n\n    Returns:\n        Exchange type URI.\n    \"\"\"\n    upper = exchange_type.upper()\n    if upper in EXCHANGE_TYPE_URI_MAP:\n        return EXCHANGE_TYPE_URI_MAP[upper]\n    return f\"https://civic-exchange.org/types/{exchange_type.lower()}\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.parse_timestamp","title":"parse_timestamp","text":"<pre><code>parse_timestamp(date_str: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse a date or datetime string to CanonicalTimestamp.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string (e.g., \"2024-05-15\" or \"2024-05-15T14:02:10Z\").</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def parse_timestamp(date_str: str) -&gt; CanonicalTimestamp:\n    \"\"\"Parse a date or datetime string to CanonicalTimestamp.\n\n    Args:\n        date_str: Date string (e.g., \"2024-05-15\" or \"2024-05-15T14:02:10Z\").\n\n    Returns:\n        CanonicalTimestamp.\n    \"\"\"\n    # If it's just a date, add midnight UTC\n    if \"T\" not in date_str:\n        date_str = f\"{date_str}T00:00:00.000000Z\"\n    return CanonicalTimestamp.parse(date_str)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange_builder.validate_required","title":"validate_required","text":"<pre><code>validate_required(mapped: dict[str, Any]) -&gt; None\n</code></pre> <p>Validate that required fields are present and non-null.</p> <p>Parameters:</p> Name Type Description Default <code>mapped</code> <code>dict[str, Any]</code> <p>Dictionary with canonical field names.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If required fields are missing or null.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange_builder.py</code> <pre><code>def validate_required(mapped: dict[str, Any]) -&gt; None:\n    \"\"\"Validate that required fields are present and non-null.\n\n    Args:\n        mapped: Dictionary with canonical field names.\n\n    Raises:\n        ValueError: If required fields are missing or null.\n    \"\"\"\n    missing = EXCHANGE_REQUIRED - set(mapped.keys())\n    if missing:\n        raise ValueError(f\"Missing required fields: {missing}\")\n\n    for field in EXCHANGE_REQUIRED:\n        if mapped.get(field) is None:\n            raise ValueError(f\"Required field {field!r} cannot be null\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance","title":"provenance","text":"<p>Provenance chain tracking for CEP exchanges.</p> <p>Traces the compositional flow of funds through the civic graph. This is the Category Theory morphism path implementation.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization","title":"ExchangeCategorization  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Categorization codes for reporting and analysis.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass ExchangeCategorization(Canonicalize):\n    \"\"\"Categorization codes for reporting and analysis.\"\"\"\n\n    cfda_number: str | None = None\n    naics_code: str | None = None\n    gtas_account_code: str | None = None\n    local_category_code: str | None = None\n    local_category_label: str | None = None\n\n    def with_cfda(self, cfda: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with CFDA set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=cfda,\n            naics_code=self.naics_code,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_naics(self, naics: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with NAICS set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=naics,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_gtas(self, gtas: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with GTAS set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=self.naics_code,\n            gtas_account_code=gtas,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_local_category(self, code: str, label: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with local category set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=self.naics_code,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=code,\n            local_category_label=label,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if any categorization is present.\"\"\"\n        return (\n            self.cfda_number is not None\n            or self.naics_code is not None\n            or self.gtas_account_code is not None\n            or self.local_category_code is not None\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the exchange categorization.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"cfdaNumber\", self.cfda_number)\n        insert_if_present(fields, \"gtasAccountCode\", self.gtas_account_code)\n        insert_if_present(fields, \"localCategoryCode\", self.local_category_code)\n        insert_if_present(fields, \"localCategoryLabel\", self.local_category_label)\n        insert_if_present(fields, \"naicsCode\", self.naics_code)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the exchange categorization.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the exchange categorization.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"cfdaNumber\", self.cfda_number)\n    insert_if_present(fields, \"gtasAccountCode\", self.gtas_account_code)\n    insert_if_present(fields, \"localCategoryCode\", self.local_category_code)\n    insert_if_present(fields, \"localCategoryLabel\", self.local_category_label)\n    insert_if_present(fields, \"naicsCode\", self.naics_code)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if any categorization is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if any categorization is present.\"\"\"\n    return (\n        self.cfda_number is not None\n        or self.naics_code is not None\n        or self.gtas_account_code is not None\n        or self.local_category_code is not None\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.with_cfda","title":"with_cfda","text":"<pre><code>with_cfda(cfda: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with CFDA set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_cfda(self, cfda: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with CFDA set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=cfda,\n        naics_code=self.naics_code,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.with_gtas","title":"with_gtas","text":"<pre><code>with_gtas(gtas: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with GTAS set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_gtas(self, gtas: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with GTAS set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=self.naics_code,\n        gtas_account_code=gtas,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.with_local_category","title":"with_local_category","text":"<pre><code>with_local_category(\n    code: str, label: str\n) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with local category set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_local_category(self, code: str, label: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with local category set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=self.naics_code,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=code,\n        local_category_label=label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.with_naics","title":"with_naics","text":"<pre><code>with_naics(naics: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with NAICS set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_naics(self, naics: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with NAICS set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=naics,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.IntermediaryEntity","title":"IntermediaryEntity  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>An intermediary entity in the funding chain.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass IntermediaryEntity(Canonicalize):\n    \"\"\"An intermediary entity in the funding chain.\"\"\"\n\n    entity_id: str\n    role_uri: str | None = None\n\n    def with_role(self, role_uri: str) -&gt; \"IntermediaryEntity\":\n        \"\"\"Return a new IntermediaryEntity with role set.\"\"\"\n        return IntermediaryEntity(entity_id=self.entity_id, role_uri=role_uri)\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the intermediary entity.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_if_present(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.IntermediaryEntity.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the intermediary entity.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.IntermediaryEntity.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the intermediary entity.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_if_present(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.IntermediaryEntity.with_role","title":"with_role","text":"<pre><code>with_role(role_uri: str) -&gt; IntermediaryEntity\n</code></pre> <p>Return a new IntermediaryEntity with role set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_role(self, role_uri: str) -&gt; \"IntermediaryEntity\":\n    \"\"\"Return a new IntermediaryEntity with role set.\"\"\"\n    return IntermediaryEntity(entity_id=self.entity_id, role_uri=role_uri)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain","title":"ProvenanceChain  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Provenance chain tracing the flow of funds.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass ProvenanceChain(Canonicalize):\n    \"\"\"Provenance chain tracing the flow of funds.\"\"\"\n\n    funding_chain_tag: str | None = None\n    ultimate_source_entity_id: str | None = None\n    intermediary_entities: list[IntermediaryEntity] | None = None\n    parent_exchange_id: str | None = None\n\n    def with_funding_chain_tag(self, tag: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with funding chain tag set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_ultimate_source(self, entity_id: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with ultimate source set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_intermediary(self, entity: IntermediaryEntity) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with an intermediary added.\"\"\"\n        entities = list(self.intermediary_entities) if self.intermediary_entities else []\n        entities.append(entity)\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_parent_exchange(self, exchange_id: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with parent exchange set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=exchange_id,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if any provenance information is present.\"\"\"\n        return (\n            self.funding_chain_tag is not None\n            or self.ultimate_source_entity_id is not None\n            or (self.intermediary_entities is not None and len(self.intermediary_entities) &gt; 0)\n            or self.parent_exchange_id is not None\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the provenance chain.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n\n        insert_if_present(fields, \"fundingChainTag\", self.funding_chain_tag)\n\n        # Intermediary entities serialized as array\n        if self.intermediary_entities:\n            entities_json = \",\".join(e.to_canonical_string() for e in self.intermediary_entities)\n            fields[\"intermediaryEntities\"] = f\"[{entities_json}]\"\n\n        insert_if_present(fields, \"parentExchangeId\", self.parent_exchange_id)\n        insert_if_present(fields, \"ultimateSourceEntityId\", self.ultimate_source_entity_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the provenance chain.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the provenance chain.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n\n    insert_if_present(fields, \"fundingChainTag\", self.funding_chain_tag)\n\n    # Intermediary entities serialized as array\n    if self.intermediary_entities:\n        entities_json = \",\".join(e.to_canonical_string() for e in self.intermediary_entities)\n        fields[\"intermediaryEntities\"] = f\"[{entities_json}]\"\n\n    insert_if_present(fields, \"parentExchangeId\", self.parent_exchange_id)\n    insert_if_present(fields, \"ultimateSourceEntityId\", self.ultimate_source_entity_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if any provenance information is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if any provenance information is present.\"\"\"\n    return (\n        self.funding_chain_tag is not None\n        or self.ultimate_source_entity_id is not None\n        or (self.intermediary_entities is not None and len(self.intermediary_entities) &gt; 0)\n        or self.parent_exchange_id is not None\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.with_funding_chain_tag","title":"with_funding_chain_tag","text":"<pre><code>with_funding_chain_tag(tag: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with funding chain tag set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_funding_chain_tag(self, tag: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with funding chain tag set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.with_intermediary","title":"with_intermediary","text":"<pre><code>with_intermediary(\n    entity: IntermediaryEntity,\n) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with an intermediary added.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_intermediary(self, entity: IntermediaryEntity) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with an intermediary added.\"\"\"\n    entities = list(self.intermediary_entities) if self.intermediary_entities else []\n    entities.append(entity)\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.with_parent_exchange","title":"with_parent_exchange","text":"<pre><code>with_parent_exchange(exchange_id: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with parent exchange set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_parent_exchange(self, exchange_id: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with parent exchange set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.with_ultimate_source","title":"with_ultimate_source","text":"<pre><code>with_ultimate_source(entity_id: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with ultimate source set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_ultimate_source(self, entity_id: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with ultimate source set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value","title":"value","text":"<p>Value types for CEP exchanges.</p> <p>Supports monetary values (with currency) and in-kind contributions.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty","title":"ExchangeParty  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A party in an exchange (source or recipient).</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ExchangeParty(Canonicalize):\n    \"\"\"A party in an exchange (source or recipient).\"\"\"\n\n    entity_id: str\n    role_uri: str | None = None\n    account_identifier: str | None = None\n\n    def with_role(self, role_uri: str) -&gt; \"ExchangeParty\":\n        \"\"\"Return a new ExchangeParty with role set.\"\"\"\n        return ExchangeParty(\n            entity_id=self.entity_id,\n            role_uri=role_uri,\n            account_identifier=self.account_identifier,\n        )\n\n    def with_account(self, account: str) -&gt; \"ExchangeParty\":\n        \"\"\"Return a new ExchangeParty with account identifier set.\"\"\"\n        return ExchangeParty(\n            entity_id=self.entity_id,\n            role_uri=self.role_uri,\n            account_identifier=account,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of this party as a dictionary.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields for this exchange party.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"accountIdentifier\", self.account_identifier)\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_if_present(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of this party as a dictionary.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields for this exchange party.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of this party as a dictionary.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields for this exchange party.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"accountIdentifier\", self.account_identifier)\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_if_present(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty.with_account","title":"with_account","text":"<pre><code>with_account(account: str) -&gt; ExchangeParty\n</code></pre> <p>Return a new ExchangeParty with account identifier set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def with_account(self, account: str) -&gt; \"ExchangeParty\":\n    \"\"\"Return a new ExchangeParty with account identifier set.\"\"\"\n    return ExchangeParty(\n        entity_id=self.entity_id,\n        role_uri=self.role_uri,\n        account_identifier=account,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty.with_role","title":"with_role","text":"<pre><code>with_role(role_uri: str) -&gt; ExchangeParty\n</code></pre> <p>Return a new ExchangeParty with role set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def with_role(self, role_uri: str) -&gt; \"ExchangeParty\":\n    \"\"\"Return a new ExchangeParty with role set.\"\"\"\n    return ExchangeParty(\n        entity_id=self.entity_id,\n        role_uri=role_uri,\n        account_identifier=self.account_identifier,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue","title":"ExchangeValue  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>The value being exchanged.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ExchangeValue(Canonicalize):\n    \"\"\"The value being exchanged.\"\"\"\n\n    amount: float\n    currency_code: str = \"USD\"\n    value_type_uri: str = DEFAULT_VALUE_TYPE_URI\n    in_kind_description: str | None = None\n\n    @classmethod\n    def monetary(cls, amount: float, currency_code: str = \"USD\") -&gt; \"ExchangeValue\":\n        \"\"\"Create a new monetary value.\"\"\"\n        return cls(amount=amount, currency_code=currency_code)\n\n    @classmethod\n    def usd(cls, amount: float) -&gt; \"ExchangeValue\":\n        \"\"\"Create a new USD monetary value.\"\"\"\n        return cls.monetary(amount, \"USD\")\n\n    @classmethod\n    def in_kind(cls, amount: float, description: str) -&gt; \"ExchangeValue\":\n        \"\"\"Create an in-kind value with description.\"\"\"\n        return cls(\n            amount=amount,\n            currency_code=\"USD\",\n            value_type_uri=ValueType.in_kind().type_uri,\n            in_kind_description=description,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of this value as a dictionary.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields for this exchange value.\n        \"\"\"\n        fields: dict[str, str] = {}\n        # Amount formatted to exactly 2 decimal places\n        insert_required(fields, \"amount\", format_amount(self.amount))\n        insert_required(fields, \"currencyCode\", self.currency_code)\n        insert_if_present(fields, \"inKindDescription\", self.in_kind_description)\n        insert_required(fields, \"valueTypeUri\", self.value_type_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of this value as a dictionary.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields for this exchange value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of this value as a dictionary.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields for this exchange value.\n    \"\"\"\n    fields: dict[str, str] = {}\n    # Amount formatted to exactly 2 decimal places\n    insert_required(fields, \"amount\", format_amount(self.amount))\n    insert_required(fields, \"currencyCode\", self.currency_code)\n    insert_if_present(fields, \"inKindDescription\", self.in_kind_description)\n    insert_required(fields, \"valueTypeUri\", self.value_type_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.in_kind","title":"in_kind  <code>classmethod</code>","text":"<pre><code>in_kind(amount: float, description: str) -&gt; ExchangeValue\n</code></pre> <p>Create an in-kind value with description.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef in_kind(cls, amount: float, description: str) -&gt; \"ExchangeValue\":\n    \"\"\"Create an in-kind value with description.\"\"\"\n    return cls(\n        amount=amount,\n        currency_code=\"USD\",\n        value_type_uri=ValueType.in_kind().type_uri,\n        in_kind_description=description,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.monetary","title":"monetary  <code>classmethod</code>","text":"<pre><code>monetary(\n    amount: float, currency_code: str = 'USD'\n) -&gt; ExchangeValue\n</code></pre> <p>Create a new monetary value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef monetary(cls, amount: float, currency_code: str = \"USD\") -&gt; \"ExchangeValue\":\n    \"\"\"Create a new monetary value.\"\"\"\n    return cls(amount=amount, currency_code=currency_code)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.usd","title":"usd  <code>classmethod</code>","text":"<pre><code>usd(amount: float) -&gt; ExchangeValue\n</code></pre> <p>Create a new USD monetary value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef usd(cls, amount: float) -&gt; \"ExchangeValue\":\n    \"\"\"Create a new USD monetary value.\"\"\"\n    return cls.monetary(amount, \"USD\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ValueType","title":"ValueType  <code>dataclass</code>","text":"<p>The type of value being exchanged.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ValueType:\n    \"\"\"The type of value being exchanged.\"\"\"\n\n    type_uri: str\n\n    @classmethod\n    def monetary(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for monetary exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#monetary\"\n        )\n\n    @classmethod\n    def in_kind(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for in-kind exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#in-kind\"\n        )\n\n    @classmethod\n    def service_hours(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for service hours exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#service-hours\"\n        )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ValueType.in_kind","title":"in_kind  <code>classmethod</code>","text":"<pre><code>in_kind() -&gt; ValueType\n</code></pre> <p>Return a ValueType for in-kind exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef in_kind(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for in-kind exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#in-kind\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ValueType.monetary","title":"monetary  <code>classmethod</code>","text":"<pre><code>monetary() -&gt; ValueType\n</code></pre> <p>Return a ValueType for monetary exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef monetary(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for monetary exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#monetary\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ValueType.service_hours","title":"service_hours  <code>classmethod</code>","text":"<pre><code>service_hours() -&gt; ValueType\n</code></pre> <p>Return a ValueType for service hours exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef service_hours(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for service hours exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#service-hours\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship","title":"relationship","text":"<p>CEP Relationship - Relationship records for the Civic Exchange Protocol.</p> <p>This package defines the RelationshipRecord type, which represents a verifiable legal or functional relationship between two or more attested entities.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.BilateralParties","title":"BilateralParties  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Bilateral parties in a two-party relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>@dataclass\nclass BilateralParties(Canonicalize):\n    \"\"\"Bilateral parties in a two-party relationship.\"\"\"\n\n    party_a: Party  # Initiating, granting, or contracting party\n    party_b: Party  # Receiving, performing, or beneficiary party\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of bilateral parties.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields with partyA and partyB.\n        \"\"\"\n        fields: dict[str, str] = {}\n        # Nested objects serialized as their canonical strings\n        insert_required(fields, \"partyA\", self.party_a.to_canonical_string())\n        insert_required(fields, \"partyB\", self.party_b.to_canonical_string())\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.BilateralParties.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of bilateral parties.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.BilateralParties.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields with partyA and partyB.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of bilateral parties.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields with partyA and partyB.\n    \"\"\"\n    fields: dict[str, str] = {}\n    # Nested objects serialized as their canonical strings\n    insert_required(fields, \"partyA\", self.party_a.to_canonical_string())\n    insert_required(fields, \"partyB\", self.party_b.to_canonical_string())\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.FinancialTerms","title":"FinancialTerms  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Financial terms of a relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass FinancialTerms(Canonicalize):\n    \"\"\"Financial terms of a relationship.\"\"\"\n\n    total_value: float | None = None\n    obligated_value: float | None = None\n    currency_code: str = \"USD\"\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of financial terms fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"currencyCode\", self.currency_code)\n        if self.obligated_value is not None:\n            insert_required(fields, \"obligatedValue\", format_amount(self.obligated_value))\n        if self.total_value is not None:\n            insert_required(fields, \"totalValue\", format_amount(self.total_value))\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.FinancialTerms.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of financial terms fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.FinancialTerms.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of financial terms fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"currencyCode\", self.currency_code)\n    if self.obligated_value is not None:\n        insert_required(fields, \"obligatedValue\", format_amount(self.obligated_value))\n    if self.total_value is not None:\n        insert_required(fields, \"totalValue\", format_amount(self.total_value))\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Member","title":"Member  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A member in a multilateral relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>@dataclass\nclass Member(Canonicalize):\n    \"\"\"A member in a multilateral relationship.\"\"\"\n\n    entity_id: str\n    role_uri: str\n    participation_share: float | None = None\n\n    def with_share(self, share: float) -&gt; \"Member\":\n        \"\"\"Return a new Member with the participation share set.\"\"\"\n        return Member(\n            entity_id=self.entity_id,\n            role_uri=self.role_uri,\n            participation_share=share,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the member.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing entityId, roleUri, and optionally participationShare.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        if self.participation_share is not None:\n            insert_required(fields, \"participationShare\", f\"{self.participation_share:.4f}\")\n        insert_required(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Member.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the member.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.Member.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing entityId, roleUri, and optionally participationShare.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the member.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing entityId, roleUri, and optionally participationShare.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    if self.participation_share is not None:\n        insert_required(fields, \"participationShare\", f\"{self.participation_share:.4f}\")\n    insert_required(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Member.with_share","title":"with_share","text":"<pre><code>with_share(share: float) -&gt; Member\n</code></pre> <p>Return a new Member with the participation share set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def with_share(self, share: float) -&gt; \"Member\":\n    \"\"\"Return a new Member with the participation share set.\"\"\"\n    return Member(\n        entity_id=self.entity_id,\n        role_uri=self.role_uri,\n        participation_share=share,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers","title":"MultilateralMembers","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A collection of members in a multilateral relationship.</p> <p>Members are automatically sorted by entity_id to ensure hash stability regardless of insertion order.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>class MultilateralMembers(Canonicalize):\n    \"\"\"A collection of members in a multilateral relationship.\n\n    Members are automatically sorted by entity_id to ensure\n    hash stability regardless of insertion order.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty collection of multilateral relationship members.\"\"\"\n        self._members: list[Member] = []\n\n    def add(self, member: Member) -&gt; None:\n        \"\"\"Add a member to the set.\"\"\"\n        # Check for duplicate entity_id\n        for existing in self._members:\n            if existing.entity_id == member.entity_id:\n                return  # Already exists\n        self._members.append(member)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of members in the collection.\"\"\"\n        return len(self._members)\n\n    def __iter__(self) -&gt; Iterator[Member]:\n        \"\"\"Iterate over members in sorted order by entity_id.\"\"\"\n        return iter(sorted(self._members, key=lambda m: m.entity_id))\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the collection has no members.\n\n        Returns:\n        -------\n        bool\n            True if the collection is empty, False otherwise.\n        \"\"\"\n        return len(self._members) == 0\n\n    def validate_shares(self) -&gt; None:\n        \"\"\"Validate that all participation shares sum to 1.0 (if present).\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        shares = [m.participation_share for m in self._members if m.participation_share is not None]\n\n        if not shares:\n            return\n\n        if len(shares) != len(self._members):\n            raise ValueError(\"All members must have participation shares if any do\")\n\n        total = sum(shares)\n        if abs(total - 1.0) &gt; 0.0001:\n            raise ValueError(f\"Participation shares must sum to 1.0, got {total:.4f}\")\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Serialize as array, members sorted by entity_id\n        if self._members:\n            sorted_members = sorted(self._members, key=lambda m: m.entity_id)\n            members_json = \",\".join(m.to_canonical_string() for m in sorted_members)\n            fields[\"members\"] = f\"[{members_json}]\"\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize an empty collection of multilateral relationship members.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty collection of multilateral relationship members.\"\"\"\n    self._members: list[Member] = []\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Member]\n</code></pre> <p>Iterate over members in sorted order by entity_id.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Member]:\n    \"\"\"Iterate over members in sorted order by entity_id.\"\"\"\n    return iter(sorted(self._members, key=lambda m: m.entity_id))\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of members in the collection.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of members in the collection.\"\"\"\n    return len(self._members)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.add","title":"add","text":"<pre><code>add(member: Member) -&gt; None\n</code></pre> <p>Add a member to the set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def add(self, member: Member) -&gt; None:\n    \"\"\"Add a member to the set.\"\"\"\n    # Check for duplicate entity_id\n    for existing in self._members:\n        if existing.entity_id == member.entity_id:\n            return  # Already exists\n    self._members.append(member)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Serialize as array, members sorted by entity_id\n    if self._members:\n        sorted_members = sorted(self._members, key=lambda m: m.entity_id)\n        members_json = \",\".join(m.to_canonical_string() for m in sorted_members)\n        fields[\"members\"] = f\"[{members_json}]\"\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the collection has no members.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.is_empty--returns","title":"Returns:","text":"<p>bool     True if the collection is empty, False otherwise.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the collection has no members.\n\n    Returns:\n    -------\n    bool\n        True if the collection is empty, False otherwise.\n    \"\"\"\n    return len(self._members) == 0\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.validate_shares","title":"validate_shares","text":"<pre><code>validate_shares() -&gt; None\n</code></pre> <p>Validate that all participation shares sum to 1.0 (if present).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def validate_shares(self) -&gt; None:\n    \"\"\"Validate that all participation shares sum to 1.0 (if present).\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    shares = [m.participation_share for m in self._members if m.participation_share is not None]\n\n    if not shares:\n        return\n\n    if len(shares) != len(self._members):\n        raise ValueError(\"All members must have participation shares if any do\")\n\n    total = sum(shares)\n    if abs(total - 1.0) &gt; 0.0001:\n        raise ValueError(f\"Participation shares must sum to 1.0, got {total:.4f}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Party","title":"Party  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A party in a bilateral relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>@dataclass\nclass Party(Canonicalize):\n    \"\"\"A party in a bilateral relationship.\"\"\"\n\n    entity_id: str\n    role_uri: str\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the party.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields with entityId and roleUri.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_required(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Party.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the party.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.Party.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields with entityId and roleUri.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the party.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields with entityId and roleUri.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_required(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord","title":"RelationshipRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Relationship Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass RelationshipRecord(Canonicalize):\n    \"\"\"A complete CEP Relationship Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    relationship_type_uri: str\n    parties: Parties\n    effective_timestamp: CanonicalTimestamp\n    status: RelationshipStatus\n    jurisdiction_iso: str\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    parent_relationship_id: str | None = None\n    expiration_timestamp: CanonicalTimestamp | None = None\n    financial_terms: FinancialTerms | None = None\n    terms_attributes: dict[str, str] | None = None\n    source_references: list[SourceReference] | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new_bilateral(\n        cls,\n        verifiable_id: str,\n        relationship_type_uri: str,\n        parties: BilateralParties,\n        effective_timestamp: CanonicalTimestamp,\n        status: RelationshipStatus,\n        jurisdiction_iso: str,\n        attestation: Attestation,\n    ) -&gt; \"RelationshipRecord\":\n        \"\"\"Create a new bilateral RelationshipRecord.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_type_uri=relationship_type_uri,\n            parties=parties,\n            effective_timestamp=effective_timestamp,\n            status=status,\n            jurisdiction_iso=jurisdiction_iso,\n            attestation=attestation,\n        )\n\n    @classmethod\n    def new_multilateral(\n        cls,\n        verifiable_id: str,\n        relationship_type_uri: str,\n        members: MultilateralMembers,\n        effective_timestamp: CanonicalTimestamp,\n        status: RelationshipStatus,\n        jurisdiction_iso: str,\n        attestation: Attestation,\n    ) -&gt; \"RelationshipRecord\":\n        \"\"\"Create a new multilateral RelationshipRecord.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_type_uri=relationship_type_uri,\n            parties=members,\n            effective_timestamp=effective_timestamp,\n            status=status,\n            jurisdiction_iso=jurisdiction_iso,\n            attestation=attestation,\n        )\n\n    def with_parent(self, parent_id: str) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with parent relationship set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=parent_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_expiration(self, timestamp: CanonicalTimestamp) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with expiration timestamp set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_financial_terms(self, terms: FinancialTerms) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with financial terms set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_source_reference(self, reference: SourceReference) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with a source reference added.\"\"\"\n        refs = list(self.source_references) if self.source_references else []\n        refs.append(reference)\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=refs,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with previous hash set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with revision number set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n        insert_required(\n            fields, \"effectiveTimestamp\", self.effective_timestamp.to_canonical_string()\n        )\n        if self.expiration_timestamp is not None:\n            insert_required(\n                fields, \"expirationTimestamp\", self.expiration_timestamp.to_canonical_string()\n            )\n        if self.financial_terms is not None:\n            insert_required(fields, \"financialTerms\", self.financial_terms.to_canonical_string())\n        insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n        insert_if_present(fields, \"parentRelationshipId\", self.parent_relationship_id)\n\n        # Parties (bilateral or multilateral)\n        if isinstance(self.parties, BilateralParties):\n            insert_required(fields, \"bilateralParties\", self.parties.to_canonical_string())\n        else:\n            insert_required(fields, \"multilateralMembers\", self.parties.to_canonical_string())\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n        insert_required(fields, \"relationshipTypeUri\", self.relationship_type_uri)\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Source references sorted by sourceSystemUri then sourceRecordId\n        if self.source_references:\n            sorted_refs = sorted(\n                self.source_references,\n                key=lambda r: (r.source_system_uri, r.source_record_id),\n            )\n            refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n            fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n\n        # Terms attributes (already sorted as dict)\n        if self.terms_attributes:\n            import json\n\n            fields[\"termsAttributes\"] = json.dumps(\n                dict(sorted(self.terms_attributes.items())), separators=(\",\", \":\")\n            )\n\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n    insert_required(\n        fields, \"effectiveTimestamp\", self.effective_timestamp.to_canonical_string()\n    )\n    if self.expiration_timestamp is not None:\n        insert_required(\n            fields, \"expirationTimestamp\", self.expiration_timestamp.to_canonical_string()\n        )\n    if self.financial_terms is not None:\n        insert_required(fields, \"financialTerms\", self.financial_terms.to_canonical_string())\n    insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n    insert_if_present(fields, \"parentRelationshipId\", self.parent_relationship_id)\n\n    # Parties (bilateral or multilateral)\n    if isinstance(self.parties, BilateralParties):\n        insert_required(fields, \"bilateralParties\", self.parties.to_canonical_string())\n    else:\n        insert_required(fields, \"multilateralMembers\", self.parties.to_canonical_string())\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n    insert_required(fields, \"relationshipTypeUri\", self.relationship_type_uri)\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Source references sorted by sourceSystemUri then sourceRecordId\n    if self.source_references:\n        sorted_refs = sorted(\n            self.source_references,\n            key=lambda r: (r.source_system_uri, r.source_record_id),\n        )\n        refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n        fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n\n    # Terms attributes (already sorted as dict)\n    if self.terms_attributes:\n        import json\n\n        fields[\"termsAttributes\"] = json.dumps(\n            dict(sorted(self.terms_attributes.items())), separators=(\",\", \":\")\n        )\n\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.new_bilateral","title":"new_bilateral  <code>classmethod</code>","text":"<pre><code>new_bilateral(\n    verifiable_id: str,\n    relationship_type_uri: str,\n    parties: BilateralParties,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; RelationshipRecord\n</code></pre> <p>Create a new bilateral RelationshipRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@classmethod\ndef new_bilateral(\n    cls,\n    verifiable_id: str,\n    relationship_type_uri: str,\n    parties: BilateralParties,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; \"RelationshipRecord\":\n    \"\"\"Create a new bilateral RelationshipRecord.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_type_uri=relationship_type_uri,\n        parties=parties,\n        effective_timestamp=effective_timestamp,\n        status=status,\n        jurisdiction_iso=jurisdiction_iso,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.new_multilateral","title":"new_multilateral  <code>classmethod</code>","text":"<pre><code>new_multilateral(\n    verifiable_id: str,\n    relationship_type_uri: str,\n    members: MultilateralMembers,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; RelationshipRecord\n</code></pre> <p>Create a new multilateral RelationshipRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@classmethod\ndef new_multilateral(\n    cls,\n    verifiable_id: str,\n    relationship_type_uri: str,\n    members: MultilateralMembers,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; \"RelationshipRecord\":\n    \"\"\"Create a new multilateral RelationshipRecord.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_type_uri=relationship_type_uri,\n        parties=members,\n        effective_timestamp=effective_timestamp,\n        status=status,\n        jurisdiction_iso=jurisdiction_iso,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_expiration","title":"with_expiration","text":"<pre><code>with_expiration(\n    timestamp: CanonicalTimestamp,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with expiration timestamp set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_expiration(self, timestamp: CanonicalTimestamp) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with expiration timestamp set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_financial_terms","title":"with_financial_terms","text":"<pre><code>with_financial_terms(\n    terms: FinancialTerms,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with financial terms set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_financial_terms(self, terms: FinancialTerms) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with financial terms set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_parent","title":"with_parent","text":"<pre><code>with_parent(parent_id: str) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with parent relationship set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_parent(self, parent_id: str) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with parent relationship set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=parent_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(\n    hash_val: CanonicalHash,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with previous hash set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with revision number set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_source_reference","title":"with_source_reference","text":"<pre><code>with_source_reference(\n    reference: SourceReference,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with a source reference added.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_source_reference(self, reference: SourceReference) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with a source reference added.\"\"\"\n    refs = list(self.source_references) if self.source_references else []\n    refs.append(reference)\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=refs,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatus","title":"RelationshipStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Relationship status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass RelationshipStatus(Canonicalize):\n    \"\"\"Relationship status information.\"\"\"\n\n    status_code: RelationshipStatusCode\n    status_effective_timestamp: CanonicalTimestamp\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of relationship status fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(\n            fields,\n            \"statusEffectiveTimestamp\",\n            self.status_effective_timestamp.to_canonical_string(),\n        )\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of relationship status fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatus.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of relationship status fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(\n        fields,\n        \"statusEffectiveTimestamp\",\n        self.status_effective_timestamp.to_canonical_string(),\n    )\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatusCode","title":"RelationshipStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Relationship operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>class RelationshipStatusCode(Enum):\n    \"\"\"Relationship operational status.\"\"\"\n\n    PENDING = \"PENDING\"\n    ACTIVE = \"ACTIVE\"\n    SUSPENDED = \"SUSPENDED\"\n    COMPLETED = \"COMPLETED\"\n    TERMINATED = \"TERMINATED\"\n    AMENDED = \"AMENDED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string value of the relationship status code.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string value of the relationship status code.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string value of the relationship status code.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.SourceReference","title":"SourceReference  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Reference to an authoritative source record.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass SourceReference(Canonicalize):\n    \"\"\"Reference to an authoritative source record.\"\"\"\n\n    source_system_uri: str\n    source_record_id: str\n    source_url: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of source reference fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"sourceRecordId\", self.source_record_id)\n        insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n        insert_if_present(fields, \"sourceUrl\", self.source_url)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.SourceReference.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of source reference fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.SourceReference.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of source reference fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"sourceRecordId\", self.source_record_id)\n    insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n    insert_if_present(fields, \"sourceUrl\", self.source_url)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral","title":"bilateral","text":"<p>Bilateral party definitions for two-party relationships.</p> <p>Bilateral relationships have clear directionality: - Party A: The initiating, granting, or contracting party - Party B: The receiving, performing, or beneficiary party</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.BilateralParties","title":"BilateralParties  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Bilateral parties in a two-party relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>@dataclass\nclass BilateralParties(Canonicalize):\n    \"\"\"Bilateral parties in a two-party relationship.\"\"\"\n\n    party_a: Party  # Initiating, granting, or contracting party\n    party_b: Party  # Receiving, performing, or beneficiary party\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of bilateral parties.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields with partyA and partyB.\n        \"\"\"\n        fields: dict[str, str] = {}\n        # Nested objects serialized as their canonical strings\n        insert_required(fields, \"partyA\", self.party_a.to_canonical_string())\n        insert_required(fields, \"partyB\", self.party_b.to_canonical_string())\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.BilateralParties.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of bilateral parties.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.BilateralParties.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields with partyA and partyB.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of bilateral parties.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields with partyA and partyB.\n    \"\"\"\n    fields: dict[str, str] = {}\n    # Nested objects serialized as their canonical strings\n    insert_required(fields, \"partyA\", self.party_a.to_canonical_string())\n    insert_required(fields, \"partyB\", self.party_b.to_canonical_string())\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.Party","title":"Party  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A party in a bilateral relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>@dataclass\nclass Party(Canonicalize):\n    \"\"\"A party in a bilateral relationship.\"\"\"\n\n    entity_id: str\n    role_uri: str\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the party.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields with entityId and roleUri.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_required(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.Party.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the party.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.Party.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields with entityId and roleUri.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the party.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields with entityId and roleUri.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_required(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.builder","title":"builder","text":"<p>Builder module for creating and managing civic exchange relationships.</p> <p>This module provides utilities for constructing relationship objects in the civic exchange protocol.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral","title":"multilateral","text":"<p>Multilateral member definitions for n-ary relationships.</p> <p>Multilateral relationships involve more than two parties, such as: - Consortia - Joint ventures - Board memberships</p> <p>Members are sorted by entity_id to guarantee deterministic ordering for hash stability across all implementations.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.Member","title":"Member  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A member in a multilateral relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>@dataclass\nclass Member(Canonicalize):\n    \"\"\"A member in a multilateral relationship.\"\"\"\n\n    entity_id: str\n    role_uri: str\n    participation_share: float | None = None\n\n    def with_share(self, share: float) -&gt; \"Member\":\n        \"\"\"Return a new Member with the participation share set.\"\"\"\n        return Member(\n            entity_id=self.entity_id,\n            role_uri=self.role_uri,\n            participation_share=share,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the member.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing entityId, roleUri, and optionally participationShare.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        if self.participation_share is not None:\n            insert_required(fields, \"participationShare\", f\"{self.participation_share:.4f}\")\n        insert_required(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.Member.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the member.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.Member.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing entityId, roleUri, and optionally participationShare.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the member.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing entityId, roleUri, and optionally participationShare.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    if self.participation_share is not None:\n        insert_required(fields, \"participationShare\", f\"{self.participation_share:.4f}\")\n    insert_required(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.Member.with_share","title":"with_share","text":"<pre><code>with_share(share: float) -&gt; Member\n</code></pre> <p>Return a new Member with the participation share set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def with_share(self, share: float) -&gt; \"Member\":\n    \"\"\"Return a new Member with the participation share set.\"\"\"\n    return Member(\n        entity_id=self.entity_id,\n        role_uri=self.role_uri,\n        participation_share=share,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers","title":"MultilateralMembers","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A collection of members in a multilateral relationship.</p> <p>Members are automatically sorted by entity_id to ensure hash stability regardless of insertion order.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>class MultilateralMembers(Canonicalize):\n    \"\"\"A collection of members in a multilateral relationship.\n\n    Members are automatically sorted by entity_id to ensure\n    hash stability regardless of insertion order.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty collection of multilateral relationship members.\"\"\"\n        self._members: list[Member] = []\n\n    def add(self, member: Member) -&gt; None:\n        \"\"\"Add a member to the set.\"\"\"\n        # Check for duplicate entity_id\n        for existing in self._members:\n            if existing.entity_id == member.entity_id:\n                return  # Already exists\n        self._members.append(member)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of members in the collection.\"\"\"\n        return len(self._members)\n\n    def __iter__(self) -&gt; Iterator[Member]:\n        \"\"\"Iterate over members in sorted order by entity_id.\"\"\"\n        return iter(sorted(self._members, key=lambda m: m.entity_id))\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the collection has no members.\n\n        Returns:\n        -------\n        bool\n            True if the collection is empty, False otherwise.\n        \"\"\"\n        return len(self._members) == 0\n\n    def validate_shares(self) -&gt; None:\n        \"\"\"Validate that all participation shares sum to 1.0 (if present).\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        shares = [m.participation_share for m in self._members if m.participation_share is not None]\n\n        if not shares:\n            return\n\n        if len(shares) != len(self._members):\n            raise ValueError(\"All members must have participation shares if any do\")\n\n        total = sum(shares)\n        if abs(total - 1.0) &gt; 0.0001:\n            raise ValueError(f\"Participation shares must sum to 1.0, got {total:.4f}\")\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Serialize as array, members sorted by entity_id\n        if self._members:\n            sorted_members = sorted(self._members, key=lambda m: m.entity_id)\n            members_json = \",\".join(m.to_canonical_string() for m in sorted_members)\n            fields[\"members\"] = f\"[{members_json}]\"\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize an empty collection of multilateral relationship members.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty collection of multilateral relationship members.\"\"\"\n    self._members: list[Member] = []\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Member]\n</code></pre> <p>Iterate over members in sorted order by entity_id.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Member]:\n    \"\"\"Iterate over members in sorted order by entity_id.\"\"\"\n    return iter(sorted(self._members, key=lambda m: m.entity_id))\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of members in the collection.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of members in the collection.\"\"\"\n    return len(self._members)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.add","title":"add","text":"<pre><code>add(member: Member) -&gt; None\n</code></pre> <p>Add a member to the set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def add(self, member: Member) -&gt; None:\n    \"\"\"Add a member to the set.\"\"\"\n    # Check for duplicate entity_id\n    for existing in self._members:\n        if existing.entity_id == member.entity_id:\n            return  # Already exists\n    self._members.append(member)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Serialize as array, members sorted by entity_id\n    if self._members:\n        sorted_members = sorted(self._members, key=lambda m: m.entity_id)\n        members_json = \",\".join(m.to_canonical_string() for m in sorted_members)\n        fields[\"members\"] = f\"[{members_json}]\"\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the collection has no members.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.is_empty--returns","title":"Returns:","text":"<p>bool     True if the collection is empty, False otherwise.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the collection has no members.\n\n    Returns:\n    -------\n    bool\n        True if the collection is empty, False otherwise.\n    \"\"\"\n    return len(self._members) == 0\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.validate_shares","title":"validate_shares","text":"<pre><code>validate_shares() -&gt; None\n</code></pre> <p>Validate that all participation shares sum to 1.0 (if present).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def validate_shares(self) -&gt; None:\n    \"\"\"Validate that all participation shares sum to 1.0 (if present).\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    shares = [m.participation_share for m in self._members if m.participation_share is not None]\n\n    if not shares:\n        return\n\n    if len(shares) != len(self._members):\n        raise ValueError(\"All members must have participation shares if any do\")\n\n    total = sum(shares)\n    if abs(total - 1.0) &gt; 0.0001:\n        raise ValueError(f\"Participation shares must sum to 1.0, got {total:.4f}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship","title":"relationship","text":"<p>CEP Relationship Record definition.</p> <p>A Relationship Record represents a verifiable legal or functional relationship between two or more attested entities.</p> <p>Relationships can be: - Bilateral: Two-party relationships with clear directionality (contracts, grants) - Multilateral: N-ary relationships (consortia, boards, joint ventures)</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.FinancialTerms","title":"FinancialTerms  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Financial terms of a relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass FinancialTerms(Canonicalize):\n    \"\"\"Financial terms of a relationship.\"\"\"\n\n    total_value: float | None = None\n    obligated_value: float | None = None\n    currency_code: str = \"USD\"\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of financial terms fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"currencyCode\", self.currency_code)\n        if self.obligated_value is not None:\n            insert_required(fields, \"obligatedValue\", format_amount(self.obligated_value))\n        if self.total_value is not None:\n            insert_required(fields, \"totalValue\", format_amount(self.total_value))\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.FinancialTerms.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of financial terms fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.FinancialTerms.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of financial terms fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"currencyCode\", self.currency_code)\n    if self.obligated_value is not None:\n        insert_required(fields, \"obligatedValue\", format_amount(self.obligated_value))\n    if self.total_value is not None:\n        insert_required(fields, \"totalValue\", format_amount(self.total_value))\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord","title":"RelationshipRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Relationship Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass RelationshipRecord(Canonicalize):\n    \"\"\"A complete CEP Relationship Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    relationship_type_uri: str\n    parties: Parties\n    effective_timestamp: CanonicalTimestamp\n    status: RelationshipStatus\n    jurisdiction_iso: str\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    parent_relationship_id: str | None = None\n    expiration_timestamp: CanonicalTimestamp | None = None\n    financial_terms: FinancialTerms | None = None\n    terms_attributes: dict[str, str] | None = None\n    source_references: list[SourceReference] | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new_bilateral(\n        cls,\n        verifiable_id: str,\n        relationship_type_uri: str,\n        parties: BilateralParties,\n        effective_timestamp: CanonicalTimestamp,\n        status: RelationshipStatus,\n        jurisdiction_iso: str,\n        attestation: Attestation,\n    ) -&gt; \"RelationshipRecord\":\n        \"\"\"Create a new bilateral RelationshipRecord.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_type_uri=relationship_type_uri,\n            parties=parties,\n            effective_timestamp=effective_timestamp,\n            status=status,\n            jurisdiction_iso=jurisdiction_iso,\n            attestation=attestation,\n        )\n\n    @classmethod\n    def new_multilateral(\n        cls,\n        verifiable_id: str,\n        relationship_type_uri: str,\n        members: MultilateralMembers,\n        effective_timestamp: CanonicalTimestamp,\n        status: RelationshipStatus,\n        jurisdiction_iso: str,\n        attestation: Attestation,\n    ) -&gt; \"RelationshipRecord\":\n        \"\"\"Create a new multilateral RelationshipRecord.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_type_uri=relationship_type_uri,\n            parties=members,\n            effective_timestamp=effective_timestamp,\n            status=status,\n            jurisdiction_iso=jurisdiction_iso,\n            attestation=attestation,\n        )\n\n    def with_parent(self, parent_id: str) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with parent relationship set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=parent_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_expiration(self, timestamp: CanonicalTimestamp) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with expiration timestamp set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_financial_terms(self, terms: FinancialTerms) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with financial terms set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_source_reference(self, reference: SourceReference) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with a source reference added.\"\"\"\n        refs = list(self.source_references) if self.source_references else []\n        refs.append(reference)\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=refs,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with previous hash set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with revision number set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n        insert_required(\n            fields, \"effectiveTimestamp\", self.effective_timestamp.to_canonical_string()\n        )\n        if self.expiration_timestamp is not None:\n            insert_required(\n                fields, \"expirationTimestamp\", self.expiration_timestamp.to_canonical_string()\n            )\n        if self.financial_terms is not None:\n            insert_required(fields, \"financialTerms\", self.financial_terms.to_canonical_string())\n        insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n        insert_if_present(fields, \"parentRelationshipId\", self.parent_relationship_id)\n\n        # Parties (bilateral or multilateral)\n        if isinstance(self.parties, BilateralParties):\n            insert_required(fields, \"bilateralParties\", self.parties.to_canonical_string())\n        else:\n            insert_required(fields, \"multilateralMembers\", self.parties.to_canonical_string())\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n        insert_required(fields, \"relationshipTypeUri\", self.relationship_type_uri)\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Source references sorted by sourceSystemUri then sourceRecordId\n        if self.source_references:\n            sorted_refs = sorted(\n                self.source_references,\n                key=lambda r: (r.source_system_uri, r.source_record_id),\n            )\n            refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n            fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n\n        # Terms attributes (already sorted as dict)\n        if self.terms_attributes:\n            import json\n\n            fields[\"termsAttributes\"] = json.dumps(\n                dict(sorted(self.terms_attributes.items())), separators=(\",\", \":\")\n            )\n\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n    insert_required(\n        fields, \"effectiveTimestamp\", self.effective_timestamp.to_canonical_string()\n    )\n    if self.expiration_timestamp is not None:\n        insert_required(\n            fields, \"expirationTimestamp\", self.expiration_timestamp.to_canonical_string()\n        )\n    if self.financial_terms is not None:\n        insert_required(fields, \"financialTerms\", self.financial_terms.to_canonical_string())\n    insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n    insert_if_present(fields, \"parentRelationshipId\", self.parent_relationship_id)\n\n    # Parties (bilateral or multilateral)\n    if isinstance(self.parties, BilateralParties):\n        insert_required(fields, \"bilateralParties\", self.parties.to_canonical_string())\n    else:\n        insert_required(fields, \"multilateralMembers\", self.parties.to_canonical_string())\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n    insert_required(fields, \"relationshipTypeUri\", self.relationship_type_uri)\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Source references sorted by sourceSystemUri then sourceRecordId\n    if self.source_references:\n        sorted_refs = sorted(\n            self.source_references,\n            key=lambda r: (r.source_system_uri, r.source_record_id),\n        )\n        refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n        fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n\n    # Terms attributes (already sorted as dict)\n    if self.terms_attributes:\n        import json\n\n        fields[\"termsAttributes\"] = json.dumps(\n            dict(sorted(self.terms_attributes.items())), separators=(\",\", \":\")\n        )\n\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.new_bilateral","title":"new_bilateral  <code>classmethod</code>","text":"<pre><code>new_bilateral(\n    verifiable_id: str,\n    relationship_type_uri: str,\n    parties: BilateralParties,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; RelationshipRecord\n</code></pre> <p>Create a new bilateral RelationshipRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@classmethod\ndef new_bilateral(\n    cls,\n    verifiable_id: str,\n    relationship_type_uri: str,\n    parties: BilateralParties,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; \"RelationshipRecord\":\n    \"\"\"Create a new bilateral RelationshipRecord.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_type_uri=relationship_type_uri,\n        parties=parties,\n        effective_timestamp=effective_timestamp,\n        status=status,\n        jurisdiction_iso=jurisdiction_iso,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.new_multilateral","title":"new_multilateral  <code>classmethod</code>","text":"<pre><code>new_multilateral(\n    verifiable_id: str,\n    relationship_type_uri: str,\n    members: MultilateralMembers,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; RelationshipRecord\n</code></pre> <p>Create a new multilateral RelationshipRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@classmethod\ndef new_multilateral(\n    cls,\n    verifiable_id: str,\n    relationship_type_uri: str,\n    members: MultilateralMembers,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; \"RelationshipRecord\":\n    \"\"\"Create a new multilateral RelationshipRecord.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_type_uri=relationship_type_uri,\n        parties=members,\n        effective_timestamp=effective_timestamp,\n        status=status,\n        jurisdiction_iso=jurisdiction_iso,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_expiration","title":"with_expiration","text":"<pre><code>with_expiration(\n    timestamp: CanonicalTimestamp,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with expiration timestamp set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_expiration(self, timestamp: CanonicalTimestamp) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with expiration timestamp set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_financial_terms","title":"with_financial_terms","text":"<pre><code>with_financial_terms(\n    terms: FinancialTerms,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with financial terms set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_financial_terms(self, terms: FinancialTerms) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with financial terms set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_parent","title":"with_parent","text":"<pre><code>with_parent(parent_id: str) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with parent relationship set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_parent(self, parent_id: str) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with parent relationship set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=parent_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(\n    hash_val: CanonicalHash,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with previous hash set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with revision number set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_source_reference","title":"with_source_reference","text":"<pre><code>with_source_reference(\n    reference: SourceReference,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with a source reference added.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_source_reference(self, reference: SourceReference) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with a source reference added.\"\"\"\n    refs = list(self.source_references) if self.source_references else []\n    refs.append(reference)\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=refs,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatus","title":"RelationshipStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Relationship status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass RelationshipStatus(Canonicalize):\n    \"\"\"Relationship status information.\"\"\"\n\n    status_code: RelationshipStatusCode\n    status_effective_timestamp: CanonicalTimestamp\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of relationship status fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(\n            fields,\n            \"statusEffectiveTimestamp\",\n            self.status_effective_timestamp.to_canonical_string(),\n        )\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of relationship status fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatus.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of relationship status fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(\n        fields,\n        \"statusEffectiveTimestamp\",\n        self.status_effective_timestamp.to_canonical_string(),\n    )\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatusCode","title":"RelationshipStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Relationship operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>class RelationshipStatusCode(Enum):\n    \"\"\"Relationship operational status.\"\"\"\n\n    PENDING = \"PENDING\"\n    ACTIVE = \"ACTIVE\"\n    SUSPENDED = \"SUSPENDED\"\n    COMPLETED = \"COMPLETED\"\n    TERMINATED = \"TERMINATED\"\n    AMENDED = \"AMENDED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string value of the relationship status code.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string value of the relationship status code.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string value of the relationship status code.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.SourceReference","title":"SourceReference  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Reference to an authoritative source record.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass SourceReference(Canonicalize):\n    \"\"\"Reference to an authoritative source record.\"\"\"\n\n    source_system_uri: str\n    source_record_id: str\n    source_url: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of source reference fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"sourceRecordId\", self.source_record_id)\n        insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n        insert_if_present(fields, \"sourceUrl\", self.source_url)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.SourceReference.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of source reference fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.SourceReference.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of source reference fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"sourceRecordId\", self.source_record_id)\n    insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n    insert_if_present(fields, \"sourceUrl\", self.source_url)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei","title":"snfei","text":"<p>CEP Core Linker: Entity Resolution and SNFEI Generation.</p> <p>This package implements the Normalizing Functor architecture for generating deterministic entity identifiers (SNFEIs) from heterogeneous source data.</p> Architecture <p>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  Raw Entity  \u2502     \u2502  Intermediate  \u2502     \u2502  Canonical  \u2502 \u2502    Data      \u2502\u2500\u2500\u2500&gt; \u2502    Canonical   \u2502\u2500\u2500\u2500&gt; \u2502   Entity    \u2502 \u2502              \u2502  L  \u2502                \u2502  N  \u2502             \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                     \u2502                                                     \u2502 SHA-256                                                     V                                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                             \u2502    SNFEI     \u2502                                             \u2502  (64-char)   \u2502                                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518</p> <p>L = Localization Functor (jurisdiction-specific transforms) N = Normalizing Functor (universal normalization)</p> Usage <p>from civic_exchange_protocol.core_linker import (     generate_snfei,     normalize_legal_name,     apply_localization, )</p>"},{"location":"en/api/#civic_exchange_protocol.snfei--simple-snfei-generation","title":"Simple SNFEI generation","text":"<p>snfei, inputs = generate_snfei(     legal_name=\"Springfield USD #12\",     country_code=\"US\",     address=\"123 Main St\", )</p>"},{"location":"en/api/#civic_exchange_protocol.snfei--with-jurisdiction-specific-localization","title":"With jurisdiction-specific localization","text":"<p>from civic_exchange_protocol.core_linker import apply_localization localized = apply_localization(\"MTA\", \"us/ny\")</p>"},{"location":"en/api/#civic_exchange_protocol.snfei---metropolitan-transportation-authority","title":"-&gt; \"metropolitan transportation authority\"","text":""},{"location":"en/api/#civic_exchange_protocol.snfei.CanonicalInput","title":"CanonicalInput  <code>dataclass</code>","text":"<p>Normalized input for SNFEI hashing.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>@dataclass\nclass CanonicalInput:\n    \"\"\"Normalized input for SNFEI hashing.\"\"\"\n\n    legal_name_normalized: str\n    address_normalized: str | None\n    country_code: str\n    registration_date: str | None\n\n    def to_hash_string(self) -&gt; str:\n        \"\"\"Generate the concatenated string for hashing.\n\n        Format:\n            legal_name_normalized|address_normalized|country_code|registration_date\n\n        Empty/None fields are included as empty strings to maintain\n        consistent field positions.\n        \"\"\"\n        parts = [\n            self.legal_name_normalized,\n            self.address_normalized or \"\",\n            self.country_code,\n            self.registration_date or \"\",\n        ]\n        return \"|\".join(parts)\n\n    def to_hash_string_v2(self) -&gt; str:\n        \"\"\"Alternative format that omits empty fields.\n\n        This produces shorter strings but requires all implementations\n        to handle optional fields identically.\n        \"\"\"\n        parts = [self.legal_name_normalized]\n        if self.address_normalized:\n            parts.append(self.address_normalized)\n        parts.append(self.country_code)\n        if self.registration_date:\n            parts.append(self.registration_date)\n        return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.CanonicalInput.to_hash_string","title":"to_hash_string","text":"<pre><code>to_hash_string() -&gt; str\n</code></pre> <p>Generate the concatenated string for hashing.</p> Format <p>legal_name_normalized|address_normalized|country_code|registration_date</p> <p>Empty/None fields are included as empty strings to maintain consistent field positions.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def to_hash_string(self) -&gt; str:\n    \"\"\"Generate the concatenated string for hashing.\n\n    Format:\n        legal_name_normalized|address_normalized|country_code|registration_date\n\n    Empty/None fields are included as empty strings to maintain\n    consistent field positions.\n    \"\"\"\n    parts = [\n        self.legal_name_normalized,\n        self.address_normalized or \"\",\n        self.country_code,\n        self.registration_date or \"\",\n    ]\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.CanonicalInput.to_hash_string_v2","title":"to_hash_string_v2","text":"<pre><code>to_hash_string_v2() -&gt; str\n</code></pre> <p>Alternative format that omits empty fields.</p> <p>This produces shorter strings but requires all implementations to handle optional fields identically.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def to_hash_string_v2(self) -&gt; str:\n    \"\"\"Alternative format that omits empty fields.\n\n    This produces shorter strings but requires all implementations\n    to handle optional fields identically.\n    \"\"\"\n    parts = [self.legal_name_normalized]\n    if self.address_normalized:\n        parts.append(self.address_normalized)\n    parts.append(self.country_code)\n    if self.registration_date:\n        parts.append(self.registration_date)\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.LocalizationConfig","title":"LocalizationConfig  <code>dataclass</code>","text":"<p>Configuration for a specific jurisdiction.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationConfig:\n    \"\"\"Configuration for a specific jurisdiction.\"\"\"\n\n    jurisdiction: str  # e.g., \"us/ca\", \"ca/on\"\n    parent: str | None  # Parent jurisdiction for inheritance\n\n    # Transformation maps\n    abbreviations: dict[str, str] = field(default_factory=dict)\n    agency_names: dict[str, str] = field(default_factory=dict)\n    entity_types: dict[str, str] = field(default_factory=dict)\n\n    # Additional rules\n    rules: list[LocalizationRule] = field(default_factory=list)\n\n    # Stop words specific to this jurisdiction\n    stop_words: set[str] = field(default_factory=set)\n\n    def apply_to_name(self, name: str) -&gt; str:\n        \"\"\"Apply jurisdiction-specific transformations to a name.\n\n        Order of application:\n        1. Agency name expansions\n        2. Abbreviation expansions\n        3. Entity type standardization\n        4. Custom rules\n        \"\"\"\n        result = name.lower()\n\n        # 1. Agency names (exact match, case-insensitive)\n        for abbrev, full in self.agency_names.items():\n            # Word boundary matching\n            import re\n\n            pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n            result = re.sub(pattern, full.lower(), result)\n\n        # 2. Abbreviations\n        tokens = result.split()\n        expanded = []\n        for token in tokens:\n            if token in self.abbreviations:\n                expanded.append(self.abbreviations[token].lower())\n            else:\n                expanded.append(token)\n        result = \" \".join(expanded)\n\n        # 3. Entity types\n        for local_type, canonical_type in self.entity_types.items():\n            import re\n\n            pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n            result = re.sub(pattern, canonical_type.lower(), result)\n\n        # 4. Custom rules\n        for rule in self.rules:\n            if rule.is_regex:\n                import re\n\n                result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n            else:\n                result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n        return result\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.LocalizationConfig.apply_to_name","title":"apply_to_name","text":"<pre><code>apply_to_name(name: str) -&gt; str\n</code></pre> <p>Apply jurisdiction-specific transformations to a name.</p> <p>Order of application: 1. Agency name expansions 2. Abbreviation expansions 3. Entity type standardization 4. Custom rules</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def apply_to_name(self, name: str) -&gt; str:\n    \"\"\"Apply jurisdiction-specific transformations to a name.\n\n    Order of application:\n    1. Agency name expansions\n    2. Abbreviation expansions\n    3. Entity type standardization\n    4. Custom rules\n    \"\"\"\n    result = name.lower()\n\n    # 1. Agency names (exact match, case-insensitive)\n    for abbrev, full in self.agency_names.items():\n        # Word boundary matching\n        import re\n\n        pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n        result = re.sub(pattern, full.lower(), result)\n\n    # 2. Abbreviations\n    tokens = result.split()\n    expanded = []\n    for token in tokens:\n        if token in self.abbreviations:\n            expanded.append(self.abbreviations[token].lower())\n        else:\n            expanded.append(token)\n    result = \" \".join(expanded)\n\n    # 3. Entity types\n    for local_type, canonical_type in self.entity_types.items():\n        import re\n\n        pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n        result = re.sub(pattern, canonical_type.lower(), result)\n\n    # 4. Custom rules\n    for rule in self.rules:\n        if rule.is_regex:\n            import re\n\n            result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n        else:\n            result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n    return result\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.LocalizationRegistry","title":"LocalizationRegistry","text":"<p>Registry for loading and caching localization configurations.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>class LocalizationRegistry:\n    \"\"\"Registry for loading and caching localization configurations.\"\"\"\n\n    def __init__(self, config_dir: Path | None = None):\n        \"\"\"Initialize the registry.\n\n        Args:\n            config_dir: Optional path to localization YAML files.\n                       If None, only built-in configs are available.\n        \"\"\"\n        self.config_dir = config_dir\n        self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n\n    def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n        \"\"\"Get localization config for a jurisdiction.\n\n        Falls back through parent jurisdictions if specific config not found.\n        Merges child config with parent config for inheritance.\n\n        Args:\n            jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                         Case-insensitive - will be normalized to lowercase.\n\n        Returns:\n            LocalizationConfig for the jurisdiction (merged with parent).\n        \"\"\"\n        # Normalize to lowercase\n        jurisdiction = jurisdiction.lower()\n\n        # Check if we have a merged config cached\n        cache_key = f\"_merged_{jurisdiction}\"\n        if cache_key in self._cache:\n            return self._cache[cache_key]\n\n        # Get the base config for this jurisdiction\n        if jurisdiction in self._cache:\n            config = self._cache[jurisdiction]\n        elif self.config_dir:\n            config = self._load_yaml(jurisdiction)\n            if config:\n                self._cache[jurisdiction] = config\n            else:\n                config = None\n        else:\n            config = None\n\n        # If no config found, fall back to parent\n        if config is None:\n            if \"/\" in jurisdiction:\n                parent = jurisdiction.rsplit(\"/\", 1)[0]\n                return self.get_config(parent)\n            # Return empty config as last resort\n            return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n        # If config has a parent, merge with parent config\n        if config.parent:\n            parent_config = self.get_config(config.parent)\n            merged = self.merge_configs(config, parent_config)\n            self._cache[cache_key] = merged\n            return merged\n\n        return config\n\n    def _load_yaml(self, jurisdiction: str) -&gt; LocalizationConfig | None:\n        \"\"\"Load config from YAML file.\n\n        Expected paths:\n            - {config_dir}/{country}/base.yaml for country-level (e.g., US, CA)\n            - {config_dir}/{country}/{region}.yaml for region-level (e.g., us/ca, ca/on)\n        \"\"\"\n        if not self.config_dir:\n            return None\n\n        # Determine the YAML file path\n        if \"/\" in jurisdiction:\n            # Region-level: us/ca -&gt; us/ca.yaml\n            parts = jurisdiction.split(\"/\")\n            yaml_path = self.config_dir / parts[0] / f\"{parts[1]}.yaml\"\n        else:\n            # Country-level: US -&gt; us/base.yaml\n            yaml_path = self.config_dir / jurisdiction / \"base.yaml\"\n\n        if not yaml_path.exists():\n            return None\n\n        try:\n            with yaml_path.open(\"r\", encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n\n            if not data:\n                return None\n\n            # Parse rules if present\n            rules = []\n            for rule_data in data.get(\"rules\", []):\n                rules.append(\n                    LocalizationRule(\n                        pattern=rule_data.get(\"pattern\", \"\"),\n                        replacement=rule_data.get(\"replacement\", \"\"),\n                        is_regex=rule_data.get(\"is_regex\", False),\n                        context=rule_data.get(\"context\"),\n                    )\n                )\n\n            return LocalizationConfig(\n                jurisdiction=data.get(\"jurisdiction\", jurisdiction),\n                parent=data.get(\"parent\"),\n                abbreviations=data.get(\"abbreviations\", {}),\n                agency_names=data.get(\"agency_names\", {}),\n                entity_types=data.get(\"entity_types\", {}),\n                rules=rules,\n                stop_words=set(data.get(\"stop_words\", [])),\n            )\n        except Exception as e:\n            # Log error but don't crash\n            print(f\"Warning: Failed to load localization YAML {yaml_path}: {e}\")\n            return None\n\n    def merge_configs(\n        self, child: LocalizationConfig, parent: LocalizationConfig\n    ) -&gt; LocalizationConfig:\n        \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n        merged_abbrevs = dict(parent.abbreviations)\n        merged_abbrevs.update(child.abbreviations)\n\n        merged_agencies = dict(parent.agency_names)\n        merged_agencies.update(child.agency_names)\n\n        merged_types = dict(parent.entity_types)\n        merged_types.update(child.entity_types)\n\n        return LocalizationConfig(\n            jurisdiction=child.jurisdiction,\n            parent=parent.jurisdiction,\n            abbreviations=merged_abbrevs,\n            agency_names=merged_agencies,\n            entity_types=merged_types,\n            rules=parent.rules + child.rules,\n            stop_words=parent.stop_words | child.stop_words,\n        )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.LocalizationRegistry.__init__","title":"__init__","text":"<pre><code>__init__(config_dir: Path | None = None)\n</code></pre> <p>Initialize the registry.</p> <p>Parameters:</p> Name Type Description Default <code>config_dir</code> <code>Path | None</code> <p>Optional path to localization YAML files.        If None, only built-in configs are available.</p> <code>None</code> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def __init__(self, config_dir: Path | None = None):\n    \"\"\"Initialize the registry.\n\n    Args:\n        config_dir: Optional path to localization YAML files.\n                   If None, only built-in configs are available.\n    \"\"\"\n    self.config_dir = config_dir\n    self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.LocalizationRegistry.get_config","title":"get_config","text":"<pre><code>get_config(jurisdiction: str) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction.</p> <p>Falls back through parent jurisdictions if specific config not found. Merges child config with parent config for inheritance.</p> <p>Parameters:</p> Name Type Description Default <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\", \"ca/on\").          Case-insensitive - will be normalized to lowercase.</p> required <p>Returns:</p> Type Description <code>LocalizationConfig</code> <p>LocalizationConfig for the jurisdiction (merged with parent).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction.\n\n    Falls back through parent jurisdictions if specific config not found.\n    Merges child config with parent config for inheritance.\n\n    Args:\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                     Case-insensitive - will be normalized to lowercase.\n\n    Returns:\n        LocalizationConfig for the jurisdiction (merged with parent).\n    \"\"\"\n    # Normalize to lowercase\n    jurisdiction = jurisdiction.lower()\n\n    # Check if we have a merged config cached\n    cache_key = f\"_merged_{jurisdiction}\"\n    if cache_key in self._cache:\n        return self._cache[cache_key]\n\n    # Get the base config for this jurisdiction\n    if jurisdiction in self._cache:\n        config = self._cache[jurisdiction]\n    elif self.config_dir:\n        config = self._load_yaml(jurisdiction)\n        if config:\n            self._cache[jurisdiction] = config\n        else:\n            config = None\n    else:\n        config = None\n\n    # If no config found, fall back to parent\n    if config is None:\n        if \"/\" in jurisdiction:\n            parent = jurisdiction.rsplit(\"/\", 1)[0]\n            return self.get_config(parent)\n        # Return empty config as last resort\n        return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n    # If config has a parent, merge with parent config\n    if config.parent:\n        parent_config = self.get_config(config.parent)\n        merged = self.merge_configs(config, parent_config)\n        self._cache[cache_key] = merged\n        return merged\n\n    return config\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.LocalizationRegistry.merge_configs","title":"merge_configs","text":"<pre><code>merge_configs(\n    child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig\n</code></pre> <p>Merge child config with parent (child overrides parent).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def merge_configs(\n    self, child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig:\n    \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n    merged_abbrevs = dict(parent.abbreviations)\n    merged_abbrevs.update(child.abbreviations)\n\n    merged_agencies = dict(parent.agency_names)\n    merged_agencies.update(child.agency_names)\n\n    merged_types = dict(parent.entity_types)\n    merged_types.update(child.entity_types)\n\n    return LocalizationConfig(\n        jurisdiction=child.jurisdiction,\n        parent=parent.jurisdiction,\n        abbreviations=merged_abbrevs,\n        agency_names=merged_agencies,\n        entity_types=merged_types,\n        rules=parent.rules + child.rules,\n        stop_words=parent.stop_words | child.stop_words,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.LocalizationRule","title":"LocalizationRule  <code>dataclass</code>","text":"<p>A single localization transformation rule.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationRule:\n    \"\"\"A single localization transformation rule.\"\"\"\n\n    pattern: str  # Text to match (case-insensitive)\n    replacement: str  # Replacement text\n    is_regex: bool = False  # Whether pattern is a regex\n    context: str | None = None  # Optional context (e.g., \"agency\", \"school\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.Snfei","title":"Snfei  <code>dataclass</code>","text":"<p>A validated SNFEI (64-character lowercase hex string).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>@dataclass(frozen=True)\nclass Snfei:\n    \"\"\"A validated SNFEI (64-character lowercase hex string).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate SNFEI format after initialization.\"\"\"\n        if len(self.value) != 64:\n            raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n        if not all(c in \"0123456789abcdef\" for c in self.value):\n            raise ValueError(\"SNFEI must be lowercase hex\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of SNFEI.\"\"\"\n        return self.value\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n        return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the hash value (for API compatibility).\"\"\"\n        return self.value\n\n    def short(self, length: int = 12) -&gt; str:\n        \"\"\"Return a shortened version for display.\"\"\"\n        return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.Snfei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate SNFEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate SNFEI format after initialization.\"\"\"\n    if len(self.value) != 64:\n        raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n    if not all(c in \"0123456789abcdef\" for c in self.value):\n        raise ValueError(\"SNFEI must be lowercase hex\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.Snfei.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return abbreviated representation of SNFEI.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n    return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.Snfei.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation of SNFEI.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of SNFEI.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.Snfei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the hash value (for API compatibility).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the hash value (for API compatibility).\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.Snfei.short","title":"short","text":"<pre><code>short(length: int = 12) -&gt; str\n</code></pre> <p>Return a shortened version for display.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def short(self, length: int = 12) -&gt; str:\n    \"\"\"Return a shortened version for display.\"\"\"\n    return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.SnfeiResult","title":"SnfeiResult  <code>dataclass</code>","text":"<p>Result of SNFEI generation with confidence metadata.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>@dataclass\nclass SnfeiResult:\n    \"\"\"Result of SNFEI generation with confidence metadata.\"\"\"\n\n    snfei: Snfei\n    canonical: CanonicalInput\n    confidence_score: float  # 0.0 to 1.0\n    tier: int  # 1, 2, or 3\n    fields_used: list  # Which fields contributed\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert result to dictionary for serialization.\"\"\"\n        return {\n            \"snfei\": self.snfei.value,\n            \"confidence_score\": self.confidence_score,\n            \"tier\": self.tier,\n            \"fields_used\": self.fields_used,\n            \"canonical\": {\n                \"legal_name_normalized\": self.canonical.legal_name_normalized,\n                \"address_normalized\": self.canonical.address_normalized,\n                \"country_code\": self.canonical.country_code,\n                \"registration_date\": self.canonical.registration_date,\n            },\n        }\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.SnfeiResult.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert result to dictionary for serialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert result to dictionary for serialization.\"\"\"\n    return {\n        \"snfei\": self.snfei.value,\n        \"confidence_score\": self.confidence_score,\n        \"tier\": self.tier,\n        \"fields_used\": self.fields_used,\n        \"canonical\": {\n            \"legal_name_normalized\": self.canonical.legal_name_normalized,\n            \"address_normalized\": self.canonical.address_normalized,\n            \"country_code\": self.canonical.country_code,\n            \"registration_date\": self.canonical.registration_date,\n        },\n    }\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.apply_localization","title":"apply_localization","text":"<pre><code>apply_localization(name: str, jurisdiction: str) -&gt; str\n</code></pre> <p>Apply localization transforms to a name.</p> <p>This is the Localization Functor L.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw entity name.</p> required <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name with jurisdiction-specific transforms applied.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def apply_localization(name: str, jurisdiction: str) -&gt; str:\n    \"\"\"Apply localization transforms to a name.\n\n    This is the Localization Functor L.\n\n    Args:\n        name: Raw entity name.\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\").\n\n    Returns:\n        Name with jurisdiction-specific transforms applied.\n    \"\"\"\n    config = get_localization_config(jurisdiction)\n    return config.apply_to_name(name)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.build_canonical_input","title":"build_canonical_input","text":"<pre><code>build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput\n</code></pre> <p>Build a canonical input structure from raw entity data.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration/formation date.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanonicalInput</code> <p>CanonicalInput with all fields normalized.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput:\n    \"\"\"Build a canonical input structure from raw entity data.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration/formation date.\n\n    Returns:\n        CanonicalInput with all fields normalized.\n    \"\"\"\n    return CanonicalInput(\n        legal_name_normalized=normalize_legal_name(legal_name),\n        address_normalized=normalize_address(address) if address else None,\n        country_code=country_code.upper(),\n        registration_date=normalize_registration_date(registration_date)\n        if registration_date\n        else None,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(canonical: CanonicalInput) -&gt; Snfei\n</code></pre> <p>Compute SNFEI from canonical input.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>CanonicalInput</code> <p>Normalized input structure.</p> required <p>Returns:</p> Type Description <code>Snfei</code> <p>Computed SNFEI.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def compute_snfei(canonical: CanonicalInput) -&gt; Snfei:\n    \"\"\"Compute SNFEI from canonical input.\n\n    Args:\n        canonical: Normalized input structure.\n\n    Returns:\n        Computed SNFEI.\n    \"\"\"\n    hash_input = canonical.to_hash_string()\n    hash_bytes = hashlib.sha256(hash_input.encode(\"utf-8\")).hexdigest().lower()\n    return Snfei(hash_bytes)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generate_snfei","title":"generate_snfei","text":"<pre><code>generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; SnfeiResult\n</code></pre> <p>Generate an SNFEI from raw entity attributes.</p> <p>This is the main entry point for SNFEI generation. It applies the Normalizing Functor to all inputs before hashing.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code (e.g., \"US\", \"CA\").</p> required <code>address</code> <code>str | None</code> <p>Optional primary street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional formation/registration date.</p> <code>None</code> <p>Returns:</p> Type Description <code>SnfeiResult</code> <p>SnfeiResult for verification.</p> Example <p>snfei, inputs = generate_snfei( ...     legal_name=\"Springfield Unified Sch. Dist., Inc.\", ...     country_code=\"US\", ...     address=\"123 Main St., Suite 100\", ...     registration_date=\"01/15/1985\", ... ) print(snfei) a1b2c3d4... print(inputs.legal_name_normalized) springfield unified school district incorporated</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; SnfeiResult:\n    \"\"\"Generate an SNFEI from raw entity attributes.\n\n    This is the main entry point for SNFEI generation. It applies the\n    Normalizing Functor to all inputs before hashing.\n\n    Args:\n        legal_name: Raw legal name from source system.\n        country_code: ISO 3166-1 alpha-2 country code (e.g., \"US\", \"CA\").\n        address: Optional primary street address.\n        registration_date: Optional formation/registration date.\n\n    Returns:\n        SnfeiResult for verification.\n\n    Example:\n        &gt;&gt;&gt; snfei, inputs = generate_snfei(\n        ...     legal_name=\"Springfield Unified Sch. Dist., Inc.\",\n        ...     country_code=\"US\",\n        ...     address=\"123 Main St., Suite 100\",\n        ...     registration_date=\"01/15/1985\",\n        ... )\n        &gt;&gt;&gt; print(snfei)\n        a1b2c3d4...\n        &gt;&gt;&gt; print(inputs.legal_name_normalized)\n        springfield unified school district incorporated\n    \"\"\"\n    canonical = build_canonical_input(\n        legal_name=legal_name,\n        country_code=country_code,\n        address=address,\n        registration_date=registration_date,\n    )\n    snfei = compute_snfei(canonical)\n\n    # Determine fields used from what's present in canonical\n    fields_used = [\"legal_name\", \"country_code\"]\n    if canonical.address_normalized:\n        fields_used.append(\"address\")\n    if canonical.registration_date:\n        fields_used.append(\"registration_date\")\n\n    # Basic confidence: Tier 3, score based on fields\n    confidence = 0.5\n    if canonical.address_normalized:\n        confidence += 0.2\n    if canonical.registration_date:\n        confidence += 0.2\n    word_count = len(canonical.legal_name_normalized.split())\n    if word_count &gt; 3:\n        confidence += 0.1\n    confidence = min(confidence, 0.9)\n\n    return SnfeiResult(\n        snfei=snfei,\n        canonical=canonical,\n        confidence_score=round(confidence, 2),\n        tier=3,\n        fields_used=fields_used,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generate_snfei_simple","title":"generate_snfei_simple","text":"<pre><code>generate_snfei_simple(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n) -&gt; str\n</code></pre> <p>Generate SNFEI as a simple hex string.</p> <p>Convenience function that returns just the hash value.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional primary street address.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>64-character lowercase hex SNFEI string.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def generate_snfei_simple(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n) -&gt; str:\n    \"\"\"Generate SNFEI as a simple hex string.\n\n    Convenience function that returns just the hash value.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional primary street address.\n\n    Returns:\n        64-character lowercase hex SNFEI string.\n    \"\"\"\n    result = generate_snfei(legal_name, country_code, address)\n    return result.snfei.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generate_snfei_with_confidence","title":"generate_snfei_with_confidence","text":"<pre><code>generate_snfei_with_confidence(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; SnfeiResult\n</code></pre> <p>Generate SNFEI with confidence scoring and tier classification.</p> <p>Tier Classification: - Tier 1: Entity has LEI (global identifier) - confidence 1.0 - Tier 2: Entity has SAM UEI (federal identifier) - confidence 0.95 - Tier 3: Entity uses SNFEI (computed hash) - confidence varies</p> <p>Tier 3 Confidence Scoring: - Base: 0.5 (name + country only) - +0.2 if address is provided - +0.2 if registration_date is provided - +0.1 if name is reasonably long (&gt;3 words)</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration date.</p> <code>None</code> <code>lei</code> <code>str | None</code> <p>Optional LEI (Legal Entity Identifier).</p> <code>None</code> <code>sam_uei</code> <code>str | None</code> <p>Optional SAM.gov Unique Entity Identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>SnfeiResult</code> <p>SnfeiResult with SNFEI, confidence score, and metadata.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def generate_snfei_with_confidence(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; SnfeiResult:\n    \"\"\"Generate SNFEI with confidence scoring and tier classification.\n\n    Tier Classification:\n    - Tier 1: Entity has LEI (global identifier) - confidence 1.0\n    - Tier 2: Entity has SAM UEI (federal identifier) - confidence 0.95\n    - Tier 3: Entity uses SNFEI (computed hash) - confidence varies\n\n    Tier 3 Confidence Scoring:\n    - Base: 0.5 (name + country only)\n    - +0.2 if address is provided\n    - +0.2 if registration_date is provided\n    - +0.1 if name is reasonably long (&gt;3 words)\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration date.\n        lei: Optional LEI (Legal Entity Identifier).\n        sam_uei: Optional SAM.gov Unique Entity Identifier.\n\n    Returns:\n        SnfeiResult with SNFEI, confidence score, and metadata.\n    \"\"\"\n    fields_used = [\"legal_name\", \"country_code\"]\n\n    # Tier 1: LEI available\n    if lei and len(lei) == 20:\n        canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n        # For Tier 1, we still compute SNFEI but confidence is 1.0\n        snfei = compute_snfei(canonical)\n        return SnfeiResult(\n            snfei=snfei,\n            canonical=canonical,\n            confidence_score=1.0,\n            tier=1,\n            fields_used=[\"lei\"] + fields_used,\n        )\n\n    # Tier 2: SAM UEI available\n    if sam_uei and len(sam_uei) == 12:\n        canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n        snfei = compute_snfei(canonical)\n        return SnfeiResult(\n            snfei=snfei,\n            canonical=canonical,\n            confidence_score=0.95,\n            tier=2,\n            fields_used=[\"sam_uei\"] + fields_used,\n        )\n\n    # Tier 3: Compute SNFEI from attributes\n    canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n    snfei = compute_snfei(canonical)\n\n    # Calculate confidence score\n    confidence = 0.5  # Base score\n\n    if address:\n        fields_used.append(\"address\")\n        confidence += 0.2\n\n    if registration_date:\n        fields_used.append(\"registration_date\")\n        confidence += 0.2\n\n    # Bonus for longer, more specific names\n    word_count = len(canonical.legal_name_normalized.split())\n    if word_count &gt; 3:\n        confidence += 0.1\n\n    # Cap at 0.9 for Tier 3\n    confidence = min(confidence, 0.9)\n\n    return SnfeiResult(\n        snfei=snfei,\n        canonical=canonical,\n        confidence_score=round(confidence, 2),\n        tier=3,\n        fields_used=fields_used,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.get_localization_config","title":"get_localization_config","text":"<pre><code>get_localization_config(\n    jurisdiction: str,\n) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction (convenience function).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def get_localization_config(jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction (convenience function).\"\"\"\n    return _registry.get_config(jurisdiction)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalize_address","title":"normalize_address","text":"<pre><code>normalize_address(\n    address: str, remove_secondary: bool = True\n) -&gt; str\n</code></pre> <p>Normalize a street address for SNFEI hashing.</p> <p>Pipeline: 1. Lowercase 2. ASCII transliteration 3. Remove secondary unit designators (apt, suite, etc.) 4. Remove punctuation 5. Expand postal abbreviations 6. Collapse whitespace</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Raw street address.</p> required <code>remove_secondary</code> <code>bool</code> <p>Whether to remove apartment/suite numbers.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized address string.</p> Example <p>normalize_address(\"123 N. Main St., Suite 400\") \"123 north main street\"</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def normalize_address(\n    address: str,\n    remove_secondary: bool = True,\n) -&gt; str:\n    \"\"\"Normalize a street address for SNFEI hashing.\n\n    Pipeline:\n    1. Lowercase\n    2. ASCII transliteration\n    3. Remove secondary unit designators (apt, suite, etc.)\n    4. Remove punctuation\n    5. Expand postal abbreviations\n    6. Collapse whitespace\n\n    Args:\n        address: Raw street address.\n        remove_secondary: Whether to remove apartment/suite numbers.\n\n    Returns:\n        Normalized address string.\n\n    Example:\n        &gt;&gt;&gt; normalize_address(\"123 N. Main St., Suite 400\")\n        \"123 north main street\"\n    \"\"\"\n    if not address:\n        return \"\"\n\n    # 1. Lowercase\n    text = address.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove secondary unit designators\n    if remove_secondary:\n        for pattern in SECONDARY_UNIT_PATTERNS:\n            text = re.sub(pattern, \"\", text, flags=re.IGNORECASE)\n\n    # 4. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 5. Collapse whitespace first\n    text = _collapse_whitespace(text)\n\n    # 6. Expand postal abbreviations\n    tokens = text.split()\n    expanded = []\n    for token in tokens:\n        if token in US_ADDRESS_EXPANSIONS:\n            expanded.append(US_ADDRESS_EXPANSIONS[token])\n        else:\n            expanded.append(token)\n    text = \" \".join(expanded)\n\n    # 7. Final trim\n    return text.strip()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalize_legal_name","title":"normalize_legal_name","text":"<pre><code>normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str\n</code></pre> <p>Apply the universal normalization pipeline to a legal name.</p> <p>Pipeline (in order): 1. Convert to lowercase 2. ASCII transliteration 3. Remove punctuation 4. Collapse whitespace 5. Expand abbreviations 6. Remove stop words (optional) 7. Final trim</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>remove_stop_words</code> <code>bool</code> <p>Whether to filter out stop words.</p> <code>True</code> <code>preserve_initial_stop</code> <code>bool</code> <p>If True, preserve stop word at start of name.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized name suitable for SNFEI hashing.</p> Example <p>normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\") \"springfield unified school district incorporated\"</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str:\n    \"\"\"Apply the universal normalization pipeline to a legal name.\n\n    Pipeline (in order):\n    1. Convert to lowercase\n    2. ASCII transliteration\n    3. Remove punctuation\n    4. Collapse whitespace\n    5. Expand abbreviations\n    6. Remove stop words (optional)\n    7. Final trim\n\n    Args:\n        name: Raw legal name from source system.\n        remove_stop_words: Whether to filter out stop words.\n        preserve_initial_stop: If True, preserve stop word at start of name.\n\n    Returns:\n        Normalized name suitable for SNFEI hashing.\n\n    Example:\n        &gt;&gt;&gt; normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\")\n        \"springfield unified school district incorporated\"\n    \"\"\"\n    if not name:\n        return \"\"\n\n    # 1. Lowercase\n    text = name.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 4. Collapse whitespace\n    text = _collapse_whitespace(text)\n\n    # 5. Expand abbreviations\n    text = _expand_abbreviations(text)\n\n    # 6. Remove stop words\n    if remove_stop_words:\n        text = _remove_stop_words(text, preserve_initial=preserve_initial_stop)\n\n    # 7. Final collapse and trim\n    return _collapse_whitespace(text)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalize_registration_date","title":"normalize_registration_date","text":"<pre><code>normalize_registration_date(date_str: str) -&gt; str | None\n</code></pre> <p>Normalize a registration date to ISO 8601 format.</p> <p>Returns None if date cannot be parsed.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string in various formats.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>ISO 8601 date string (YYYY-MM-DD) or None.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def normalize_registration_date(date_str: str) -&gt; str | None:\n    \"\"\"Normalize a registration date to ISO 8601 format.\n\n    Returns None if date cannot be parsed.\n\n    Args:\n        date_str: Date string in various formats.\n\n    Returns:\n        ISO 8601 date string (YYYY-MM-DD) or None.\n    \"\"\"\n    if not date_str:\n        return None\n\n    # Remove extra whitespace\n    date_str = date_str.strip()\n\n    # Try common date patterns\n\n    patterns = [\n        # ISO format\n        (r\"^(\\d{4})-(\\d{2})-(\\d{2})$\", \"%Y-%m-%d\"),\n        # US format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%m/%d/%Y\"),\n        (r\"^(\\d{1,2})-(\\d{1,2})-(\\d{4})$\", \"%m-%d-%Y\"),\n        # European format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%d/%m/%Y\"),\n        # Year only\n        (r\"^(\\d{4})$\", \"%Y\"),\n    ]\n\n    for pattern, fmt in patterns:\n        if re.match(pattern, date_str):\n            try:\n                if fmt == \"%Y\":\n                    # Year only - use January 1\n                    return f\"{date_str}-01-01\"\n                dt = datetime.strptime(date_str, fmt)\n                return dt.strftime(\"%Y-%m-%d\")\n            except ValueError:\n                continue\n\n    return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator","title":"generator","text":"<p>SNFEI Hash Generation.</p> <p>This module computes the final SNFEI (Sub-National Federated Entity Identifier) from normalized entity attributes.</p> The SNFEI formula <p>SNFEI = SHA256(Concatenate[     legal_name_normalized,     address_normalized,     country_code,     registration_date ])</p> <p>All inputs must pass through the Normalizing Functor before hashing.</p>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.Snfei","title":"Snfei  <code>dataclass</code>","text":"<p>A validated SNFEI (64-character lowercase hex string).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>@dataclass(frozen=True)\nclass Snfei:\n    \"\"\"A validated SNFEI (64-character lowercase hex string).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate SNFEI format after initialization.\"\"\"\n        if len(self.value) != 64:\n            raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n        if not all(c in \"0123456789abcdef\" for c in self.value):\n            raise ValueError(\"SNFEI must be lowercase hex\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation of SNFEI.\"\"\"\n        return self.value\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n        return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the hash value (for API compatibility).\"\"\"\n        return self.value\n\n    def short(self, length: int = 12) -&gt; str:\n        \"\"\"Return a shortened version for display.\"\"\"\n        return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.Snfei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate SNFEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate SNFEI format after initialization.\"\"\"\n    if len(self.value) != 64:\n        raise ValueError(f\"SNFEI must be 64 characters, got {len(self.value)}\")\n    if not all(c in \"0123456789abcdef\" for c in self.value):\n        raise ValueError(\"SNFEI must be lowercase hex\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.Snfei.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return abbreviated representation of SNFEI.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return abbreviated representation of SNFEI.\"\"\"\n    return f\"Snfei('{self.value[:8]}...{self.value[-8:]}')\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.Snfei.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return string representation of SNFEI.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation of SNFEI.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.Snfei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the hash value (for API compatibility).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the hash value (for API compatibility).\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.Snfei.short","title":"short","text":"<pre><code>short(length: int = 12) -&gt; str\n</code></pre> <p>Return a shortened version for display.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def short(self, length: int = 12) -&gt; str:\n    \"\"\"Return a shortened version for display.\"\"\"\n    return self.value[:length]\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.SnfeiResult","title":"SnfeiResult  <code>dataclass</code>","text":"<p>Result of SNFEI generation with confidence metadata.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>@dataclass\nclass SnfeiResult:\n    \"\"\"Result of SNFEI generation with confidence metadata.\"\"\"\n\n    snfei: Snfei\n    canonical: CanonicalInput\n    confidence_score: float  # 0.0 to 1.0\n    tier: int  # 1, 2, or 3\n    fields_used: list  # Which fields contributed\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert result to dictionary for serialization.\"\"\"\n        return {\n            \"snfei\": self.snfei.value,\n            \"confidence_score\": self.confidence_score,\n            \"tier\": self.tier,\n            \"fields_used\": self.fields_used,\n            \"canonical\": {\n                \"legal_name_normalized\": self.canonical.legal_name_normalized,\n                \"address_normalized\": self.canonical.address_normalized,\n                \"country_code\": self.canonical.country_code,\n                \"registration_date\": self.canonical.registration_date,\n            },\n        }\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.SnfeiResult.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert result to dictionary for serialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert result to dictionary for serialization.\"\"\"\n    return {\n        \"snfei\": self.snfei.value,\n        \"confidence_score\": self.confidence_score,\n        \"tier\": self.tier,\n        \"fields_used\": self.fields_used,\n        \"canonical\": {\n            \"legal_name_normalized\": self.canonical.legal_name_normalized,\n            \"address_normalized\": self.canonical.address_normalized,\n            \"country_code\": self.canonical.country_code,\n            \"registration_date\": self.canonical.registration_date,\n        },\n    }\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.compute_snfei","title":"compute_snfei","text":"<pre><code>compute_snfei(canonical: CanonicalInput) -&gt; Snfei\n</code></pre> <p>Compute SNFEI from canonical input.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>CanonicalInput</code> <p>Normalized input structure.</p> required <p>Returns:</p> Type Description <code>Snfei</code> <p>Computed SNFEI.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def compute_snfei(canonical: CanonicalInput) -&gt; Snfei:\n    \"\"\"Compute SNFEI from canonical input.\n\n    Args:\n        canonical: Normalized input structure.\n\n    Returns:\n        Computed SNFEI.\n    \"\"\"\n    hash_input = canonical.to_hash_string()\n    hash_bytes = hashlib.sha256(hash_input.encode(\"utf-8\")).hexdigest().lower()\n    return Snfei(hash_bytes)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.generate_snfei","title":"generate_snfei","text":"<pre><code>generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; SnfeiResult\n</code></pre> <p>Generate an SNFEI from raw entity attributes.</p> <p>This is the main entry point for SNFEI generation. It applies the Normalizing Functor to all inputs before hashing.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code (e.g., \"US\", \"CA\").</p> required <code>address</code> <code>str | None</code> <p>Optional primary street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional formation/registration date.</p> <code>None</code> <p>Returns:</p> Type Description <code>SnfeiResult</code> <p>SnfeiResult for verification.</p> Example <p>snfei, inputs = generate_snfei( ...     legal_name=\"Springfield Unified Sch. Dist., Inc.\", ...     country_code=\"US\", ...     address=\"123 Main St., Suite 100\", ...     registration_date=\"01/15/1985\", ... ) print(snfei) a1b2c3d4... print(inputs.legal_name_normalized) springfield unified school district incorporated</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def generate_snfei(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; SnfeiResult:\n    \"\"\"Generate an SNFEI from raw entity attributes.\n\n    This is the main entry point for SNFEI generation. It applies the\n    Normalizing Functor to all inputs before hashing.\n\n    Args:\n        legal_name: Raw legal name from source system.\n        country_code: ISO 3166-1 alpha-2 country code (e.g., \"US\", \"CA\").\n        address: Optional primary street address.\n        registration_date: Optional formation/registration date.\n\n    Returns:\n        SnfeiResult for verification.\n\n    Example:\n        &gt;&gt;&gt; snfei, inputs = generate_snfei(\n        ...     legal_name=\"Springfield Unified Sch. Dist., Inc.\",\n        ...     country_code=\"US\",\n        ...     address=\"123 Main St., Suite 100\",\n        ...     registration_date=\"01/15/1985\",\n        ... )\n        &gt;&gt;&gt; print(snfei)\n        a1b2c3d4...\n        &gt;&gt;&gt; print(inputs.legal_name_normalized)\n        springfield unified school district incorporated\n    \"\"\"\n    canonical = build_canonical_input(\n        legal_name=legal_name,\n        country_code=country_code,\n        address=address,\n        registration_date=registration_date,\n    )\n    snfei = compute_snfei(canonical)\n\n    # Determine fields used from what's present in canonical\n    fields_used = [\"legal_name\", \"country_code\"]\n    if canonical.address_normalized:\n        fields_used.append(\"address\")\n    if canonical.registration_date:\n        fields_used.append(\"registration_date\")\n\n    # Basic confidence: Tier 3, score based on fields\n    confidence = 0.5\n    if canonical.address_normalized:\n        confidence += 0.2\n    if canonical.registration_date:\n        confidence += 0.2\n    word_count = len(canonical.legal_name_normalized.split())\n    if word_count &gt; 3:\n        confidence += 0.1\n    confidence = min(confidence, 0.9)\n\n    return SnfeiResult(\n        snfei=snfei,\n        canonical=canonical,\n        confidence_score=round(confidence, 2),\n        tier=3,\n        fields_used=fields_used,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.generate_snfei_simple","title":"generate_snfei_simple","text":"<pre><code>generate_snfei_simple(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n) -&gt; str\n</code></pre> <p>Generate SNFEI as a simple hex string.</p> <p>Convenience function that returns just the hash value.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional primary street address.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>64-character lowercase hex SNFEI string.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def generate_snfei_simple(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n) -&gt; str:\n    \"\"\"Generate SNFEI as a simple hex string.\n\n    Convenience function that returns just the hash value.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional primary street address.\n\n    Returns:\n        64-character lowercase hex SNFEI string.\n    \"\"\"\n    result = generate_snfei(legal_name, country_code, address)\n    return result.snfei.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.generator.generate_snfei_with_confidence","title":"generate_snfei_with_confidence","text":"<pre><code>generate_snfei_with_confidence(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; SnfeiResult\n</code></pre> <p>Generate SNFEI with confidence scoring and tier classification.</p> <p>Tier Classification: - Tier 1: Entity has LEI (global identifier) - confidence 1.0 - Tier 2: Entity has SAM UEI (federal identifier) - confidence 0.95 - Tier 3: Entity uses SNFEI (computed hash) - confidence varies</p> <p>Tier 3 Confidence Scoring: - Base: 0.5 (name + country only) - +0.2 if address is provided - +0.2 if registration_date is provided - +0.1 if name is reasonably long (&gt;3 words)</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration date.</p> <code>None</code> <code>lei</code> <code>str | None</code> <p>Optional LEI (Legal Entity Identifier).</p> <code>None</code> <code>sam_uei</code> <code>str | None</code> <p>Optional SAM.gov Unique Entity Identifier.</p> <code>None</code> <p>Returns:</p> Type Description <code>SnfeiResult</code> <p>SnfeiResult with SNFEI, confidence score, and metadata.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/generator.py</code> <pre><code>def generate_snfei_with_confidence(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n    lei: str | None = None,\n    sam_uei: str | None = None,\n) -&gt; SnfeiResult:\n    \"\"\"Generate SNFEI with confidence scoring and tier classification.\n\n    Tier Classification:\n    - Tier 1: Entity has LEI (global identifier) - confidence 1.0\n    - Tier 2: Entity has SAM UEI (federal identifier) - confidence 0.95\n    - Tier 3: Entity uses SNFEI (computed hash) - confidence varies\n\n    Tier 3 Confidence Scoring:\n    - Base: 0.5 (name + country only)\n    - +0.2 if address is provided\n    - +0.2 if registration_date is provided\n    - +0.1 if name is reasonably long (&gt;3 words)\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration date.\n        lei: Optional LEI (Legal Entity Identifier).\n        sam_uei: Optional SAM.gov Unique Entity Identifier.\n\n    Returns:\n        SnfeiResult with SNFEI, confidence score, and metadata.\n    \"\"\"\n    fields_used = [\"legal_name\", \"country_code\"]\n\n    # Tier 1: LEI available\n    if lei and len(lei) == 20:\n        canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n        # For Tier 1, we still compute SNFEI but confidence is 1.0\n        snfei = compute_snfei(canonical)\n        return SnfeiResult(\n            snfei=snfei,\n            canonical=canonical,\n            confidence_score=1.0,\n            tier=1,\n            fields_used=[\"lei\"] + fields_used,\n        )\n\n    # Tier 2: SAM UEI available\n    if sam_uei and len(sam_uei) == 12:\n        canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n        snfei = compute_snfei(canonical)\n        return SnfeiResult(\n            snfei=snfei,\n            canonical=canonical,\n            confidence_score=0.95,\n            tier=2,\n            fields_used=[\"sam_uei\"] + fields_used,\n        )\n\n    # Tier 3: Compute SNFEI from attributes\n    canonical = build_canonical_input(legal_name, country_code, address, registration_date)\n    snfei = compute_snfei(canonical)\n\n    # Calculate confidence score\n    confidence = 0.5  # Base score\n\n    if address:\n        fields_used.append(\"address\")\n        confidence += 0.2\n\n    if registration_date:\n        fields_used.append(\"registration_date\")\n        confidence += 0.2\n\n    # Bonus for longer, more specific names\n    word_count = len(canonical.legal_name_normalized.split())\n    if word_count &gt; 3:\n        confidence += 0.1\n\n    # Cap at 0.9 for Tier 3\n    confidence = min(confidence, 0.9)\n\n    return SnfeiResult(\n        snfei=snfei,\n        canonical=canonical,\n        confidence_score=round(confidence, 2),\n        tier=3,\n        fields_used=fields_used,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization","title":"localization","text":"<p>Localization Functor: Jurisdiction-Specific Transformations.</p> <p>This module loads and applies jurisdiction-specific normalization rules BEFORE the universal Normalizing Functor is applied.</p> <p>The Localization Functor L transforms raw local data into a canonical intermediate form that the universal normalizer can process:</p> <pre><code>L: RawLocal \u2192 IntermediateCanonical\nN: IntermediateCanonical \u2192 FinalCanonical\n\nSNFEI = Hash(N(L(raw_data)))\n</code></pre> Directory Structure <p>/localization/     base.yaml           # Default/fallback rules     us/         base.yaml       # US-wide rules         ca.yaml         # California-specific         ny.yaml         # New York-specific     ca/         base.yaml       # Canada-wide rules         on.yaml         # Ontario-specific         qc.yaml         # Quebec-specific</p>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.LocalizationConfig","title":"LocalizationConfig  <code>dataclass</code>","text":"<p>Configuration for a specific jurisdiction.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationConfig:\n    \"\"\"Configuration for a specific jurisdiction.\"\"\"\n\n    jurisdiction: str  # e.g., \"us/ca\", \"ca/on\"\n    parent: str | None  # Parent jurisdiction for inheritance\n\n    # Transformation maps\n    abbreviations: dict[str, str] = field(default_factory=dict)\n    agency_names: dict[str, str] = field(default_factory=dict)\n    entity_types: dict[str, str] = field(default_factory=dict)\n\n    # Additional rules\n    rules: list[LocalizationRule] = field(default_factory=list)\n\n    # Stop words specific to this jurisdiction\n    stop_words: set[str] = field(default_factory=set)\n\n    def apply_to_name(self, name: str) -&gt; str:\n        \"\"\"Apply jurisdiction-specific transformations to a name.\n\n        Order of application:\n        1. Agency name expansions\n        2. Abbreviation expansions\n        3. Entity type standardization\n        4. Custom rules\n        \"\"\"\n        result = name.lower()\n\n        # 1. Agency names (exact match, case-insensitive)\n        for abbrev, full in self.agency_names.items():\n            # Word boundary matching\n            import re\n\n            pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n            result = re.sub(pattern, full.lower(), result)\n\n        # 2. Abbreviations\n        tokens = result.split()\n        expanded = []\n        for token in tokens:\n            if token in self.abbreviations:\n                expanded.append(self.abbreviations[token].lower())\n            else:\n                expanded.append(token)\n        result = \" \".join(expanded)\n\n        # 3. Entity types\n        for local_type, canonical_type in self.entity_types.items():\n            import re\n\n            pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n            result = re.sub(pattern, canonical_type.lower(), result)\n\n        # 4. Custom rules\n        for rule in self.rules:\n            if rule.is_regex:\n                import re\n\n                result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n            else:\n                result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n        return result\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.LocalizationConfig.apply_to_name","title":"apply_to_name","text":"<pre><code>apply_to_name(name: str) -&gt; str\n</code></pre> <p>Apply jurisdiction-specific transformations to a name.</p> <p>Order of application: 1. Agency name expansions 2. Abbreviation expansions 3. Entity type standardization 4. Custom rules</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def apply_to_name(self, name: str) -&gt; str:\n    \"\"\"Apply jurisdiction-specific transformations to a name.\n\n    Order of application:\n    1. Agency name expansions\n    2. Abbreviation expansions\n    3. Entity type standardization\n    4. Custom rules\n    \"\"\"\n    result = name.lower()\n\n    # 1. Agency names (exact match, case-insensitive)\n    for abbrev, full in self.agency_names.items():\n        # Word boundary matching\n        import re\n\n        pattern = r\"\\b\" + re.escape(abbrev.lower()) + r\"\\b\"\n        result = re.sub(pattern, full.lower(), result)\n\n    # 2. Abbreviations\n    tokens = result.split()\n    expanded = []\n    for token in tokens:\n        if token in self.abbreviations:\n            expanded.append(self.abbreviations[token].lower())\n        else:\n            expanded.append(token)\n    result = \" \".join(expanded)\n\n    # 3. Entity types\n    for local_type, canonical_type in self.entity_types.items():\n        import re\n\n        pattern = r\"\\b\" + re.escape(local_type.lower()) + r\"\\b\"\n        result = re.sub(pattern, canonical_type.lower(), result)\n\n    # 4. Custom rules\n    for rule in self.rules:\n        if rule.is_regex:\n            import re\n\n            result = re.sub(rule.pattern, rule.replacement, result, flags=re.IGNORECASE)\n        else:\n            result = result.replace(rule.pattern.lower(), rule.replacement.lower())\n\n    return result\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.LocalizationRegistry","title":"LocalizationRegistry","text":"<p>Registry for loading and caching localization configurations.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>class LocalizationRegistry:\n    \"\"\"Registry for loading and caching localization configurations.\"\"\"\n\n    def __init__(self, config_dir: Path | None = None):\n        \"\"\"Initialize the registry.\n\n        Args:\n            config_dir: Optional path to localization YAML files.\n                       If None, only built-in configs are available.\n        \"\"\"\n        self.config_dir = config_dir\n        self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n\n    def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n        \"\"\"Get localization config for a jurisdiction.\n\n        Falls back through parent jurisdictions if specific config not found.\n        Merges child config with parent config for inheritance.\n\n        Args:\n            jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                         Case-insensitive - will be normalized to lowercase.\n\n        Returns:\n            LocalizationConfig for the jurisdiction (merged with parent).\n        \"\"\"\n        # Normalize to lowercase\n        jurisdiction = jurisdiction.lower()\n\n        # Check if we have a merged config cached\n        cache_key = f\"_merged_{jurisdiction}\"\n        if cache_key in self._cache:\n            return self._cache[cache_key]\n\n        # Get the base config for this jurisdiction\n        if jurisdiction in self._cache:\n            config = self._cache[jurisdiction]\n        elif self.config_dir:\n            config = self._load_yaml(jurisdiction)\n            if config:\n                self._cache[jurisdiction] = config\n            else:\n                config = None\n        else:\n            config = None\n\n        # If no config found, fall back to parent\n        if config is None:\n            if \"/\" in jurisdiction:\n                parent = jurisdiction.rsplit(\"/\", 1)[0]\n                return self.get_config(parent)\n            # Return empty config as last resort\n            return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n        # If config has a parent, merge with parent config\n        if config.parent:\n            parent_config = self.get_config(config.parent)\n            merged = self.merge_configs(config, parent_config)\n            self._cache[cache_key] = merged\n            return merged\n\n        return config\n\n    def _load_yaml(self, jurisdiction: str) -&gt; LocalizationConfig | None:\n        \"\"\"Load config from YAML file.\n\n        Expected paths:\n            - {config_dir}/{country}/base.yaml for country-level (e.g., US, CA)\n            - {config_dir}/{country}/{region}.yaml for region-level (e.g., us/ca, ca/on)\n        \"\"\"\n        if not self.config_dir:\n            return None\n\n        # Determine the YAML file path\n        if \"/\" in jurisdiction:\n            # Region-level: us/ca -&gt; us/ca.yaml\n            parts = jurisdiction.split(\"/\")\n            yaml_path = self.config_dir / parts[0] / f\"{parts[1]}.yaml\"\n        else:\n            # Country-level: US -&gt; us/base.yaml\n            yaml_path = self.config_dir / jurisdiction / \"base.yaml\"\n\n        if not yaml_path.exists():\n            return None\n\n        try:\n            with yaml_path.open(\"r\", encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n\n            if not data:\n                return None\n\n            # Parse rules if present\n            rules = []\n            for rule_data in data.get(\"rules\", []):\n                rules.append(\n                    LocalizationRule(\n                        pattern=rule_data.get(\"pattern\", \"\"),\n                        replacement=rule_data.get(\"replacement\", \"\"),\n                        is_regex=rule_data.get(\"is_regex\", False),\n                        context=rule_data.get(\"context\"),\n                    )\n                )\n\n            return LocalizationConfig(\n                jurisdiction=data.get(\"jurisdiction\", jurisdiction),\n                parent=data.get(\"parent\"),\n                abbreviations=data.get(\"abbreviations\", {}),\n                agency_names=data.get(\"agency_names\", {}),\n                entity_types=data.get(\"entity_types\", {}),\n                rules=rules,\n                stop_words=set(data.get(\"stop_words\", [])),\n            )\n        except Exception as e:\n            # Log error but don't crash\n            print(f\"Warning: Failed to load localization YAML {yaml_path}: {e}\")\n            return None\n\n    def merge_configs(\n        self, child: LocalizationConfig, parent: LocalizationConfig\n    ) -&gt; LocalizationConfig:\n        \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n        merged_abbrevs = dict(parent.abbreviations)\n        merged_abbrevs.update(child.abbreviations)\n\n        merged_agencies = dict(parent.agency_names)\n        merged_agencies.update(child.agency_names)\n\n        merged_types = dict(parent.entity_types)\n        merged_types.update(child.entity_types)\n\n        return LocalizationConfig(\n            jurisdiction=child.jurisdiction,\n            parent=parent.jurisdiction,\n            abbreviations=merged_abbrevs,\n            agency_names=merged_agencies,\n            entity_types=merged_types,\n            rules=parent.rules + child.rules,\n            stop_words=parent.stop_words | child.stop_words,\n        )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.LocalizationRegistry.__init__","title":"__init__","text":"<pre><code>__init__(config_dir: Path | None = None)\n</code></pre> <p>Initialize the registry.</p> <p>Parameters:</p> Name Type Description Default <code>config_dir</code> <code>Path | None</code> <p>Optional path to localization YAML files.        If None, only built-in configs are available.</p> <code>None</code> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def __init__(self, config_dir: Path | None = None):\n    \"\"\"Initialize the registry.\n\n    Args:\n        config_dir: Optional path to localization YAML files.\n                   If None, only built-in configs are available.\n    \"\"\"\n    self.config_dir = config_dir\n    self._cache: dict[str, LocalizationConfig] = dict(BUILT_IN_CONFIGS)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.LocalizationRegistry.get_config","title":"get_config","text":"<pre><code>get_config(jurisdiction: str) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction.</p> <p>Falls back through parent jurisdictions if specific config not found. Merges child config with parent config for inheritance.</p> <p>Parameters:</p> Name Type Description Default <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\", \"ca/on\").          Case-insensitive - will be normalized to lowercase.</p> required <p>Returns:</p> Type Description <code>LocalizationConfig</code> <p>LocalizationConfig for the jurisdiction (merged with parent).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def get_config(self, jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction.\n\n    Falls back through parent jurisdictions if specific config not found.\n    Merges child config with parent config for inheritance.\n\n    Args:\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\", \"ca/on\").\n                     Case-insensitive - will be normalized to lowercase.\n\n    Returns:\n        LocalizationConfig for the jurisdiction (merged with parent).\n    \"\"\"\n    # Normalize to lowercase\n    jurisdiction = jurisdiction.lower()\n\n    # Check if we have a merged config cached\n    cache_key = f\"_merged_{jurisdiction}\"\n    if cache_key in self._cache:\n        return self._cache[cache_key]\n\n    # Get the base config for this jurisdiction\n    if jurisdiction in self._cache:\n        config = self._cache[jurisdiction]\n    elif self.config_dir:\n        config = self._load_yaml(jurisdiction)\n        if config:\n            self._cache[jurisdiction] = config\n        else:\n            config = None\n    else:\n        config = None\n\n    # If no config found, fall back to parent\n    if config is None:\n        if \"/\" in jurisdiction:\n            parent = jurisdiction.rsplit(\"/\", 1)[0]\n            return self.get_config(parent)\n        # Return empty config as last resort\n        return LocalizationConfig(jurisdiction=jurisdiction, parent=None)\n\n    # If config has a parent, merge with parent config\n    if config.parent:\n        parent_config = self.get_config(config.parent)\n        merged = self.merge_configs(config, parent_config)\n        self._cache[cache_key] = merged\n        return merged\n\n    return config\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.LocalizationRegistry.merge_configs","title":"merge_configs","text":"<pre><code>merge_configs(\n    child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig\n</code></pre> <p>Merge child config with parent (child overrides parent).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def merge_configs(\n    self, child: LocalizationConfig, parent: LocalizationConfig\n) -&gt; LocalizationConfig:\n    \"\"\"Merge child config with parent (child overrides parent).\"\"\"\n    merged_abbrevs = dict(parent.abbreviations)\n    merged_abbrevs.update(child.abbreviations)\n\n    merged_agencies = dict(parent.agency_names)\n    merged_agencies.update(child.agency_names)\n\n    merged_types = dict(parent.entity_types)\n    merged_types.update(child.entity_types)\n\n    return LocalizationConfig(\n        jurisdiction=child.jurisdiction,\n        parent=parent.jurisdiction,\n        abbreviations=merged_abbrevs,\n        agency_names=merged_agencies,\n        entity_types=merged_types,\n        rules=parent.rules + child.rules,\n        stop_words=parent.stop_words | child.stop_words,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.LocalizationRule","title":"LocalizationRule  <code>dataclass</code>","text":"<p>A single localization transformation rule.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>@dataclass\nclass LocalizationRule:\n    \"\"\"A single localization transformation rule.\"\"\"\n\n    pattern: str  # Text to match (case-insensitive)\n    replacement: str  # Replacement text\n    is_regex: bool = False  # Whether pattern is a regex\n    context: str | None = None  # Optional context (e.g., \"agency\", \"school\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.apply_localization","title":"apply_localization","text":"<pre><code>apply_localization(name: str, jurisdiction: str) -&gt; str\n</code></pre> <p>Apply localization transforms to a name.</p> <p>This is the Localization Functor L.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw entity name.</p> required <code>jurisdiction</code> <code>str</code> <p>Jurisdiction code (e.g., \"us/ca\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name with jurisdiction-specific transforms applied.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def apply_localization(name: str, jurisdiction: str) -&gt; str:\n    \"\"\"Apply localization transforms to a name.\n\n    This is the Localization Functor L.\n\n    Args:\n        name: Raw entity name.\n        jurisdiction: Jurisdiction code (e.g., \"us/ca\").\n\n    Returns:\n        Name with jurisdiction-specific transforms applied.\n    \"\"\"\n    config = get_localization_config(jurisdiction)\n    return config.apply_to_name(name)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.localization.get_localization_config","title":"get_localization_config","text":"<pre><code>get_localization_config(\n    jurisdiction: str,\n) -&gt; LocalizationConfig\n</code></pre> <p>Get localization config for a jurisdiction (convenience function).</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/localization.py</code> <pre><code>def get_localization_config(jurisdiction: str) -&gt; LocalizationConfig:\n    \"\"\"Get localization config for a jurisdiction (convenience function).\"\"\"\n    return _registry.get_config(jurisdiction)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalizer","title":"normalizer","text":"<p>CEP Core Linker: The Normalizing Functor.</p> <p>This module implements the universal normalization pipeline that transforms entity attributes into hash-ready canonical form for SNFEI generation.</p> <p>The architecture follows the Category Theory foundation: - Localization Functor: Jurisdiction-specific transforms (YAML-driven) - Normalizing Functor: Universal normalization steps (this module) - SNFEI Hash: Final SHA-256 computation</p> Directory Structure <p>/snfei/     normalizer.py      # Universal normalization (this file)     generator.py       # SNFEI hash generation     localization.py    # Localization functor implementation /localization/     us/               # US state-specific rules         ca.yaml         ny.yaml     ca/               # Canada province-specific rules         on.yaml         qc.yaml     base.yaml         # Fallback rules</p> Mathematical Foundation <p>The Normalizing Functor N transforms the category of Raw Entity Data into the category of Canonical Entity Data:</p> <p>N: RawEntity \u2192 CanonicalEntity</p> <p>Where N preserves identity (same entity always maps to same canonical form) and composition (N(L(x)) = N \u2218 L(x) where L is the localization functor).</p>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalizer.CanonicalInput","title":"CanonicalInput  <code>dataclass</code>","text":"<p>Normalized input for SNFEI hashing.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>@dataclass\nclass CanonicalInput:\n    \"\"\"Normalized input for SNFEI hashing.\"\"\"\n\n    legal_name_normalized: str\n    address_normalized: str | None\n    country_code: str\n    registration_date: str | None\n\n    def to_hash_string(self) -&gt; str:\n        \"\"\"Generate the concatenated string for hashing.\n\n        Format:\n            legal_name_normalized|address_normalized|country_code|registration_date\n\n        Empty/None fields are included as empty strings to maintain\n        consistent field positions.\n        \"\"\"\n        parts = [\n            self.legal_name_normalized,\n            self.address_normalized or \"\",\n            self.country_code,\n            self.registration_date or \"\",\n        ]\n        return \"|\".join(parts)\n\n    def to_hash_string_v2(self) -&gt; str:\n        \"\"\"Alternative format that omits empty fields.\n\n        This produces shorter strings but requires all implementations\n        to handle optional fields identically.\n        \"\"\"\n        parts = [self.legal_name_normalized]\n        if self.address_normalized:\n            parts.append(self.address_normalized)\n        parts.append(self.country_code)\n        if self.registration_date:\n            parts.append(self.registration_date)\n        return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalizer.CanonicalInput.to_hash_string","title":"to_hash_string","text":"<pre><code>to_hash_string() -&gt; str\n</code></pre> <p>Generate the concatenated string for hashing.</p> Format <p>legal_name_normalized|address_normalized|country_code|registration_date</p> <p>Empty/None fields are included as empty strings to maintain consistent field positions.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def to_hash_string(self) -&gt; str:\n    \"\"\"Generate the concatenated string for hashing.\n\n    Format:\n        legal_name_normalized|address_normalized|country_code|registration_date\n\n    Empty/None fields are included as empty strings to maintain\n    consistent field positions.\n    \"\"\"\n    parts = [\n        self.legal_name_normalized,\n        self.address_normalized or \"\",\n        self.country_code,\n        self.registration_date or \"\",\n    ]\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalizer.CanonicalInput.to_hash_string_v2","title":"to_hash_string_v2","text":"<pre><code>to_hash_string_v2() -&gt; str\n</code></pre> <p>Alternative format that omits empty fields.</p> <p>This produces shorter strings but requires all implementations to handle optional fields identically.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def to_hash_string_v2(self) -&gt; str:\n    \"\"\"Alternative format that omits empty fields.\n\n    This produces shorter strings but requires all implementations\n    to handle optional fields identically.\n    \"\"\"\n    parts = [self.legal_name_normalized]\n    if self.address_normalized:\n        parts.append(self.address_normalized)\n    parts.append(self.country_code)\n    if self.registration_date:\n        parts.append(self.registration_date)\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalizer.build_canonical_input","title":"build_canonical_input","text":"<pre><code>build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput\n</code></pre> <p>Build a canonical input structure from raw entity data.</p> <p>Parameters:</p> Name Type Description Default <code>legal_name</code> <code>str</code> <p>Raw legal name.</p> required <code>country_code</code> <code>str</code> <p>ISO 3166-1 alpha-2 country code.</p> required <code>address</code> <code>str | None</code> <p>Optional street address.</p> <code>None</code> <code>registration_date</code> <code>str | None</code> <p>Optional registration/formation date.</p> <code>None</code> <p>Returns:</p> Type Description <code>CanonicalInput</code> <p>CanonicalInput with all fields normalized.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def build_canonical_input(\n    legal_name: str,\n    country_code: str,\n    address: str | None = None,\n    registration_date: str | None = None,\n) -&gt; CanonicalInput:\n    \"\"\"Build a canonical input structure from raw entity data.\n\n    Args:\n        legal_name: Raw legal name.\n        country_code: ISO 3166-1 alpha-2 country code.\n        address: Optional street address.\n        registration_date: Optional registration/formation date.\n\n    Returns:\n        CanonicalInput with all fields normalized.\n    \"\"\"\n    return CanonicalInput(\n        legal_name_normalized=normalize_legal_name(legal_name),\n        address_normalized=normalize_address(address) if address else None,\n        country_code=country_code.upper(),\n        registration_date=normalize_registration_date(registration_date)\n        if registration_date\n        else None,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalizer.normalize_address","title":"normalize_address","text":"<pre><code>normalize_address(\n    address: str, remove_secondary: bool = True\n) -&gt; str\n</code></pre> <p>Normalize a street address for SNFEI hashing.</p> <p>Pipeline: 1. Lowercase 2. ASCII transliteration 3. Remove secondary unit designators (apt, suite, etc.) 4. Remove punctuation 5. Expand postal abbreviations 6. Collapse whitespace</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Raw street address.</p> required <code>remove_secondary</code> <code>bool</code> <p>Whether to remove apartment/suite numbers.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized address string.</p> Example <p>normalize_address(\"123 N. Main St., Suite 400\") \"123 north main street\"</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def normalize_address(\n    address: str,\n    remove_secondary: bool = True,\n) -&gt; str:\n    \"\"\"Normalize a street address for SNFEI hashing.\n\n    Pipeline:\n    1. Lowercase\n    2. ASCII transliteration\n    3. Remove secondary unit designators (apt, suite, etc.)\n    4. Remove punctuation\n    5. Expand postal abbreviations\n    6. Collapse whitespace\n\n    Args:\n        address: Raw street address.\n        remove_secondary: Whether to remove apartment/suite numbers.\n\n    Returns:\n        Normalized address string.\n\n    Example:\n        &gt;&gt;&gt; normalize_address(\"123 N. Main St., Suite 400\")\n        \"123 north main street\"\n    \"\"\"\n    if not address:\n        return \"\"\n\n    # 1. Lowercase\n    text = address.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove secondary unit designators\n    if remove_secondary:\n        for pattern in SECONDARY_UNIT_PATTERNS:\n            text = re.sub(pattern, \"\", text, flags=re.IGNORECASE)\n\n    # 4. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 5. Collapse whitespace first\n    text = _collapse_whitespace(text)\n\n    # 6. Expand postal abbreviations\n    tokens = text.split()\n    expanded = []\n    for token in tokens:\n        if token in US_ADDRESS_EXPANSIONS:\n            expanded.append(US_ADDRESS_EXPANSIONS[token])\n        else:\n            expanded.append(token)\n    text = \" \".join(expanded)\n\n    # 7. Final trim\n    return text.strip()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalizer.normalize_legal_name","title":"normalize_legal_name","text":"<pre><code>normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str\n</code></pre> <p>Apply the universal normalization pipeline to a legal name.</p> <p>Pipeline (in order): 1. Convert to lowercase 2. ASCII transliteration 3. Remove punctuation 4. Collapse whitespace 5. Expand abbreviations 6. Remove stop words (optional) 7. Final trim</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Raw legal name from source system.</p> required <code>remove_stop_words</code> <code>bool</code> <p>Whether to filter out stop words.</p> <code>True</code> <code>preserve_initial_stop</code> <code>bool</code> <p>If True, preserve stop word at start of name.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Normalized name suitable for SNFEI hashing.</p> Example <p>normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\") \"springfield unified school district incorporated\"</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def normalize_legal_name(\n    name: str,\n    remove_stop_words: bool = True,\n    preserve_initial_stop: bool = False,\n) -&gt; str:\n    \"\"\"Apply the universal normalization pipeline to a legal name.\n\n    Pipeline (in order):\n    1. Convert to lowercase\n    2. ASCII transliteration\n    3. Remove punctuation\n    4. Collapse whitespace\n    5. Expand abbreviations\n    6. Remove stop words (optional)\n    7. Final trim\n\n    Args:\n        name: Raw legal name from source system.\n        remove_stop_words: Whether to filter out stop words.\n        preserve_initial_stop: If True, preserve stop word at start of name.\n\n    Returns:\n        Normalized name suitable for SNFEI hashing.\n\n    Example:\n        &gt;&gt;&gt; normalize_legal_name(\"The Springfield Unified Sch. Dist., Inc.\")\n        \"springfield unified school district incorporated\"\n    \"\"\"\n    if not name:\n        return \"\"\n\n    # 1. Lowercase\n    text = name.lower()\n\n    # 2. ASCII transliteration\n    text = _to_ascii(text)\n\n    # 3. Remove punctuation\n    text = _remove_punctuation(text)\n\n    # 4. Collapse whitespace\n    text = _collapse_whitespace(text)\n\n    # 5. Expand abbreviations\n    text = _expand_abbreviations(text)\n\n    # 6. Remove stop words\n    if remove_stop_words:\n        text = _remove_stop_words(text, preserve_initial=preserve_initial_stop)\n\n    # 7. Final collapse and trim\n    return _collapse_whitespace(text)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.snfei.normalizer.normalize_registration_date","title":"normalize_registration_date","text":"<pre><code>normalize_registration_date(date_str: str) -&gt; str | None\n</code></pre> <p>Normalize a registration date to ISO 8601 format.</p> <p>Returns None if date cannot be parsed.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string in various formats.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>ISO 8601 date string (YYYY-MM-DD) or None.</p> Source code in <code>src/python/src/civic_exchange_protocol/snfei/normalizer.py</code> <pre><code>def normalize_registration_date(date_str: str) -&gt; str | None:\n    \"\"\"Normalize a registration date to ISO 8601 format.\n\n    Returns None if date cannot be parsed.\n\n    Args:\n        date_str: Date string in various formats.\n\n    Returns:\n        ISO 8601 date string (YYYY-MM-DD) or None.\n    \"\"\"\n    if not date_str:\n        return None\n\n    # Remove extra whitespace\n    date_str = date_str.strip()\n\n    # Try common date patterns\n\n    patterns = [\n        # ISO format\n        (r\"^(\\d{4})-(\\d{2})-(\\d{2})$\", \"%Y-%m-%d\"),\n        # US format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%m/%d/%Y\"),\n        (r\"^(\\d{1,2})-(\\d{1,2})-(\\d{4})$\", \"%m-%d-%Y\"),\n        # European format\n        (r\"^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\", \"%d/%m/%Y\"),\n        # Year only\n        (r\"^(\\d{4})$\", \"%Y\"),\n    ]\n\n    for pattern, fmt in patterns:\n        if re.match(pattern, date_str):\n            try:\n                if fmt == \"%Y\":\n                    # Year only - use January 1\n                    return f\"{date_str}-01-01\"\n                dt = datetime.strptime(date_str, fmt)\n                return dt.strftime(\"%Y-%m-%d\")\n            except ValueError:\n                continue\n\n    return None\n</code></pre>"},{"location":"en/cli/","title":"CLI Reference","text":""},{"location":"en/cli/#quick-help","title":"Quick help","text":"<pre><code># Show top-level help\ncx --help\n\n# Show help for a subcommand\ncx &lt;subcommand&gt; --help\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/","title":"Category Theory Foundation for CEP","text":""},{"location":"en/concepts/category-theory-foundation/#overview","title":"Overview","text":"<p>This document provides a formal categorical semantics for the Civic Exchange Protocol (CEP). The goal is to prove that the system's design is mathematically sound, ensuring that compositions of civic relationships and exchanges behave predictably and that the Verifiable ID system constitutes a proper universal construction.</p>"},{"location":"en/concepts/category-theory-foundation/#1-the-category-civic","title":"1. The Category Civic","text":"<p>We define a category Civic as follows:</p>"},{"location":"en/concepts/category-theory-foundation/#objects","title":"Objects","text":"<p>The objects of Civic are attested civic entities. Each object E represents: - A verified legal entity (government agency, contractor, nonprofit, individual) - With a canonical Verifiable ID - At a specific point in time (revision number)</p> <p>Formally: <code>Ob(Civic) = { E | E is a valid CEP entity record }</code></p>"},{"location":"en/concepts/category-theory-foundation/#morphisms","title":"Morphisms","text":"<p>The morphisms in Civic are relationships and exchanges between entities. A morphism <code>f: A \u2192 B</code> represents a directed flow of legal obligation, value, or authority from entity A to entity B.</p> <p>There are two kinds of morphisms:</p> <ol> <li>Relationship morphisms: Represent the legal basis for interaction</li> <li><code>grant: FederalAgency \u2192 StateAgency</code></li> <li><code>contract: Agency \u2192 Contractor</code></li> <li> <p><code>subcontract: PrimeContractor \u2192 Subcontractor</code></p> </li> <li> <p>Exchange morphisms: Represent actual value flows within relationships</p> </li> <li><code>disburse: GrantingAgency \u2192 Grantee</code></li> <li><code>pay: ContractingOffice \u2192 Vendor</code></li> </ol>"},{"location":"en/concepts/category-theory-foundation/#identity-morphism","title":"Identity Morphism","text":"<p>For each entity E, the identity morphism <code>id_E: E \u2192 E</code> represents the entity's self-attestation\u2014the record where the entity attests to its own existence and status. This is the initial entity record with <code>previousRecordHash = null</code>.</p>"},{"location":"en/concepts/category-theory-foundation/#composition","title":"Composition","text":"<p>Given morphisms <code>f: A \u2192 B</code> and <code>g: B \u2192 C</code>, the composition <code>g \u2218 f: A \u2192 C</code> represents the compositional provenance chain.</p> <p>Example: Federal grant flows through a state to a local school district:</p> <pre><code>f: FederalDOE \u2192 StateEducationDept    (grant-award relationship)\ng: StateEducationDept \u2192 LocalDistrict  (subgrant relationship)\n\ng \u2218 f: FederalDOE \u2192 LocalDistrict      (derived provenance)\n</code></pre> <p>This composition is captured in the <code>provenanceChain.fundingChainTag</code> field as <code>FEDERAL&gt;STATE&gt;LOCAL</code>.</p>"},{"location":"en/concepts/category-theory-foundation/#associativity","title":"Associativity","text":"<p>Composition must be associative: <code>(h \u2218 g) \u2218 f = h \u2218 (g \u2218 f)</code></p> <p>For provenance chains: <pre><code>FED \u2192 STATE \u2192 COUNTY \u2192 CONTRACTOR\n\n((FED \u2192 STATE) \u2192 COUNTY) \u2192 CONTRACTOR = (FED \u2192 STATE) \u2192 (COUNTY \u2192 CONTRACTOR)\n</code></pre></p> <p>Both yield the same ultimate provenance: funds originating from FED, flowing through STATE and COUNTY, to CONTRACTOR. The <code>fundingChainTag</code> is identical regardless of grouping.</p> <p>Implementation guarantee: The <code>parentRelationshipId</code> and <code>parentExchangeId</code> fields create an explicit linked list that ensures associativity. You can trace back from any exchange to its ultimate source by following the chain.</p>"},{"location":"en/concepts/category-theory-foundation/#2-the-verifiable-id-as-a-universal-property","title":"2. The Verifiable ID as a Universal Property","text":""},{"location":"en/concepts/category-theory-foundation/#the-problem-multiple-representations","title":"The Problem: Multiple Representations","text":"<p>A single real-world entity may appear in many source systems with different identifiers: - SAM.gov: <code>J6H4FB3N5YK7</code> - State campaign finance: <code>VENDOR-2024-0093</code> - County procurement: <code>Acme Consulting LLC</code> (no ID, just a name) - Federal LEI system: <code>5493001KJTIIGC8Y1R12</code></p> <p>Each source system defines its own category of records, call them SAM, StateCF, CountyProc, LEI.</p>"},{"location":"en/concepts/category-theory-foundation/#the-diagram-to-commute","title":"The Diagram to Commute","text":"<p>We have partial identity mappings (entity resolution functions) between these systems: <pre><code>        SAM\n         \u2191\n         |  \u03c6_sam\n         |\n      ENTITY  \u2190---------- LEI\n         |      \u03c6_lei\n         |\n         \u2193  \u03c6_county\n    CountyProc\n</code></pre></p> <p>Each <code>\u03c6_X</code> is a functor from the source category to Civic that maps source records to entities.</p>"},{"location":"en/concepts/category-theory-foundation/#the-limit-construction","title":"The Limit Construction","text":"<p>The Entity <code>verifiableId</code> acts as the limit (specifically, a product in the relevant slice category) of the diagram of source identifiers.</p> <p>Definition: For an entity E appearing in source systems S\u2081, S\u2082, ..., S\u2099 with identifiers id\u2081, id\u2082, ..., id\u2099 respectively, the Verifiable ID is the unique object V equipped with projections: <pre><code>\u03c0_1: V \u2192 S\u2081   (maps V to id\u2081)\n\u03c0_2: V \u2192 S\u2082   (maps V to id\u2082)\n...\n\u03c0_n: V \u2192 S\u2099   (maps V to id\u2099)\n</code></pre></p> <p>Such that for any other object W with maps to all S\u1d62, there exists a unique map <code>u: W \u2192 V</code> making all triangles commute.</p> <p>In CEP terms: The <code>identifiers</code> object in entity is exactly this limit, it holds all known identifiers for the entity:</p> <pre><code>\"identifiers\": {\n  \"samUei\": \"J6H4FB3N5YK7\",\n  \"lei\": \"5493001KJTIIGC8Y1R12\",\n  \"snfei\": \"a3b2c1d4e5f6...\",\n  \"additionalSchemes\": [\n    {\"schemeUri\": \"https://state.gov/cf\", \"value\": \"VENDOR-2024-0093\"}\n  ]\n}\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-universal-property-guarantee","title":"The Universal Property Guarantee","text":"<p>The <code>verifiableId</code> (<code>entity:{scheme}:{value}</code>) provides the universal property:</p> <ol> <li> <p>Existence: For any entity in any source system, there exists an entity record with a verifiableId that subsumes all its known identifiers.</p> </li> <li> <p>Uniqueness: If two entity records claim to represent the same entity (have overlapping source identifiers), they MUST have the same verifiableId\u2014or one is an error requiring resolution.</p> </li> <li> <p>Confidence-Weighted Resolution: The <code>resolutionConfidence.score</code> field acknowledges that in practice, entity resolution is probabilistic. A score of 1.0 indicates authoritative identity (the entity self-attested or the source is canonical). Lower scores indicate probabilistic matching.</p> </li> </ol>"},{"location":"en/concepts/category-theory-foundation/#3-functors-the-bridge-to-external-standards","title":"3. Functors: The Bridge to External Standards","text":""},{"location":"en/concepts/category-theory-foundation/#the-xbrl-functor","title":"The XBRL Functor","text":"<p>Define <code>F_xbrl: Civic \u2192 XBRL</code> as a functor mapping: - entities \u2192 XBRL reporting entities - exchanges \u2192 XBRL fact instances</p> <p>This functor must preserve composition: if <code>g \u2218 f</code> is a provenance chain in Civic, then <code>F(g) \u2218 F(f)</code> must be a valid XBRL reporting chain.</p> <p>Implementation: The <code>categorization.gtasAccountCode</code> field in exchange records provides the data needed for this functor to operate\u2014it maps CEP exchanges to Treasury reporting concepts.</p>"},{"location":"en/concepts/category-theory-foundation/#the-w3c-prov-functor","title":"The W3C PROV Functor","text":"<p>Define <code>F_prov: Civic \u2192 PROV</code> mapping: - entities \u2192 <code>prov:Entity</code> - relationships \u2192 <code>prov:Activity</code> (the act of establishing a relationship) - exchanges \u2192 <code>prov:Activity</code> (the act of exchanging value) - Attestations \u2192 <code>prov:Agent</code> + <code>prov:wasAttributedTo</code></p> <p>The <code>attestation</code> block in every CEP record provides exactly the data needed for this mapping: - <code>attestorId</code> \u2192 <code>prov:Agent</code> - <code>attestationTimestamp</code> \u2192 <code>prov:atTime</code> - <code>proofValue</code> \u2192 provenance integrity proof</p>"},{"location":"en/concepts/category-theory-foundation/#4-the-amendment-chain-as-a-categorical-construction","title":"4. The Amendment Chain as a Categorical Construction","text":""},{"location":"en/concepts/category-theory-foundation/#the-category-of-revisions","title":"The Category of Revisions","text":"<p>For a given entity E, define the category Rev(E) where: - Objects are revisions: E\u2081, E\u2082, E\u2083, ... - Morphisms are amendment relationships: <code>amend: E\u1d62 \u2192 E\u1d62\u208a\u2081</code></p> <p>This forms a total order (a thin category where there's at most one morphism between any two objects).</p>"},{"location":"en/concepts/category-theory-foundation/#hash-chains-as-functors","title":"Hash Chains as Functors","text":"<p>The <code>previousRecordHash</code> field defines a functor <code>H: Rev(E) \u2192 HashChain</code> where HashChain is the category of SHA-256 hash values with \"derived-from\" morphisms.</p> <p>Preservation property: If <code>E\u1d62 \u2192amend E\u1d62\u208a\u2081</code>, then <code>H(E\u1d62)</code> is embedded in <code>E\u1d62\u208a\u2081.previousRecordHash</code>, creating an immutable audit trail.</p> <p>This is the categorical equivalent of a blockchain's hash chain, but without requiring distributed consensus\u2014the attesting node is responsible for chain integrity.</p>"},{"location":"en/concepts/category-theory-foundation/#5-the-slice-category-for-jurisdictional-scoping","title":"5. The Slice Category for Jurisdictional Scoping","text":""},{"location":"en/concepts/category-theory-foundation/#jurisdictional-restriction","title":"Jurisdictional Restriction","text":"<p>For a given jurisdiction J (e.g., <code>US-CA</code>), define the slice category <code>Civic/J</code> where: - Objects are entities with <code>jurisdictionIso</code> compatible with J - Morphisms are relationships/exchanges within that jurisdiction</p> <p>This allows queries like \"show me all contracts in California\" to be formalized as working within <code>Civic/US-CA</code> rather than searching all of Civic.</p>"},{"location":"en/concepts/category-theory-foundation/#the-inclusion-functor","title":"The Inclusion Functor","text":"<p>The forgetful functor <code>U: Civic/J \u2192 Civic</code> embeds jurisdictional data back into the global category, enabling cross-jurisdictional queries while preserving local structure.</p>"},{"location":"en/concepts/category-theory-foundation/#6-verification-the-proof-subcategory","title":"6. Verification: The Proof Subcategory","text":""},{"location":"en/concepts/category-theory-foundation/#defining-verification","title":"Defining Verification","text":"<p>A verified object or morphism is one where: 1. The <code>attestation.proofValue</code> is cryptographically valid 2. The <code>attestation.verificationMethodUri</code> resolves to a valid public key 3. If <code>anchorUri</code> is provided, the anchor can be independently verified</p>"},{"location":"en/concepts/category-theory-foundation/#the-subcategory-of-verified-records","title":"The Subcategory of Verified Records","text":"<p>Define Civic_verified \u2282 Civic as the full subcategory of verified records.</p> <p>The inclusion <code>I: Civic_verified \u2192 Civic</code> is faithful (injective on morphisms), meaning verification status is preserved under composition.</p> <p>Practical implication: If both <code>f: A \u2192 B</code> and <code>g: B \u2192 C</code> are verified, then <code>g \u2218 f: A \u2192 C</code> can be marked as having verified provenance\u2014the entire chain is trustworthy.</p>"},{"location":"en/concepts/category-theory-foundation/#7-summary-why-category-theory","title":"7. Summary: Why Category Theory?","text":"Categorical Concept CEP Implementation Benefit Objects entities Formalized identity Morphisms relationships, exchanges Typed, directed flows Composition <code>parentRelationshipId</code>, <code>fundingChainTag</code> Provenance tracing Identity Self-attestation (revision 1) Entity lifecycle start Limit/Universal Property Verifiable ID + <code>identifiers</code> Canonical identity resolution Functors XBRL, PROV mappings Interoperability Slice categories Jurisdictional scoping Efficient local queries Hash chain functor <code>previousRecordHash</code> Immutable audit trail"},{"location":"en/concepts/category-theory-foundation/#the-core-theorem","title":"The Core Theorem","text":"<p>Theorem: The CEP system, as defined by the entity, relationship, and exchange schemas with their attestation and hash chain requirements, forms a well-defined category Civic with: 1. A universal property for entity identity (the Verifiable ID limit) 2. Associative composition for provenance chains 3. Faithful functors to external standards (XBRL, PROV) 4. A verified subcategory preserving cryptographic integrity</p> <p>Corollary: Any implementation that correctly generates canonical strings and validates attestations will produce records that compose correctly in the categorical sense\u2014provenance chains will be traceable, amendments will be auditable, and cross-system identity will be resolvable.</p>"},{"location":"en/concepts/category-theory-foundation/#appendix-diagrammatic-notation","title":"Appendix: Diagrammatic Notation","text":""},{"location":"en/concepts/category-theory-foundation/#basic-composition","title":"Basic Composition","text":"<pre><code>    grant           subgrant\nFED -----\u2192 STATE ----------\u2192 LOCAL\n\n         composed to:\n\n         federal-to-local\nFED ------------------------\u2192 LOCAL\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-limit-diagram-for-verifiable-id","title":"The Limit Diagram for Verifiable ID","text":"<pre><code>                  \u250c\u2500\u2500\u2500 SAM.gov record\n                  \u2502\n                  \u2502    \u03c0_sam\n                  \u2193\n    LEI record \u2500\u2500\u2500\u2192 Entity (Verifiable ID) \u2190\u2500\u2500\u2500 County record\n                  \u2191\n                  \u2502    \u03c0_state  \n                  \u2502\n                  \u2514\u2500\u2500\u2500 State CF record\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-amendment-chain","title":"The Amendment Chain","text":"<pre><code>E\u2081 \u2500\u2500amend\u2500\u2500\u2192 E\u2082 \u2500\u2500amend\u2500\u2500\u2192 E\u2083 \u2500\u2500amend\u2500\u2500\u2192 E\u2084\n\u2502              \u2502              \u2502              \u2502\n\u2502 hash         \u2502 hash         \u2502 hash         \u2502\n\u2193              \u2193              \u2193              \u2193\nH\u2081 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2082 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2083 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2084\n     (H\u2081 in        (H\u2082 in        (H\u2083 in\n      E\u2082)           E\u2083)           E\u2084)\n</code></pre> <p>This completes the categorical foundation for CEP. The schemas implement these abstract structures concretely, and the test vectors verify that implementations preserve the categorical properties.</p>"},{"location":"en/concepts/interoperability/","title":"Interoperability","text":"<p>CEP is designed to integrate with: </p> <ul> <li>Popolo - the entity + political relationships backbone of nearly every open civics project worldwide (OCD, OpenStates, etc.) includes models for Person, Organization, Membership,  Post / Role, Area, Event, Motion / Vote, Legislative Activity and works for elected officials, models boards, committees, councils, includes membership graph.</li> <li>Open Civic Data</li> <li>Open Contracting Data Standard (OCDS) - international standard for public procurement, contracts, tenders, awards, suppliers, implementation and milestone tracking.</li> <li>Schema.org - includes Organization, Person, Place, GovernmentOrganization, Grant, MonetaryGrant,  Legislation, VoteAction and enables interoperability with Google datasets, machine readability.</li> <li>Financial Taxonomies (XBRL) - good for financial reporting, auditing, interoperability with Treasury and state finance systems</li> <li>W3C PROV - good for academics and auditors, PROV guides revision chains, attestation blocks, canonical timestamps, and hash-based integrity. CEP attestation maps to PROV wasGeneratedBy, wasAttributedTo, wasDerivedFrom and CEP previousRecordHash maps to PROV wasRevisionOf.</li> <li>Open Referral Human Services Data Specification (HSDS) - has Organization, Location, Service, Funding - enables connecting public funding to outcomes</li> <li>Financial Industry Business Ontology (FIBO) - map to loan-agreement, grant-award (loosely), subsidiary.</li> </ul>"},{"location":"en/concepts/interoperability/#cep-concept-mapping-table","title":"CEP Concept Mapping Table","text":"CEP Concept CEP Term / Field CEP Vocabulary / Schema External Standard External Concept / Class / Field Mapping Type Notes Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Popolo <code>Organization</code> exactMatch Government bodies (legislatures, councils, agencies). Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> OCD <code>ocd-jurisdiction</code> exactMatch Use in <code>identifiers.additionalSchemes</code> with OCD jurisdiction IDs. Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Schema.org <code>GovernmentOrganization</code> exactMatch For web/SEO and generic data consumers. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> OCD <code>ocd-division</code> + <code>ocd-jurisdiction</code> (school districts) broadMatch Division/jurisdiction pair identifies school districts. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> Schema.org <code>EducationalOrganization</code> / <code>SchoolDistrict</code> (where available) exactMatch For education analytics and public-facing data. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Popolo <code>Organization</code> with classification <code>nonprofit</code> broadMatch Nonprofits providing services, fiscal sponsors, etc. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Schema.org <code>NGO</code> / <code>Organization</code> relatedMatch Web-compatible representation of nonprofits. Entity (organization) <code>entityTypeUri = #vendor</code> <code>entity-type.json</code> OCDS <code>Party</code> with role <code>supplier</code> exactMatch Contractors / vendors in procurement. Entity (natural person) <code>entityTypeUri = #natural-person</code> <code>entity-type.json</code> Popolo <code>Person</code> exactMatch Politicians, officials, natural-person donors, etc. Entity (natural person) <code>entityTypeUri = #elected-official</code> <code>entity-type.json</code> Popolo <code>Person</code> + <code>Membership</code> in <code>Organization</code> exactMatch Derived from Popolo membership in a legislature / council. Entity (natural person) <code>entityTypeUri = #natural-person</code> / <code>#elected-official</code> <code>entity-type.json</code> Schema.org <code>Person</code> exactMatch Generic consumer-friendly alignment. Entity (division) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division/...</code> exactMatch Political geography for school districts, counties, states, etc. Entity (jurisdiction) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-jurisdiction/...</code> exactMatch Governing bodies over divisions. Entity (organization) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-organization/...</code> exactMatch Committees, councils, agencies, boards. Entity (person) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-person/...</code> exactMatch People in OCD-compatible civic graphs. Entity (financial) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI ISO 17442 Legal Entity Identifier exactMatch Global financial identity for entities in financial transactions. Entity (federal) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov Unique Entity Identifier exactMatch U.S. federal financial identity for entities. Entity (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) Hash-based Sub-National Federated Entity Identifier newConcept Bridges UEI/LEI to local civic entities; open-source identifier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> exactMatch Prime contract between government and supplier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> USAspending <code>contract</code> (glossary) exactMatch Alignment with USASpending contract awards. Relationship (subcontract) <code>relationshipTypeUri = #subcontract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> linked via <code>relatedProcesses</code> broadMatch Subcontracts under a prime contract. Relationship (grant) <code>relationshipTypeUri = #grant-award</code> <code>relationship-type.json</code> USAspending <code>grant</code> (glossary) exactMatch Federal grants / assistance awards. Relationship (subgrant) <code>relationshipTypeUri = #subgrant</code> <code>relationship-type.json</code> OCDS <code>Award</code> + <code>Implementation.transactions</code> for subawards broadMatch Pass-through grants from state to local entities. Relationship (coop agrmt) <code>relationshipTypeUri = #cooperative-agreement</code> <code>relationship-type.json</code> USAspending <code>cooperative agreement</code> exactMatch Cooperative federal assistance relationships. Relationship (interagency) <code>relationshipTypeUri = #interagency-agreement</code> <code>relationship-type.json</code> OCDS <code>Contract</code> or <code>Agreement</code> between government parties relatedMatch Transfer agreements between agencies. Relationship (MOU) <code>relationshipTypeUri = #memorandum-of-understanding</code> <code>relationship-type.json</code> Popolo <code>Membership</code> / <code>Organization</code> with informal cooperation relatedMatch Non-binding but structured relationships. Relationship (fiscal spon) <code>relationshipTypeUri = #fiscal-sponsorship</code> <code>relationship-type.json</code> HSDS <code>Funding</code> / <code>Service</code> provider/host relationship relatedMatch Connects projects to 501(c)(3) entities. Relationship (board) <code>relationshipTypeUri = #board-membership</code> <code>relationship-type.json</code> Popolo <code>Membership</code> (person \u2194 organization, role = board member) exactMatch Governance relationships. Relationship (employment) <code>relationshipTypeUri = #employment</code> <code>relationship-type.json</code> Popolo <code>Membership</code> or <code>Post</code> with classification <code>employment</code> exactMatch Staff roles in agencies, schools, vendors. Relationship (consulting) <code>relationshipTypeUri = #consulting-engagement</code> <code>relationship-type.json</code> Popolo <code>Membership</code> with classification <code>consultant</code> relatedMatch Non-employee professional services. Relationship (subsidiary) <code>relationshipTypeUri = #subsidiary</code> <code>relationship-type.json</code> Schema.org <code>subOrganization</code> relatedMatch Corporate ownership within civic vendor trees. Relationship (joint ven.) <code>relationshipTypeUri = #joint-venture</code> <code>relationship-type.json</code> FIBO Joint venture relationship relatedMatch Optional mapping for advanced financial/corporate semantics. Relationship (reg. reg.) <code>relationshipTypeUri = #regulatory-registration</code> <code>relationship-type.json</code> Schema.org <code>GovernmentOrganization</code> + <code>registration</code>-related properties relatedMatch Entities registered with regulatory bodies. Relationship (loan) <code>relationshipTypeUri = #loan-agreement</code> <code>relationship-type.json</code> FIBO Loan contract exactMatch For loans, bond-like instruments, and revolving credit. Relationship (bill-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Bill</code> object relatedMatch Relationship authorized or shaped by a bill. Relationship (vote-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Vote</code> object relatedMatch Relationship activated/approved by a vote. Relationship (event-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Event</code> object relatedMatch Relationship linked to hearings, meetings, signings. Exchange (grant) <code>exchangeTypeUri = #grant-disbursement</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type grant disbursement exactMatch Payment of grant funds under a grant-award relationship. Exchange (contract fee) <code>exchangeTypeUri = #contract-fee-payment</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type payment exactMatch Invoice payments under contracts. Exchange (subaward) <code>exchangeTypeUri = #subgrant-disbursement</code> <code>exchange-type.json</code> USAspending Subaward transactions exactMatch Pass-through disbursements to subrecipients. Exchange (donation) <code>exchangeTypeUri = #campaign-contribution</code> <code>exchange-type.json</code> Popolo / DIME Contribution records mapped to <code>Person</code> / <code>Organization</code> donors/recipients relatedMatch Campaign finance contributions tied into CEP graph. Exchange (in-kind) <code>value.valueTypeUri = #in-kind</code> <code>value-type.json</code> Schema.org <code>Offer</code> / <code>Grant</code> with non-monetary value relatedMatch Non-monetary goods/services tracked in CEP. Exchange (service-hours) <code>value.valueTypeUri = #service-hours</code> <code>value-type.json</code> HSDS <code>Service</code> + time-based contributions relatedMatch Volunteer or staff time as value. Exchange (categorization) <code>categorization.naicsCode</code> <code>cep.exchange.schema.json</code> NAICS NAICS industry codes exactMatch Standard economic activity classification for exchanges. Exchange (categorization) <code>categorization.cfdaNumber</code> <code>cep.exchange.schema.json</code> CFDA / Assistance CFDA / Assistance Listing number exactMatch Links exchanges to federal assistance programs. Exchange (categorization) <code>categorization.gtasAccountCode</code> <code>cep.exchange.schema.json</code> GTAS Treasury Account Symbol exactMatch Aligns exchanges to Treasury reporting accounts. Exchange (source) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCDS <code>Release</code>, <code>Award</code>, <code>Contract</code>, <code>Implementation.transactions</code> relatedMatch Exchange derived from procurement data. Exchange (bill/vote) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCD <code>Bill</code>, <code>Vote</code>, <code>Event</code> relatedMatch Funding events tied to legislative activity. Value (monetary) <code>value.valueTypeUri = #monetary</code> <code>value-type.json</code> XBRL Monetary item types (e.g., <code>monetaryItemType</code>) exactMatch Monetary amounts aligned with financial reporting taxonomies. Value (monetary) <code>value.amount</code>, <code>value.currencyCode</code> <code>cep.exchange.schema.json</code> XBRL <code>xbrli:monetaryItemType</code>, ISO 4217 exactMatch Strictly typed monetary values. Value (provisioning) <code>valueTypeUri = #service-hours</code> / <code>#in-kind</code> <code>value-type.json</code> HSDS <code>Service</code> value dimensions relatedMatch For human services and community programs. Provenance (entity) <code>attestation</code> block on Entity <code>cep.entity.schema.json</code> W3C PROV <code>prov:Entity</code>, <code>prov:wasGeneratedBy</code>, <code>prov:wasAttributedTo</code> exactMatch Entity record as a PROV entity with associated agent/activity. Provenance (relationship) <code>attestation</code> block on Relationship <code>cep.relationship.schema.json</code> W3C PROV Same as above exactMatch Relationship record provenance in PROV terms. Provenance (exchange) <code>attestation</code> block on Exchange <code>cep.exchange.schema.json</code> W3C PROV Same as above exactMatch Exchange record provenance. Provenance (revision) <code>previousRecordHash</code>, <code>revisionNumber</code> all CEP core schemas W3C PROV <code>prov:wasRevisionOf</code>, <code>prov:qualifiedRevision</code> exactMatch Immutable revision chains expressed via hashes and monotone revisions. Provenance (hash) Canonical string + SHA-256 hash (SSOT) implementation / spec W3C PROV <code>prov:generatedAtTime</code>, <code>prov:wasDerivedFrom</code> relatedMatch Hash as integrity proof supporting PROV-compatible derivation chains. IDs (UEI) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov UEI exactMatch Federal identity. IDs (LEI) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI LEI exactMatch Global financial identity. IDs (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) SNFEI newConcept Open, recomputable sub-federal ID bridging UEI/LEI and local civic entities. IDs (OCD) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division</code>, <code>ocd-jurisdiction</code>, <code>ocd-organization</code>, <code>ocd-person</code> exactMatch Primary bridge to the Open Civic Data topology. IDs (OCDS) <code>identifiers.additionalSchemes</code> on Entity/Relationship <code>cep.entity/relationship</code> OCDS <code>Parties</code>, <code>Award.id</code>, <code>Contract.id</code> relatedMatch Tie CEP entities/relationships back to OCDS releases. IDs (Popolo) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> Popolo <code>Person.id</code>, <code>Organization.id</code> relatedMatch Where Popolo IDs exist separately from OCD IDs."},{"location":"en/concepts/interoperability/#cep-concept-mapping-table-by-schema","title":"CEP Concept Mapping Table (by Schema)","text":"CEP Concept / Field External Standard External Concept / ID / Class Mapping Type Suggested <code>externalUri</code> / <code>schemeUri</code> example Notes Entity (general civic entity) Popolo <code>Person</code>, <code>Organization</code> broadMatch <code>http://www.popoloproject.com/specs/person.html</code>, <code>http://www.popoloproject.com/specs/organization.html</code> CEP <code>entity</code> covers both persons and orgs; Popolo separates. <code>entityTypeUri</code> <code>#natural-person</code> Popolo <code>Person</code> exactMatch <code>http://www.popoloproject.com/specs/person.html</code> For individuals (candidates, officials, donors). <code>entityTypeUri</code> <code>#organization</code> Popolo <code>Organization</code> exactMatch <code>http://www.popoloproject.com/specs/organization.html</code> Base org type, parent of more specific government / nonprofit types. <code>entityTypeUri</code> <code>#government-jurisdiction</code> Popolo/OCD Popolo <code>Organization</code> + OCD <code>jurisdiction</code> relatedMatch <code>https://opencivicdata.org/id/jurisdiction</code> A governing body; mix of org and jurisdiction. <code>identifiers.additionalSchemes</code> (division) OCD <code>ocd-division/*</code> exactMatch <code>https://opencivicdata.org/id/division</code> Store OCD division IDs as <code>schemeUri = \"https://opencivicdata.org/id/division\"</code>. <code>identifiers.additionalSchemes</code> (jurisdiction) OCD <code>ocd-jurisdiction/*</code> exactMatch <code>https://opencivicdata.org/id/jurisdiction</code> Store OCD jurisdiction IDs. <code>identifiers.additionalSchemes</code> (person) OCD / Popolo <code>ocd-person/*</code> (Popolo person) exactMatch <code>https://opencivicdata.org/id/person</code> Link CEP entity to OCD/Popolo person IDs. <code>identifiers.additionalSchemes</code> (organization) OCD / Popolo <code>ocd-organization/*</code> exactMatch <code>https://opencivicdata.org/id/organization</code> Link CEP entity to OCD/Popolo org IDs. <code>identifiers.lei</code> leif / LEI <code>LEI</code> (ISO 17442 Legal Entity Identifier) exactMatch <code>https://www.gleif.org/en/about-lei/introducing-the-legal-entity-identifier-lei</code> Already in schema; key for global finance interoperability. <code>identifiers.samUei</code> US Federal UEI (SAM.gov Unique Entity Identifier) exactMatch <code>https://www.sam.gov/</code> Tier 2 identity in our stack. <code>identifiers.additionalSchemes</code> (OCDS party) OCDS <code>parties.identifier.id</code> relatedMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Use for suppliers / buyers in procurement records. <code>entityTypeUri</code> <code>#supplier</code> / <code>#contractor</code> OCDS <code>Organization</code> with role <code>supplier</code> / <code>tenderer</code> exactMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Straight mapping for vendors. <code>entityTypeUri</code> <code>#school-district</code> Schema.org <code>SchoolDistrict</code> (subtype of <code>EducationalOrganization</code>) relatedMatch <code>https://schema.org/SchoolDistrict</code> For education equity analytics. <code>entityTypeUri</code> <code>#government-agency</code> Schema.org <code>GovernmentOrganization</code> exactMatch <code>https://schema.org/GovernmentOrganization</code> For agencies at any level. Relationship (legal / functional relationships) Popolo <code>Membership</code>, <code>Post</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> CEP Relationship is more general; includes contracts, grants, etc. <code>relationshipTypeUri</code> <code>#board-membership</code> Popolo <code>Membership</code> exactMatch <code>http://www.popoloproject.com/specs/membership.html</code> Board membership of a person in an org. <code>relationshipTypeUri</code> <code>#employment</code> Popolo <code>Membership</code> (with <code>post</code> / <code>role</code>) broadMatch <code>http://www.popoloproject.com/specs/membership.html</code> Employment is a constrained membership. <code>relationshipTypeUri</code> <code>#consulting-engagement</code> Popolo <code>Membership</code> or <code>ContactDetail</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> Less formal, non-employee service relationship. <code>relationshipTypeUri</code> <code>#prime-contract</code> OCDS <code>Contract</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> CEP Relationship for a prime contract matches OCDS Contract. <code>relationshipTypeUri</code> <code>#subcontract</code> OCDS <code>Contract</code> with <code>relatedProcesses</code> / <code>relatedLots</code> narrowMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> Subcontracts are contracts linked to a parent award. <code>relationshipTypeUri</code> <code>#grant-award</code> OCDS <code>Award</code> relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#award</code> OCDS is procurement-focused; grants are adjacent. <code>relationshipTypeUri</code> <code>#cooperative-agreement</code> OCDS <code>Award</code> or <code>Contract</code> (context-specific) relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/</code> Map conceptually to awarded agreements. <code>relationshipTypeUri</code> <code>#loan-agreement</code> FIBO <code>LoanAgreement</code> exactMatch <code>https://spec.edmcouncil.org/fibo/ontology/FBC/DebtAndEquities/Debt/LoanAgreement</code> Optional FIBO mapping; useful for financial instruments. <code>relationshipTypeUri</code> <code>#subsidiary</code> Schema.org <code>subOrganization</code> relatedMatch <code>https://schema.org/subOrganization</code> See vocab.mappings. <code>relationshipTypeUri</code> <code>#joint-venture</code> Schema.org <code>Organization</code> with <code>memberOf</code> relatedMatch <code>https://schema.org/Organization</code> Joint ventures as special multi-party orgs. <code>relationshipTypeUri</code> <code>#regulatory-registration</code> Schema.org <code>GovernmentOrganization</code> / <code>Service</code> relatedMatch <code>https://schema.org/GovernmentOrganization</code> Registration with a regulator. <code>relationshipTypeUri</code> <code>#fiscal-sponsorship</code> HSDS / Nonprofit HSDS <code>Funding</code> or <code>Service</code> relatedMatch <code>https://github.com/openreferral/specification</code> For nonprofit fiscal sponsor relationships. Exchange (value transfer events) OCDS <code>Implementation.transactions[]</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#implementation</code> CEP Exchange is very close to OCDS transaction-level data. <code>exchangeTypeUri</code> <code>#grant-disbursement</code> Schema.org <code>MonetaryGrant</code> exactMatch <code>https://schema.org/MonetaryGrant</code> Core pattern for education &amp; campaign finance. <code>exchangeTypeUri</code> <code>#contract-fee-payment</code> Schema.org <code>Payment</code> / <code>Invoice</code> relatedMatch <code>https://schema.org/Invoice</code> Payment for contracted services. <code>exchangeTypeUri</code> <code>#donation</code> (if defined) Schema.org <code>DonateAction</code> relatedMatch <code>https://schema.org/DonateAction</code> Campaign or charitable donations. <code>exchangeTypeUri</code> <code>#loan-disbursement</code> FIBO <code>LoanPrincipalPayment</code> relatedMatch FIBO debt concepts More detailed financial modeling if needed. Value &amp; Categorization XBRL GAAP / GRT financial elements exactMatch e.g. <code>http://xbrl.us/us-gaap/2024-01-31#RevenueRecognition</code> Map CEP <code>categorization</code> fields to XBRL when possible. <code>value.currencyCode</code> ISO 4217 Currency codes exactMatch <code>https://www.iso.org/iso-4217-currency-codes.html</code> Already enforced by regex. <code>categorization.naicsCode</code> NAICS NAICS activity code exactMatch <code>https://www.census.gov/naics/</code> Already included in schema. <code>categorization.cfdaNumber</code> Assistance List CFDA / Assistance Listing number exactMatch <code>https://sam.gov/content/assistance-listing</code> For federal assistance programs. <code>categorization.gtasAccountCode</code> US GTAS Treasury Account Symbol (TAS) exactMatch <code>https://fiscal.treasury.gov/gtas/</code> Connects to federal reporting. Provenance &amp; Attestation W3C PROV <code>Entity</code>, <code>Activity</code>, <code>Agent</code>, <code>wasGeneratedBy</code>, <code>wasAttributedTo</code>, etc. relatedMatch <code>https://www.w3.org/TR/prov-o/</code> CEP is PROV-aligned but more specialized. <code>attestation.attestorId</code> W3C PROV <code>Agent</code> / <code>prov:wasAttributedTo</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasAttributedTo</code> The attesting node is the Agent. <code>attestation.attestationTimestamp</code> W3C PROV <code>generatedAtTime</code> exactMatch <code>https://www.w3.org/TR/prov-o/#generatedAtTime</code> When the record (Entity) was generated. <code>previousRecordHash</code> W3C PROV <code>wasRevisionOf</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasRevisionOf</code> Revision chain between CEP records. <code>provenanceChain.fundingChainTag</code> W3C PROV <code>wasDerivedFrom</code> chain relatedMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Human-readable representation of a PROV derivation path. <code>provenanceChain.parentExchangeId</code> W3C PROV <code>wasDerivedFrom</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Parent exchange is the immediate predecessor in the flow. Events, Bills, Votes OCD / Popolo <code>Bill</code>, <code>VoteEvent</code>, <code>Event</code> relatedMatch <code>https://opencivicdata.org/specs/</code> Linked via <code>sourceReferences</code>. <code>sourceReferences</code> (bill) OCD <code>ocd-bill/*</code> exactMatch <code>https://opencivicdata.org/id/bill</code> For authorizing legislation. <code>sourceReferences</code> (vote) OCD / Popolo <code>ocd-vote/*</code> or Popolo <code>VoteEvent</code> exactMatch <code>https://opencivicdata.org/id/vote</code> For authorization votes. <code>sourceReferences</code> (event) OCD / Popolo <code>Event</code> exactMatch <code>https://opencivicdata.org/id/event</code> Meetings, hearings tied to relationships or exchanges. Human Services / Programs (optional) HSDS <code>Service</code>, <code>Organization</code>, <code>Funding</code> relatedMatch <code>https://github.com/openreferral/specification</code> For social services and community programs. <code>entityTypeUri</code> <code>#service-provider</code> HSDS <code>Organization</code> exactMatch <code>https://github.com/openreferral/specification</code> For agencies and nonprofits providing services. <code>relationshipTypeUri</code> <code>#service-delivery-agreement</code> (future) HSDS <code>Service</code> / <code>Funding</code> relatedMatch HSDS docs If added."},{"location":"en/concepts/interoperability/#vocabulary-notes","title":"Vocabulary Notes","text":"<p>prime-contract</p> <ul> <li>USAspending contract is a close conceptual match.</li> <li>OCDS contract is the canonical public procurement concept, so exactMatch.</li> </ul> <p>subcontract</p> <ul> <li>OCDS does not have a first-class subcontract object, but it is conceptually a specialized contract under a main award, so narrowMatch.</li> </ul> <p>grant-award</p> <ul> <li>USAspending grant is a direct match to federal grants.</li> <li>OCDS award is broader (covers procurements and grants), so relatedMatch.</li> <li>Schema.org MonetaryGrant is almost exactly, so exactMatch.</li> </ul> <p>loan-agreement</p> <ul> <li>FIBO Contracts and Loans ontologies give similar semantic neighborhood but more general, so relatedMatch.</li> </ul> <p>subsidiary</p> <ul> <li>Schema.org subOrganization is close but not strictly legal-definition match, so relatedMatch.</li> <li>FIBO Subsidiary is semantically close but in financial-industry framing; so relatedMatch.</li> </ul> <p>board-membership and employment</p> <ul> <li>Both are specializations of Popolo Membership (person\u2013organization relationship with roles and time-bounds), so narrowMatch.</li> </ul>"},{"location":"en/concepts/related-domains/","title":"Related Research Domains","text":"<p>This standard operates at the intersection of three major, yet often separate, academic research domains:  - Formal Entity Resolution (CS),  - Campaign Finance/Policy Analysis (Political Science), and - Global Data Standards (Information Systems).</p>"},{"location":"en/concepts/related-domains/#prior-work-entity-resolution-data-standards-and-civic-transparency","title":"Prior Work: Entity Resolution, Data Standards, and Civic Transparency","text":"<p>This standard advances the state-of-the-art by bridging the gap between three distinct bodies of work: high-fidelity entity resolution, policy-driven data harmonization, and the development of open standards for public accountability.</p>"},{"location":"en/concepts/related-domains/#1-entity-resolution-and-data-quality-methodology","title":"1. Entity Resolution and Data Quality Methodology","text":"<p>Research in Entity Resolution (ER), also known as record linkage or deduplication, has been a cornerstone of computer science and database theory.</p> <p>Carnegie Mellon University (CMU) has contributed foundational work in formalizing the ER problem, such as the ENRES framework, which provides a semantic model to represent and relate various ER research models. This work highlights the crucial need for formal reasoning and explicit assumptions regarding entities and their references, which directly informs our Category Theory approach. Other CMU-related research has addressed Generic Entity Resolution with Data Confidences, underscoring the necessity of associating numerical confidence with merged records, a feature we implement via the Splink-generated confidence_score.</p> <p>The computational methodology behind our implementation relies heavily on advancements in probabilistic record linkage, particularly the Fellegi-Sunter model, which allows for high-accuracy linking of data without labeled training sets, critical for messy public data. The use of the open-source Splink library (pioneered outside academia and rigorously validated) represents a pragmatic, scalable implementation of these probabilistic principles.</p>"},{"location":"en/concepts/related-domains/#2-campaign-finance-and-policy-data-standardization","title":"2. Campaign Finance and Policy Data Standardization","text":"<p>A parallel track of research has focused on the application of computational methods to clean and analyze fragmented political data.</p> <p>Stanford University's DIME (Database on Ideology, Money in Politics, and Elections) Project exemplifies the effort to centralize and standardize complex political contributions data. DIME has assigned unique identifiers for millions of individual and organizational donors, candidates, and political committees across federal and state elections. This established the value proposition for a persistent, standardized identifier in the campaign finance domain.</p> <p>The University of Chicago MS in Computational Analysis and Public Policy (MSCAPP) and Stanford's Computational Public Policy programs have emphasized the necessary skills, including machine learning, big data, and computational analysis required to address policy issues like public procurement and campaign finance. These programs underscore the academic recognition that robust data infrastructure is the prerequisite for rigorous policy analysis.</p> <p>While these efforts successfully resolve entities within their domain (e.g., within campaign finance), they often use internal, proprietary identifiers that do not readily link to entities in the public procurement or grant domains, creating siloed transparency.</p>"},{"location":"en/concepts/related-domains/#3-open-data-interoperability-and-global-standards","title":"3. Open Data, Interoperability, and Global Standards","text":"<p>The third body of work defines the principles of modern data governance and standardization.</p> <p>Massachusetts Institute of Technology (MIT), through its Research Data Principles, champions the need for researchers to manage data actively and avoid acquiring or generating data that restricts future use and sharing. This principle of \"open by default\" and \"designed for reuse\" informs the design of the our open-source standard and its reliance on the non-proprietary SNFEI.</p> <p>Organizations supporting the Open Data Charter emphasize that data must be comparable and interoperable to enhance governance and accountability. This reflects the global demand for cross-sectoral standards. The existing Legal Entity Identifier (LEI) standard provides the template for a globally harmonized system in the financial sector.</p>"},{"location":"en/concepts/related-domains/#novelty-and-contribution-of-this-standard","title":"Novelty and Contribution of this Standard","text":"<p>This project is novel in three key ways:</p> <ul> <li> <p>Compositional Rigor: We model the civic exchange system as a Category, using Category Theory to formally prove that the SNFEI acts as the Universal Property (Limit) that unifies all messy civic records, helping to guarantee the standard's structural integrity and extensibility.</p> </li> <li> <p>Tiered, Extensible Identity: We address sub-federal identities by explicitly creating the SNFEI (Tier 3) as an open-source bridge to the global LEI (Tier 1) and federal UEI (Tier 2).</p> </li> <li> <p>The Provenance Tag: We enforce a Compositional Provenance Tag that structurally records the Morphism Type (GRANT, CONTRACT_FEE) and the entity hierarchy, enabling automated tracing of the entire funding chain, which goes beyond simple entity deduplication.</p> </li> </ul>"},{"location":"en/governance/evolution-policy-and-versioning/","title":"Standard Evolution Policy and Versioning","text":"<p>This policy defines the process, requirements, and responsibilities for introducing changes to the Protocol.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#1-versioning-system","title":"1. Versioning System","text":"<p>The standard utilizes Semantic Versioning (MAJOR.MINOR.PATCH). The version number applies to the entire monorepo and its core protocol requirements.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#11-major-version-change-x00","title":"1.1 MAJOR Version Change (X.0.0)","text":"<p>A MAJOR change is reserved for non-backwards-compatible modifications that require all certified nodes to update their serialization logic, otherwise, they will lose hash parity.</p> Change Type Impact Example Data Type Change Changing a field type (e.g., transactionAmount from number to string). Field Order Change Modifying the CANONICAL_FIELD_ORDER. Cryptographic Change Switching from SHA-256 to a new algorithm (e.g., SHA-384). Mandatory Field Addition Adding a new field to the required list in the JSON Schema. <p>Requirement: Requires unanimous approval from the Interconnect Standards Board (ISB) and a mandatory 6-month deprecation period.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#12-minor-version-change-0x0","title":"1.2 MINOR Version Change (0.X.0)","text":"<p>A MINOR change is a backwards-compatible modification that adds new functionality or optional fields. Existing certified nodes maintain hash parity, but new nodes may need to account for new optional data.</p> Change Type Impact Example Optional Field Addition Adding a new field to the end of the CANONICAL_FIELD_ORDER (which is omitted if null). Adding funding_source_project_id (optional). Enum Value Addition Adding a new value to an existing enum (e.g., adding TEMPORARILY_SUSPENDED to transactionStatus). Tooling Upgrade Significant upgrade to the build system (build.sh or testing dependencies). <p>Requirement: Requires simple majority approval from the ISB (2 out of 3 votes).</p>"},{"location":"en/governance/evolution-policy-and-versioning/#13-patch-version-change-00x","title":"1.3 PATCH Version Change (0.0.X)","text":"<p>A PATCH change is a small, fully backwards-compatible correction to documentation, tooling, or non-protocol code.</p> Change Type Impact Example Documentation Fix Correcting a typo in the Governance Charter. Test Data Update Adding a new test vector to /test_data that uses only existing fields. Non-Core Bug Fix Fixing a non-critical bug in a reference implementation's example code. <p>Requirement: Can be approved by the ISB Chair alone.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#2-change-submission-and-review-cycle","title":"2. Change Submission and Review Cycle","text":"<ol> <li> <p>Proposal Submission: The contributor submits a Pull Request (PR) against the main branch.</p> </li> <li> <p>Versioning Assignment: The ISB Chair assigns the PR a tentative version bump (MAJOR, MINOR, or PATCH) based on Section 1.</p> </li> <li> <p>ISB Review and Vote: The ISB reviews the proposal (focusing on need and impact) and votes according to the requirement for the assigned version type.</p> </li> <li> <p>Hash Parity Enforcement: Once the vote passes, the PR is merged, and the automated CI system executes the build.sh script to confirm 100% hash parity across all five certified languages (Python, Rust, Java, C#, TypeScript). No release can occur until 100% parity is confirmed.</p> </li> <li> <p>Release: The new version is tagged, and all certified node operators are notified.</p> </li> </ol>"},{"location":"en/governance/objectives-and-vision/","title":"Objectives and Vision","text":"<p>The Civic Exchange Protocol (CEP) is designed to support incremental integration today and strategic planning without requiring architectural changes. The core philosophy is simple:</p> <ul> <li>Optimize for low-cost, low-friction adoption.</li> <li>Provide cryptographic integrity without requiring blockchain.</li> <li>Support regulatory harmonization across jurisdictions.</li> <li>Preserve openness, interoperability, and vendor neutrality.</li> </ul> <p>At its core, CEP ensures that the same payload always yields the same canonical hash, providing a universal identity and attestation mechanism that can span civic, financial, and administrative systems.</p>"},{"location":"en/governance/objectives-and-vision/#1-objectives","title":"1. Objectives","text":""},{"location":"en/governance/objectives-and-vision/#11-lower-the-cost-of-adoption","title":"1.1 Lower the Cost of Adoption","text":"<p>Most public-sector technology initiatives fail due to the cost and complexity of onboarding. CEP minimizes this by:</p> <ul> <li>Requiring only JSON + SHA-256 + a canonical string rule.</li> <li>Avoiding specialized infrastructure (no distributed ledger, no proprietary middleware).</li> <li>Allowing any language, platform, or agency to participate.</li> <li>Transparency by default: schemas and vocabularies are openly published.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#12-decentralized-provenance-without-blockchain","title":"1.2 Decentralized Provenance Without Blockchain","text":"<p>Unlike blockchain-based solutions, CEP:</p> <ul> <li>Requires no consensus algorithm.</li> <li>Does not impose token economics or distributed nodes.</li> <li>Uses a cryptographically linked attestation chain (previousRecordHash), providing tamper evidence at a fraction of the cost.</li> </ul> <p>This provides a cryptographic audit trail suitable for public-sector systems where full decentralization is either unnecessary or impractical.</p>"},{"location":"en/governance/objectives-and-vision/#13-cost-effective-regulatory-compliance","title":"1.3 Cost-Effective Regulatory Compliance","text":"<p>CEP is designed to satisfy emerging demands in:</p> <ul> <li>Transparency and anti-corruption policy  </li> <li>Cross-jurisdiction financial tracking  </li> <li>Federal reporting (XBRL, GTAS)  </li> <li>Global financial identity standards (UEI, LEI)</li> </ul> <p>By structuring the data model around canonical identifiers, provenance, and hash-bound attestations, CEP can adapt naturally to future regulatory frameworks and programmatic audit requirements.</p>"},{"location":"en/governance/objectives-and-vision/#2-vision","title":"2. Vision","text":"<p>The Civic Exchange Protocol is deliberately designed so that incremental adoption today will not conflict with expected future requirements.</p> <p>Possible evolution includes:</p> <ul> <li>National or state-level directives requiring provenance tagging for grant, contract, or procurement systems.</li> <li>Standardization bodies adopting CEP as a formal schema for intergovernmental reporting.</li> <li>Regulatory requirements for immutable audit trails for public money flows.</li> <li>International harmonization with LEI, XBRL, HSDS, PROV, Popolo, or other standards.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#3-voluntary-integration-vs-possible-future-requirements-matrix","title":"3. Voluntary Integration vs. Possible Future Requirements Matrix","text":"<p>This matrix outlines the anticipated pathway from voluntary use to potential regulatory mandate. The protocol is built to operate seamlessly in both contexts.</p> Aspect Current Voluntary Integration Possible Future Requirements Authority Interconnect Standards Board (ISB) governs versions, vocabularies, and hash rules. Department of Governance and Exchange (DOGE) as regulatory authority for compliance and enforcement. Access Policy Peer-to-peer agreements between participating entities. Standardized Digital Roles and Permissions (SDRP), federally or globally recognized. Public Data Best practice for transparency. Agencies may decide which data to publish. Mandatory global disclosures for specific categories (e.g., grants, contracts, campaign finance). Integrity Proof Entity Hash and canonical string provide voluntary integrity guarantee. Same Entity Hash meets any required SSOT-proof for compliance and audits. <p>CEP ensures that the same proof mechanism works in both cases, with no need for new cryptographic infrastructure should mandated requirements arrive.</p>"},{"location":"en/governance/objectives-and-vision/#4-future-proof-architecture","title":"4. Future-Proof Architecture","text":"<p>CEP is explicitly designed to:</p> <ul> <li>Scale from a few adopters to wider integration.</li> <li>Allow community-driven vocabulary evolution.</li> <li>Support new jurisdictions, formats, and regulatory requirements without schema breakage.</li> <li>Provide a secure, verifiable, and interoperable foundation for multi-sector data exchange.</li> </ul> <p>The vision is an interoperable civic identity and provenance network, offering incremental integration and compatibility with existing systems.</p>"},{"location":"en/governance/vocabulary-process/","title":"Vocabulary Governance Process","text":"<p>This document defines how controlled vocabularies in the Civic Exchange Protocol (CEP) are created, reviewed, versioned, and published. CEP vocabularies include:</p> <ul> <li><code>entity-type</code></li> <li><code>relationship-type</code></li> <li><code>exchange-type</code></li> <li><code>exchange-role</code></li> <li><code>party-role</code></li> <li><code>identifier-scheme</code></li> <li><code>source-system</code></li> <li><code>resolution-method</code></li> <li><code>value-type</code></li> </ul> <p>These vocabularies provide the stable semantic backbone for CEP interoperability across government systems, academic research, and third-party implementations.</p>"},{"location":"en/governance/vocabulary-process/#1-purpose-of-vocabularies","title":"1. Purpose of Vocabularies","text":"<p>CEP vocabularies serve three critical functions:</p> <ol> <li> <p>Interoperability:    Terms map to external standards (Popolo, Open Civic Data, OCDS, HSDS, Schema.org, XBRL, W3C PROV).</p> </li> <li> <p>Semantic Stability:    Terms provide canonical meaning for entity types, role types, relationship types, exchange types, etc.</p> </li> <li> <p>Verifiable Behavior:    Terms are referenced in canonical URI form inside attested CEP records, affecting hash parity and revision integrity.</p> </li> </ol>"},{"location":"en/governance/vocabulary-process/#2-versioning","title":"2. Versioning","text":"<p>Vocabulary files follow independent semantic versioning:</p> <p><code>&lt;name&gt;.vMAJOR.MINOR.PATCH.json</code></p> <p>Examples:  </p> <pre><code>entity-type.v1.0.0.json\nidentifier-scheme.v1.0.0.json\n</code></pre>"},{"location":"en/governance/vocabulary-process/#21-major","title":"2.1 MAJOR","text":"<p>Changes that break compatibility or reinterpret existing terms: - renaming or removing terms - redefining meanings - altering term URIs - significant structural changes</p> <p>Requires unanimous ISB approval + 6-month deprecation period.</p>"},{"location":"en/governance/vocabulary-process/#22-minor","title":"2.2 MINOR","text":"<p>Backward-compatible enhancements: - adding new terms - adding new mappings - adding optional properties</p> <p>Requires simple majority vote.</p>"},{"location":"en/governance/vocabulary-process/#23-patch","title":"2.3 PATCH","text":"<p>No semantic change: - fixing typos - adding external references in <code>seeAlso</code> - clarifying descriptions</p> <p>May be approved by ISB Chair alone.</p>"},{"location":"en/governance/vocabulary-process/#3-adding-updating-or-deprecating-terms","title":"3. Adding, Updating, or Deprecating Terms","text":"<p>All vocabulary modifications follow this structured workflow:</p>"},{"location":"en/governance/vocabulary-process/#step-1-proposal-submission","title":"Step 1 \u2014 Proposal Submission","text":"<p>A contributor submits a PR that includes: - updated vocabulary file - accompanying rationale - impact assessment on interoperability - references to external standards (if relevant)</p>"},{"location":"en/governance/vocabulary-process/#step-2-technical-review","title":"Step 2 \u2014 Technical Review","text":"<p>The Interconnect Standards Board (ISB) reviews: - term clarity and definition - hierarchy (<code>parentTermUri</code>) - mappings to external standards (SKOS-style) - URI stability - potential namespace collisions - hash-parity implications</p>"},{"location":"en/governance/vocabulary-process/#step-3-vote","title":"Step 3 \u2014 Vote","text":"<p>Version bump category determines voting requirements (Section 2).</p>"},{"location":"en/governance/vocabulary-process/#step-4-merge-release","title":"Step 4 \u2014 Merge &amp; Release","text":"<p>Upon approval: - CI validates JSON format, unique URIs, and mapping integrity - The vocabulary is merged into <code>main</code> - A new tag is created:</p> <p><code>vocab/&lt;name&gt;/vMAJOR.MINOR.PATCH</code></p>"},{"location":"en/governance/vocabulary-process/#step-5-deprecation-notices","title":"Step 5 \u2014 Deprecation Notices","text":"<p>If a term becomes deprecated: - it is retained with <code>\"status\": \"deprecated\"</code> - <code>\"deprecationNote\"</code> must point to its replacement - canonical JSON schemas continue accepting it unless a MAJOR bump occurs</p>"},{"location":"en/governance/vocabulary-process/#4-design-principles-for-vocabulary-terms","title":"4. Design Principles for Vocabulary Terms","text":""},{"location":"en/governance/vocabulary-process/#41-term-uris-must-be-globally-stable","title":"4.1 Term URIs MUST be globally stable","text":"<p>URIs never change after publication.</p>"},{"location":"en/governance/vocabulary-process/#42-labels-are-human-friendly-codes-are-machine-friendly","title":"4.2 Labels are human-friendly; codes are machine-friendly","text":"<p>Examples: - code: <code>prime-contract</code> - label: <code>Prime Contract</code></p>"},{"location":"en/governance/vocabulary-process/#43-definitions-must-be-unambiguous","title":"4.3 Definitions MUST be unambiguous","text":"<p>Definitions MUST avoid jurisdiction-specific assumptions unless explicitly scoped.</p>"},{"location":"en/governance/vocabulary-process/#44-hierarchies-should-be-used-where-meaningful","title":"4.4 Hierarchies SHOULD be used where meaningful","text":"<p>Example: - <code>subgrant</code> \u2192 parent: <code>grant-award</code> - <code>subcontract</code> \u2192 parent: <code>prime-contract</code></p>"},{"location":"en/governance/vocabulary-process/#45-external-mappings-should-be-included","title":"4.5 External mappings SHOULD be included","text":"<p>Supported mapping types: <code>exactMatch</code>, <code>broadMatch</code>, <code>narrowMatch</code>, <code>relatedMatch</code>.</p>"},{"location":"en/governance/vocabulary-process/#5-file-placement-and-structure","title":"5. File Placement and Structure","text":"<p>All vocabulary files live under <code>vocabularies/</code>.</p> <p>Each file follows the canonical <code>cep.vocabulary.schema.json</code>.</p>"},{"location":"en/governance/vocabulary-process/#6-lifecycle-summary","title":"6. Lifecycle Summary","text":"Stage Description Output Proposal Contributor suggests new/updated term Pull Request Review ISB evaluates definition + mappings Comments Vote Approve/reject based on version category Decision Release Publish new vocabulary version New <code>vX.Y.Z</code> tag Deprecation Old terms marked deprecated Maintained until next MAJOR"},{"location":"en/governance/vocabulary-process/#7-guiding-objective","title":"7. Guiding Objective","text":"<p>The primary objective of CEP vocabulary governance is to stabilize meaning, maximize interoperability, and ensure backward compatibility while allowing the ecosystem to grow with new policy types, relationship structures, data standards, and domain models.</p>"},{"location":"en/implementation/implementation-guide/","title":"Implementation Guide","text":"<p>This guide provides a practical overview for developers building Civic Exchange Protocol (CEP) implementations in any language. It complements the formal schemas and the categorical foundations by describing how to validate, construct, serialize, and verify CEP records in a deterministic and interoperable way.</p>"},{"location":"en/implementation/implementation-guide/#technical-assurance","title":"Technical Assurance","text":"<p>CEP ensures technical correctness through two mandatory components:</p>"},{"location":"en/implementation/implementation-guide/#a-the-canonical-string-the-debug-tool","title":"A. The Canonical String (The Debug Tool)","text":"<p>Every implementation must expose a function (e.g., <code>getCanonicalString</code>, <code>to_canonical_string</code>, or <code>generate_canonical_string</code>) that returns the raw, unhashed, deterministic string representation of a CEP record.</p> <ul> <li>Strict field ordering  </li> <li>UTC timestamps with microsecond precision  </li> <li>Deterministic numeric formatting  </li> <li>No locale or OS artifacts  </li> </ul> <p>This is the ground truth for resolving cross-language hash mismatches.</p>"},{"location":"en/implementation/implementation-guide/#b-the-certification-test-suite-the-compliance-gate","title":"B. The Certification Test Suite (The Compliance Gate)","text":"<p>All implementations must pass the cross-language hash-parity suite in <code>/test_vectors</code>.</p> <p>Any system that computes a different SHA-256 hash for a canonical test vector is non-conforming.</p>"},{"location":"en/implementation/implementation-guide/#getting-certified","title":"Getting Certified","text":"<ol> <li>Read <code>/specifications</code>.  </li> <li>Select the implementation folder for your platform (Rust, Python, etc.).  </li> <li>Integrate <code>TransactionRecord</code> and <code>generateValidationHash</code>.  </li> <li>Run tests with <code>/test_vectors</code>.  </li> <li>Use canonical debugging strings to correct mismatch sources.  </li> </ol>"},{"location":"en/implementation/implementation-guide/#logic-organization","title":"Logic Organization","text":"Package Focus Depends On Artifacts core Shared utilities none hashing, canonicalization, timestamps, errors entity Entity records core <code>EntityRecord</code> relationship Bilateral links core, entity <code>RelationshipRecord</code> exchange Flows between entities core, entity, relationship <code>ExchangeRecord</code>"},{"location":"en/implementation/implementation-guide/#1-implementation-goals","title":"1. Implementation Goals","text":"<p>A correct CEP implementation MUST:</p> <ol> <li>Produce canonical JSON matching the schemas  </li> <li>Achieve full hash parity across languages  </li> <li>Verify attestations  </li> <li>Maintain immutable hash-linked revision chains  </li> <li>Support multi-scheme identifiers  </li> <li>Compose provenance deterministically  </li> </ol>"},{"location":"en/implementation/implementation-guide/#2-canonical-serialization","title":"2. Canonical Serialization","text":"<p>CEP uses canonical JSON for:</p> <ul> <li>hash computation  </li> <li>digital signatures  </li> <li>verification  </li> <li>cross-node equality  </li> </ul>"},{"location":"en/implementation/implementation-guide/#21-requirements","title":"2.1 Requirements","text":"<p>Canonical JSON MUST:</p> <ul> <li>Sort all object keys lexicographically  </li> <li>Use UTF-8  </li> <li>Serialize timestamps as UTC with microsecond precision and trailing <code>Z</code> </li> <li>Avoid superfluous whitespace  </li> <li>Use stable ordering inside arrays where applicable  </li> </ul> <p>Example: <code>2025-09-15T14:03:22.500000Z</code></p>"},{"location":"en/implementation/implementation-guide/#22-canonical-field-order","title":"2.2 Canonical Field Order","text":"<p>Field order is enforced via CI and cross-language tests. Any deviation produces a hash mismatch.</p>"},{"location":"en/implementation/implementation-guide/#3-record-model-and-encapsulation-philosophy","title":"3. Record Model and Encapsulation Philosophy","text":"<p>CEP defines record-shaped data, not object-oriented domain objects. The goal is interoperable, predictable, schema-driven structures that behave identically in:</p> <ul> <li>Rust  </li> <li>Python  </li> <li>TypeScript  </li> <li>Java / C#  </li> <li>SQL and NoSQL databases  </li> </ul>"},{"location":"en/implementation/implementation-guide/#31-why-cep-records-use-public-fields","title":"3.1 Why CEP Records Use Public Fields","text":"<p>CEP records are transparent because:</p> <ul> <li>Auditors must inspect them directly  </li> <li>Schemas define their shape exactly  </li> <li>Canonicalization requires predictable visibility  </li> <li>Multi-language parity demands structural simplicity  </li> <li>Hidden or computed fields would break determinism  </li> </ul> <p>Thus CEP avoids private state and getters/setters.</p>"},{"location":"en/implementation/implementation-guide/#32-where-logic-belongs-builders-and-validators","title":"3.2 Where Logic Belongs: Builders and Validators","text":"<p>CEP enforces correctness outside the record struct:</p> <ul> <li>Builders (e.g., <code>EntityBuilder</code>, <code>RelationshipBuilder</code>)  </li> <li>enforce invariants  </li> <li>normalize input  </li> <li>generate identifiers (SNFEI)  </li> <li> <p>ensure field completeness  </p> </li> <li> <p>Validators </p> </li> <li>validate schema compliance  </li> <li>enforce vocabulary correctness  </li> <li>verify signatures  </li> <li> <p>enforce revision chain rules  </p> </li> <li> <p>Canonicalization </p> </li> <li>enforces deterministic ordering  </li> <li>produces canonical strings for hashing  </li> </ul>"},{"location":"en/implementation/implementation-guide/#33-when-methods-are-appropriate","title":"3.3 When Methods Are Appropriate","text":"<p>Methods are acceptable when they:</p> <ul> <li>produce derived values (e.g., <code>canonical_string()</code>)  </li> <li>do not mutate underlying data  </li> <li>increase clarity without altering canonical shape  </li> </ul>"},{"location":"en/implementation/implementation-guide/#34-takeaway","title":"3.4 Takeaway","text":"<p>CEP records are stable public data structures. Builders and validators enforce correctness. Canonicalization enforces determinism. This ensures interoperability, auditability, and future-proof evolution.</p>"},{"location":"en/implementation/implementation-guide/#4-attestation-and-verification","title":"4. Attestation and Verification","text":""},{"location":"en/implementation/implementation-guide/#41-attestation-block","title":"4.1 Attestation Block","text":"<p>Each CEP record includes:</p> <ul> <li><code>attestorId</code> </li> <li><code>attestationTimestamp</code> </li> <li><code>proofType</code> </li> <li><code>proofValue</code> </li> <li><code>verificationMethodUri</code> </li> <li><code>proofPurpose</code> </li> <li><code>anchorUri</code> (optional)  </li> </ul>"},{"location":"en/implementation/implementation-guide/#42-verification-workflow","title":"4.2 Verification Workflow","text":"<ol> <li>Resolve public key from <code>verificationMethodUri</code> </li> <li>Recompute canonical JSON excluding attestation block  </li> <li>Verify signature using <code>proofType</code> </li> <li>Check signature matches the canonical hash  </li> </ol> <p>Failures MUST cause rejection.</p>"},{"location":"en/implementation/implementation-guide/#5-revision-and-hash-chain","title":"5. Revision and Hash Chain","text":""},{"location":"en/implementation/implementation-guide/#51-lifecycle","title":"5.1 Lifecycle","text":"<pre><code>revision 1: previousRecordHash = null\nrevision 2+: previousRecordHash = SHA256(canonical previous)\n</code></pre>"},{"location":"en/implementation/implementation-guide/#52-requirements","title":"5.2 Requirements","text":"<p>Implementations MUST:</p> <ul> <li>Enforce monotonic revision numbers  </li> <li>Reject incorrect previousRecordHash values  </li> <li>Treat any modification as a new revision  </li> </ul> <p>This forms a tamper-evident chain.</p>"},{"location":"en/implementation/implementation-guide/#6-identifier-interoperability","title":"6. Identifier Interoperability","text":"<p>CEP supports:</p> <ul> <li>UEI  </li> <li>LEI  </li> <li>SNFEI  </li> <li>Canadian BN  </li> <li>Additional scheme-based identifiers  </li> </ul>"},{"location":"en/implementation/implementation-guide/#61-best-practices","title":"6.1 Best Practices","text":"<ul> <li>Validate URIs using the identifier-scheme vocabulary  </li> <li>Validate known schemes strictly  </li> <li>Allow unknown schemes if structurally valid  </li> </ul>"},{"location":"en/implementation/implementation-guide/#7-provenance-composition","title":"7. Provenance Composition","text":"<p>Relationships and exchanges form a directed provenance graph.</p> <p>Implementations MUST:</p> <ul> <li>Validate relationship links  </li> <li>Build provenance chains deterministically  </li> <li>Support parent relationships/exchanges  </li> </ul>"},{"location":"en/implementation/implementation-guide/#71-funding-chain-convention","title":"7.1 Funding Chain Convention","text":"<p><code>FEDERAL&gt;STATE&gt;LOCAL</code></p> <p>Segments must be uppercase, separated by <code>&gt;</code>.</p>"},{"location":"en/implementation/implementation-guide/#8-vocabulary-integration","title":"8. Vocabulary Integration","text":"<p>Vocabulary URIs MUST resolve to known terms:</p> <ul> <li>relationship-type  </li> <li>exchange-type  </li> <li>party-role  </li> <li>exchange-role  </li> <li>identifier-scheme  </li> </ul> <p>Implementations SHOULD cache vocabularies locally.</p>"},{"location":"en/implementation/implementation-guide/#9-source-references","title":"9. Source References","text":"<p>Source references link CEP to external datasets.</p> <p>Implementations SHOULD:</p> <ul> <li>validate URI syntax  </li> <li>enforce nonempty IDs  </li> <li>optionally verify URL resolvability  </li> </ul>"},{"location":"en/implementation/implementation-guide/#10-example-implementation-pattern","title":"10. Example Implementation Pattern","text":"<pre><code>load_schemas()\nload_vocabularies()\n\nrecord = parse_input_json()\nvalidate_schema(record)\nvalidate_vocabularies(record)\n\ncanonical = canonicalize_json(record without attestation)\ncheck_revision_chain(canonical, record)\nverify_attestation(canonical, record.attestation)\n\nstore(record)\n</code></pre>"},{"location":"en/implementation/implementation-guide/#11-language-specific-notes","title":"11. Language-Specific Notes","text":""},{"location":"en/implementation/implementation-guide/#python","title":"Python","text":"<p><code>json.dumps(..., separators=(',', ':'), sort_keys=True)</code></p>"},{"location":"en/implementation/implementation-guide/#typescript","title":"TypeScript","text":"<p>Use deterministic-stringify libraries.</p>"},{"location":"en/implementation/implementation-guide/#rust","title":"Rust","text":"<p>Use <code>serde_json::to_writer</code> with sorted maps.</p>"},{"location":"en/implementation/implementation-guide/#java-c","title":"Java / C","text":"<p>Use custom deterministic serializers.</p> <p>All languages MUST yield identical canonical bytes.</p>"},{"location":"en/implementation/implementation-guide/#12-conformance-levels","title":"12. Conformance Levels","text":"Level Meaning Basic Validates schemas + vocabularies Full Validates attestations + revision chains Verifying Node Maintains verified subcategory Authoritative Node Issues new attestations"},{"location":"en/implementation/implementation-guide/#13-summary","title":"13. Summary","text":"<p>A complete CEP implementation MUST:</p> <p>\u2714 Validate schemas \u2714 Canonicalize deterministically \u2714 Verify cryptographic attestations \u2714 Maintain hash-linked revisions \u2714 Interpret vocabularies correctly \u2714 Support provenance graph construction \u2714 Achieve hash parity across languages  </p> <p>This ensures global interoperability within the Civic Graph.</p>"},{"location":"en/implementation/validator/","title":"Validator","text":"<p>Paste a sample Civic Exchange Protocol record below and validate it against one of the official schemas.</p>"},{"location":"en/implementation/validator/#schema-endpoints","title":"Schema Endpoints","text":"<p>The validator checks your JSON against one of the official Civic Exchange Protocol schemas:</p> <ul> <li> <p>Entity Schema https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schemas/cep.entity.schema.json</p> </li> <li> <p>Relationship Schema https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schemas/cep.relationship.schema.json</p> </li> <li> <p>Exchange Schema https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schemas/cep.exchange.schema.json</p> </li> <li> <p>Identifier Scheme Vocabulary https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schemas/cep.entity.identifier-scheme.schema.json</p> </li> </ul>"},{"location":"en/implementation/validator/#step-1-choose-schema","title":"Step 1. Choose schema","text":"<p> Entity (cep.entity.schema.json) Relationship (cep.relationship.schema.json) Exchange (cep.exchange.schema.json) <p></p>"},{"location":"en/implementation/validator/#step-2-input-json","title":"Step 2. Input JSON","text":"{   \"schemaVersion\": \"1.0.0\",   \"verifiableId\": \"cep-entity:sam-uei:J6H4FB3N5YK7\",   \"identifiers\": {     \"samUei\": \"J6H4FB3N5YK7\",     \"snfei\": \"d41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e\",     \"additionalSchemes\": [       {         \"schemeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/identifier-scheme.json#us-mn-district-id\",         \"value\": \"ISD-0123\"       },       {         \"schemeUri\": \"https://opencivicdata.org/id/division\",         \"value\": \"ocd-division/country:us/state:mn/school_district:123\"       }     ]   },   \"legalName\": \"Springfield Public School District 123\",   \"legalNameNormalized\": \"springfield public school district 123\",   \"entityTypeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/entity-type.json#school-district\",   \"jurisdictionIso\": \"US-MN\",   \"status\": {     \"statusCode\": \"ACTIVE\",     \"statusEffectiveDate\": \"2001-07-01\",     \"statusTerminationDate\": null,     \"successorEntityId\": null   },   \"naicsCode\": null,   \"resolutionConfidence\": {     \"score\": 1.0,     \"methodUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/resolution-method.json#authoritative-sam-sync\",     \"sourceRecordCount\": 1   },   \"attestation\": {     \"attestorId\": \"cep-entity:sam-uei:EDFEDERAL0001\",     \"attestationTimestamp\": \"2025-11-28T15:30:45.123456Z\",     \"proofType\": \"Ed25519Signature2020\",     \"proofValue\": \"BASE64_SIGNATURE_VALUE_HERE\",     \"verificationMethodUri\": \"https://keys.civic-interconnect.org/attestors/edfederal-node-1#primary-key\",     \"proofPurpose\": \"assertionMethod\",     \"anchorUri\": null   },   \"previousRecordHash\": null,   \"revisionNumber\": 1 }"},{"location":"en/implementation/validator/#step-3-validation-result","title":"Step 3. Validation Result","text":"(Waiting for input...)"},{"location":"en/reference/reference-projects/","title":"Reference Projects: GitHub Data Standards","text":"<p>There are categories of open-source projects on GitHub that offer great examples, particularly concerning common data schemas, multi-language support, and provenance tracking.</p>"},{"location":"en/reference/reference-projects/#1-interoperability-event-specifications-cross-platform","title":"1. Interoperability &amp; Event Specifications (Cross-Platform)","text":"<p>These standards focus on defining a common data format to ensure different systems and languages can communicate seamlessly. They typically define schemas and transport rules.</p>"},{"location":"en/reference/reference-projects/#cloudevents-specification","title":"CloudEvents Specification","text":"<p>This specification describes event data in a common way. It is designed to simplify event declaration and delivery across services, platforms, and languages (e.g., Go, Java, Python, C#).</p> <p>It's a good example of a cross-platform specification managed openly on GitHub. It defines a mandatory set of attributes (like a base entity identifier) that must be present in every data payload.</p> <p>Link: https://github.com/cloudevents/spec</p>"},{"location":"en/reference/reference-projects/#cdevents-specification","title":"CDEvents Specification","text":"<p>This is a popular specification for Continuous Delivery events, extending CloudEvents by introducing purpose and semantics to the event data.</p> <p>It shows how a standard is built on top of another standard (CloudEvents), specializing the common metadata for a specific domain (CI/CD provenance and flow).</p> <p>Link: https://github.com/cdevents/spec</p>"},{"location":"en/reference/reference-projects/#2-provenance-and-data-tracking-standards","title":"2. Provenance and Data Tracking Standards","text":"<p>These projects relate to provenance aspects, focusing on tracking the history, inputs, and derivation of data.</p>"},{"location":"en/reference/reference-projects/#prov-cpl-core-provenance-library","title":"PROV-CPL (Core Provenance Library)","text":"<p>This is the Core Provenance Library for collecting data provenance with multiple language bindings (C/C++, Java, Python, R). It uses the W3C PROV standard as its foundation.</p> <p>It demonstrates a multi-language implementation of a provenance standard, providing APIs to record who/what/when/where data was created, which is central to provenance.</p> <p>Link: https://github.com/ProvTools/prov-cpl</p>"},{"location":"en/reference/reference-projects/#3-general-data-schemas-and-monorepo-structure","title":"3. General Data Schemas and Monorepo Structure","text":"<p>These focus on using JSON Schema to define strict data structures and managing them in a versioned repository.</p>"},{"location":"en/reference/reference-projects/#json-schema-specification","title":"JSON Schema Specification","text":"<p>This is the official specification for JSON Schema, a declarative language used to annotate and validate JSON documents.</p> <p>This foundational tool is by many standards (including CloudEvents) to define specific fields and types. This repo illustrates how a core schema standard is defined and versioned.</p> <p>Link: https://github.com/json-schema-org/json-schema-spec</p>"},{"location":"en/reference/reference-projects/#consumer-data-standards-australian-dsb-schemas","title":"Consumer Data Standards (Australian DSB Schemas)","text":"<p>This repository holds a collection of JSON schema files derived from the Australian Consumer Data Standards, used for robust schema validation in banking and energy sectors.</p> <p>This offers a practical example of a large-scale data standard implementation in a monorepo (single repository), organized by release version, providing strict, enforceable JSON schemas for real-world data exchange.</p> <p>Link: https://github.com/ConsumerDataStandardsAustralia/dsb-schema-tools</p>"},{"location":"en/reference/reference-standards/","title":"Reference Standards","text":""},{"location":"en/reference/reference-standards/#associated-standards","title":"Associated Standards","text":"Standard/Acronym Purpose Why We Interface XBRL (eXtensible Business Reporting Language) The international standard for electronic transmission of business and financial data (e.g., SEC and FDIC filings use it). We map its transactional fields directly to the relevant XBRL taxonomy elements for regulatory compliance reporting. LEI (Legal Entity Identifier) Global standard for identifying parties to financial transactions worldwide. While the UEI is authoritative in the U.S. government space, our protocol needs to contain a field for the LEI if the entity is globally registered, ensuring compliance for any international transactions. W3C PROV (Provenance) The World Wide Web Consortium standard for recording the historical lifecycle and data quality of a piece of information. Our core value is Provenance. We adopt the principles of W3C PROV to formally define how data history, revisions, and sources are timestamped and logged. GTAS (Government-wide Treasury Account Symbol) The framework used by the Treasury for standardized federal financial reporting. Transactional data (e.g., amounts, categories) must be translatable into GTAS fields for seamless reporting up to the Treasury level."},{"location":"en/reference/reference-standards/#bridge","title":"Bridge","text":"<ul> <li>Official U.S UEI: The U.S. government already uses a Unique Entity Identifier (UEI), a 12-character alphanumeric ID assigned by SAM.gov, for all entities receiving federal financial assistance or doing business with the federal government (Source 3.1, 3.2). Often does not appear on state/local campaign finance reports or local school district consultant contracts unless federal funds are directly involved.</li> <li>Open-Source Data Cleaning Tools: Tools like Splink, OpenRefine, and Python/Pandas to manually clean and standardize messy names (\"Acme Consulting, LLC\" vs. \"Acme Consulting\") (Source 2.1, 2.3).</li> </ul>"}]}