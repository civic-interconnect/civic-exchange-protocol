{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"en/","title":"Project Documentation","text":"<p>Documentation for civic-exchange-protocol.</p> <p>Use the navigation menu to explore available modules and APIs.</p> <ul> <li>The API Reference section includes autogenerated docs from the source code.</li> <li>This home page will always be served at <code>/</code>.</li> </ul> <p>To learn more, visit the GitHub repository.</p>"},{"location":"en/api/","title":"API Reference","text":"<p>Auto-generated code documentation.</p>"},{"location":"en/api/#civic_exchange_protocol","title":"civic_exchange_protocol","text":""},{"location":"en/api/#civic_exchange_protocol.api","title":"api","text":"<p>CEP Entity Canonicalization Service.</p> <p>This service generates the Canonical String and Entity Hash for a CEP Entity Record, enforcing strict field ordering and temporal rules.</p> <p>Dependencies: fastapi, uvicorn, pydantic, hashlib, datetime, decimal To run: uvicorn cep_entity_service:app --reload</p>"},{"location":"en/api/#civic_exchange_protocol.api.CanonicalResponse","title":"CanonicalResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the structure of the API's successful output.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>class CanonicalResponse(BaseModel):\n    \"\"\"Defines the structure of the API's successful output.\"\"\"\n\n    c_string: str = Field(\n        ..., description=\"The Canonical String (C-String) used as the hash input.\"\n    )\n    entity_hash: str = Field(..., description=\"The final 64-character SHA-256 Entity Hash.\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.EntityPayload","title":"EntityPayload","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the structure for the CEP Entity Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>class EntityPayload(BaseModel):\n    \"\"\"Defines the structure for the CEP Entity Record.\"\"\"\n\n    # Section 1: Identity and Attestation\n    entity_uei: str = Field(..., pattern=r\"^[A-Z0-9]{12}$\", alias=\"entityUei\")\n    record_id: str = Field(..., max_length=64, alias=\"recordId\")\n    attesting_uei: str = Field(..., pattern=r\"^[A-Z0-9]{12}$\", alias=\"attestingUei\")\n    attestation_timestamp: datetime = Field(\n        ..., description=\"ISO 8601 UTC with microsecond precision.\", alias=\"attestationTimestamp\"\n    )\n\n    # Section 2: Temporal Status and Governance (The critical fields)\n    # Section 2: Temporal Status and Governance (The critical fields)\n    status_effective_date: datetime = Field(\n        ...,\n        description=\"The 'As-of' date/time when this record became valid.\",\n        alias=\"statusEffectiveDate\",\n    )\n    status_termination_date: datetime | None = Field(\n        None,\n        description=\"The date/time the record ceased to be valid (omitted if null).\",\n        alias=\"statusTerminationDate\",\n    )\n    legal_status: str = Field(\n        ..., description=\"e.g., ACTIVE, DISSOLVED, SUSPENDED.\", alias=\"legalStatus\"\n    )\n    status_suspension_date: datetime | None = Field(\n        None,\n        description=\"Date/time the entity was suspended (omitted if null).\",\n        alias=\"statusSuspensionDate\",\n    )\n    # Section 3: Core Attributes\n    legal_name: str = Field(..., max_length=256, alias=\"legalName\")\n    tax_id: str = Field(..., max_length=32, alias=\"taxId\")\n    physical_address_line1: str = Field(..., max_length=128, alias=\"physicalAddressLine1\")\n    physical_address_city: str = Field(..., max_length=64, alias=\"physicalAddressCity\")\n    physical_address_postal_code: str = Field(..., max_length=16, alias=\"physicalAddressPostalCode\")\n    is_government: bool = Field(\n        ..., description=\"True if a recognized government body.\", alias=\"isGovernment\"\n    )\n    naics_code: str | None = Field(None, max_length=10, alias=\"naicsCode\")\n\n    class Config:\n        \"\"\"Pydantic model configuration for JSON serialization and schema examples.\"\"\"\n\n        json_encoders = {datetime: lambda v: v.isoformat().replace(\"+00:00\", \"Z\")}\n        populate_by_name = True\n        # Example for API documentation\n        schema_extra = {\n            \"example\": {\n                \"entityUei\": \"1A2B3C4D5E6F\",\n                \"recordId\": \"CEP-2025-001\",\n                \"attestingUei\": \"GOV-0000000001\",\n                \"attestationTimestamp\": \"2025-11-27T17:52:30.123456Z\",\n                \"statusEffectiveDate\": \"2024-01-01T00:00:00Z\",\n                # statusTerminationDate is None/omitted, implying current validity\n                \"legalStatus\": \"ACTIVE\",\n                \"statusSuspensionDate\": None,  # Omitted\n                \"legalName\": \"Acme Data Solutions LLC\",\n                \"taxId\": \"99-1234567\",\n                \"physicalAddressLine1\": \"123 Main St.\",\n                \"physicalAddressCity\": \"Springfield\",\n                \"physicalAddressPostalCode\": \"62704\",\n                \"isGovernment\": False,\n                \"naicsCode\": \"541512\",\n            }\n        }\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.EntityPayload.Config","title":"Config","text":"<p>Pydantic model configuration for JSON serialization and schema examples.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>class Config:\n    \"\"\"Pydantic model configuration for JSON serialization and schema examples.\"\"\"\n\n    json_encoders = {datetime: lambda v: v.isoformat().replace(\"+00:00\", \"Z\")}\n    populate_by_name = True\n    # Example for API documentation\n    schema_extra = {\n        \"example\": {\n            \"entityUei\": \"1A2B3C4D5E6F\",\n            \"recordId\": \"CEP-2025-001\",\n            \"attestingUei\": \"GOV-0000000001\",\n            \"attestationTimestamp\": \"2025-11-27T17:52:30.123456Z\",\n            \"statusEffectiveDate\": \"2024-01-01T00:00:00Z\",\n            # statusTerminationDate is None/omitted, implying current validity\n            \"legalStatus\": \"ACTIVE\",\n            \"statusSuspensionDate\": None,  # Omitted\n            \"legalName\": \"Acme Data Solutions LLC\",\n            \"taxId\": \"99-1234567\",\n            \"physicalAddressLine1\": \"123 Main St.\",\n            \"physicalAddressCity\": \"Springfield\",\n            \"physicalAddressPostalCode\": \"62704\",\n            \"isGovernment\": False,\n            \"naicsCode\": \"541512\",\n        }\n    }\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.canonicalize_entity","title":"canonicalize_entity  <code>async</code>","text":"<pre><code>canonicalize_entity(payload: EntityPayload)\n</code></pre> <p>Receives an Entity Record, performs canonical serialization (CAOS), and returns the cryptographic entity hash.</p> <p>Performs canonical serialization (CAOS) on the entity record.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>@app.post(\"/api/v1/entity/canonicalize\", response_model=CanonicalResponse, status_code=200)\nasync def canonicalize_entity(payload: EntityPayload):\n    \"\"\"Receives an Entity Record, performs canonical serialization (CAOS), and returns the cryptographic entity hash.\n\n    Performs canonical serialization (CAOS) on the entity record.\n    \"\"\"\n    try:\n        # 1. Generate the Canonical String (C-String)\n        c_string = generate_canonical_string(payload)\n\n        # 2. Generate the Entity Hash\n        entity_hash = generate_entity_hash(c_string)\n\n        return CanonicalResponse(c_string=c_string, entity_hash=entity_hash)\n\n    except Exception as e:\n        print(f\"Error during canonicalization: {e}\")\n        # In a production system, detailed logs would be captured here.\n        raise HTTPException(status_code=500, detail=\"Internal canonicalization error.\") from e\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.generate_canonical_string","title":"generate_canonical_string","text":"<pre><code>generate_canonical_string(data: EntityPayload) -&gt; str\n</code></pre> <p>Generate the pipe-delimited Canonical String (C-String) based on CAOS.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>def generate_canonical_string(data: EntityPayload) -&gt; str:\n    \"\"\"Generate the pipe-delimited Canonical String (C-String) based on CAOS.\"\"\"\n    parts = []\n\n    # Convert Pydantic model to a dictionary. Use by_alias=False to use the Python field names.\n    # Exclude None is handled explicitly in the loop for consistency with CEP Rule 1.2\n    data_dict = data.dict(exclude_none=False)\n\n    for field_name in CANONICAL_ATTRIBUTE_ORDER:\n        value = data_dict.get(field_name)\n\n        # Rule 1.2: Field Omission (Null/Empty Exclusion)\n        if value is None or (isinstance(value, str) and value == \"\"):\n            continue\n\n        formatted_value = \"\"\n\n        # Specific rule for microsecond precision on attestationTimestamp\n        if field_name == \"attestationTimestamp\":\n            if not isinstance(value, datetime):\n                raise TypeError(f\"attestationTimestamp must be datetime, got {type(value)!r}\")\n            formatted_value = _format_datetime(value)\n\n        # Standard ISO 8601 for other temporal fields\n        elif field_name in [\"statusEffectiveDate\", \"statusTerminationDate\", \"statusSuspensionDate\"]:\n            # These are date-like; accept both date and datetime\n            if not isinstance(value, datetime | date):\n                raise TypeError(f\"{field_name} must be date/datetime, got {type(value)!r}\")\n            formatted_value = value.isoformat().replace(\"+00:00\", \"Z\")\n\n        # Standard Boolean Formatting\n        elif field_name == \"isGovernment\":\n            formatted_value = \"true\" if value else \"false\"\n\n        # Standard String/Integer Fields\n        else:\n            formatted_value = str(value)\n\n        parts.append(formatted_value)\n\n    # Rule 1.3: Join all parts with the pipe delimiter\n    return \"|\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.api.generate_entity_hash","title":"generate_entity_hash","text":"<pre><code>generate_entity_hash(c_string: str) -&gt; str\n</code></pre> <p>Generate the final SHA-256 Entity Hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/api.py</code> <pre><code>def generate_entity_hash(c_string: str) -&gt; str:\n    \"\"\"Generate the final SHA-256 Entity Hash.\"\"\"\n    return hashlib.sha256(c_string.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.cli","title":"cli","text":""},{"location":"en/api/#civic_exchange_protocol.cli.cli","title":"cli","text":"<p>Command-line interface for the Civic Exchange Protocol.</p> <p>This module provides CLI commands for: - version: Display the package version - validate: Validate exchange protocol data</p>"},{"location":"en/api/#civic_exchange_protocol.cli.cli.validate","title":"validate","text":"<pre><code>validate()\n</code></pre> <p>Validate exchange protocol data.</p> Source code in <code>src/python/src/civic_exchange_protocol/cli/cli.py</code> <pre><code>@app.command()\ndef validate():\n    \"\"\"Validate exchange protocol data.\"\"\"\n    print(\"Validator coming soon.\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.cli.cli.version","title":"version","text":"<pre><code>version()\n</code></pre> <p>Show package version.</p> Source code in <code>src/python/src/civic_exchange_protocol/cli/cli.py</code> <pre><code>@app.command()\ndef version():\n    \"\"\"Show package version.\"\"\"\n    from civic_exchange_protocol import __version__\n\n    print(__version__)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core","title":"core","text":"<p>CEP Core - Core primitives for the Civic Exchange Protocol.</p> <p>This package provides the foundational types used by all CEP record types:</p> <ul> <li>CanonicalTimestamp: Microsecond-precision UTC timestamps</li> <li>CanonicalHash: SHA-256 hash values</li> <li>Canonicalize: Base class for deterministic serialization</li> <li>Attestation: Cryptographic proof of record integrity</li> </ul>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation","title":"Attestation  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Cryptographic attestation proving record authenticity and integrity.</p> <p>This structure aligns with W3C Verifiable Credentials Data Integrity.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>@dataclass\nclass Attestation(Canonicalize):\n    \"\"\"Cryptographic attestation proving record authenticity and integrity.\n\n    This structure aligns with W3C Verifiable Credentials Data Integrity.\n    \"\"\"\n\n    # Verifiable ID of the entity or node attesting to this record\n    attestor_id: str\n\n    # When the attestation was created\n    attestation_timestamp: CanonicalTimestamp\n\n    # The proof algorithm identifier\n    # Examples: \"Ed25519Signature2020\", \"EcdsaSecp256k1Signature2019\", \"DataIntegrityProof\"\n    proof_type: str\n\n    # The cryptographic signature or proof value\n    proof_value: str\n\n    # URI resolving to the public key or DID document for verification\n    verification_method_uri: str\n\n    # The purpose of the proof\n    proof_purpose: ProofPurpose = field(default=ProofPurpose.ASSERTION_METHOD)\n\n    # Optional URI to a timestamping authority or DLT anchor\n    anchor_uri: str | None = None\n\n    @classmethod\n    def new(\n        cls,\n        attestor_id: str,\n        attestation_timestamp: CanonicalTimestamp,\n        proof_type: str,\n        proof_value: str,\n        verification_method_uri: str,\n    ) -&gt; \"Attestation\":\n        \"\"\"Create a new Attestation with required fields.\"\"\"\n        return cls(\n            attestor_id=attestor_id,\n            attestation_timestamp=attestation_timestamp,\n            proof_type=proof_type,\n            proof_value=proof_value,\n            verification_method_uri=verification_method_uri,\n        )\n\n    def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=purpose,\n            anchor_uri=self.anchor_uri,\n        )\n\n    def with_anchor(self, uri: str) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=self.proof_purpose,\n            anchor_uri=uri,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Fields in alphabetical order\n        insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n        insert_required(\n            fields,\n            \"attestationTimestamp\",\n            self.attestation_timestamp.to_canonical_string(),\n        )\n        insert_required(fields, \"attestorId\", self.attestor_id)\n        insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n        insert_required(fields, \"proofType\", self.proof_type)\n        insert_required(fields, \"proofValue\", self.proof_value)\n        insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Fields in alphabetical order\n    insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n    insert_required(\n        fields,\n        \"attestationTimestamp\",\n        self.attestation_timestamp.to_canonical_string(),\n    )\n    insert_required(fields, \"attestorId\", self.attestor_id)\n    insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n    insert_required(fields, \"proofType\", self.proof_type)\n    insert_required(fields, \"proofValue\", self.proof_value)\n    insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; Attestation\n</code></pre> <p>Create a new Attestation with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; \"Attestation\":\n    \"\"\"Create a new Attestation with required fields.\"\"\"\n    return cls(\n        attestor_id=attestor_id,\n        attestation_timestamp=attestation_timestamp,\n        proof_type=proof_type,\n        proof_value=proof_value,\n        verification_method_uri=verification_method_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation.with_anchor","title":"with_anchor","text":"<pre><code>with_anchor(uri: str) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified anchor URI.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def with_anchor(self, uri: str) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=self.proof_purpose,\n        anchor_uri=uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Attestation.with_purpose","title":"with_purpose","text":"<pre><code>with_purpose(purpose: ProofPurpose) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified proof purpose.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=purpose,\n        anchor_uri=self.anchor_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash","title":"CanonicalHash","text":"<p>A SHA-256 hash value represented as a 64-character lowercase hex string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>class CanonicalHash:\n    \"\"\"A SHA-256 hash value represented as a 64-character lowercase hex string.\"\"\"\n\n    __slots__ = (\"_hex\",)\n\n    def __init__(self, hex_value: str) -&gt; None:\n        \"\"\"Create a CanonicalHash from a hex string.\n\n        Args:\n            hex_value: A 64-character hexadecimal string.\n\n        Raises:\n            ValueError: If the string is not valid.\n        \"\"\"\n        if len(hex_value) != 64:\n            raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n        if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n            raise ValueError(\"Hash must contain only hexadecimal characters\")\n        self._hex = hex_value.lower()\n\n    @classmethod\n    def from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n        \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n        Args:\n            canonical: The canonical string to hash.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        hasher = hashlib.sha256()\n        hasher.update(canonical.encode(\"utf-8\"))\n        return cls(hasher.hexdigest())\n\n    @classmethod\n    def from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n        \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n        Args:\n            hex_value: A hexadecimal string.\n\n        Returns:\n            A CanonicalHash instance, or None if invalid.\n        \"\"\"\n        try:\n            return cls(hex_value)\n        except ValueError:\n            return None\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Return the hash as a lowercase hex string.\"\"\"\n        return self._hex\n\n    def as_bytes(self) -&gt; bytes:\n        \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n        return bytes.fromhex(self._hex)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the hash.\"\"\"\n        return self._hex\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a detailed string representation of the hash.\"\"\"\n        return f\"CanonicalHash({self._hex!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n        if isinstance(other, CanonicalHash):\n            return self._hex == other._hex\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n        return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n    if isinstance(other, CanonicalHash):\n        return self._hex == other._hex\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n    return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__init__","title":"__init__","text":"<pre><code>__init__(hex_value: str) -&gt; None\n</code></pre> <p>Create a CanonicalHash from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A 64-character hexadecimal string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not valid.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __init__(self, hex_value: str) -&gt; None:\n    \"\"\"Create a CanonicalHash from a hex string.\n\n    Args:\n        hex_value: A 64-character hexadecimal string.\n\n    Raises:\n        ValueError: If the string is not valid.\n    \"\"\"\n    if len(hex_value) != 64:\n        raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n    if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n        raise ValueError(\"Hash must contain only hexadecimal characters\")\n    self._hex = hex_value.lower()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a detailed string representation of the hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a detailed string representation of the hash.\"\"\"\n    return f\"CanonicalHash({self._hex!r})\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the hash.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Return the hash as bytes (32 bytes).</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def as_bytes(self) -&gt; bytes:\n    \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n    return bytes.fromhex(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Return the hash as a lowercase hex string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Return the hash as a lowercase hex string.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.from_canonical_string","title":"from_canonical_string  <code>classmethod</code>","text":"<pre><code>from_canonical_string(canonical: str) -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the given canonical string.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical string to hash.</p> required <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>@classmethod\ndef from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n    \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n    Args:\n        canonical: The canonical string to hash.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(canonical.encode(\"utf-8\"))\n    return cls(hasher.hexdigest())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalHash.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(hex_value: str) -&gt; Optional[CanonicalHash]\n</code></pre> <p>Create a CanonicalHash from a pre-computed hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Optional[CanonicalHash]</code> <p>A CanonicalHash instance, or None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n    \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n    Args:\n        hex_value: A hexadecimal string.\n\n    Returns:\n        A CanonicalHash instance, or None if invalid.\n    \"\"\"\n    try:\n        return cls(hex_value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp","title":"CanonicalTimestamp","text":"<p>A canonical CEP timestamp with mandatory microsecond precision.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>class CanonicalTimestamp:\n    \"\"\"A canonical CEP timestamp with mandatory microsecond precision.\"\"\"\n\n    __slots__ = (\"_dt\",)\n\n    def __init__(self, dt: datetime) -&gt; None:\n        \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n        Args:\n            dt: A datetime object. If naive, assumed to be UTC.\n                If aware, will be converted to UTC.\n        \"\"\"\n        if dt.tzinfo is None:\n            # Naive datetime - assume UTC\n            self._dt = dt.replace(tzinfo=UTC)\n        else:\n            # Convert to UTC\n            self._dt = dt.astimezone(UTC)\n\n    @classmethod\n    def now(cls) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n        return cls(datetime.now(UTC))\n\n    @classmethod\n    def parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Parse an ISO 8601 timestamp string.\n\n        Accepts formats:\n        - 2025-11-28T14:30:00.123456Z\n        - 2025-11-28T14:30:00.123456+00:00\n        - 2025-11-28T14:30:00Z (will add .000000)\n\n        Args:\n            s: The timestamp string to parse.\n\n        Returns:\n            A CanonicalTimestamp instance.\n\n        Raises:\n            ValueError: If the string cannot be parsed.\n        \"\"\"\n        # Handle Z suffix\n        if s.endswith(\"Z\"):\n            s = s[:-1] + \"+00:00\"\n\n        # Try parsing with microseconds\n        try:\n            dt = datetime.fromisoformat(s)\n            return cls(dt)\n        except ValueError:\n            pass\n\n        # Try without microseconds and add them\n        try:\n            # Remove timezone for parsing, then add back\n            if \"+\" in s:\n                base, tz = s.rsplit(\"+\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n            if s.count(\"-\") &gt; 2:  # Has negative offset\n                base, tz = s.rsplit(\"-\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n        except ValueError:\n            pass\n\n        raise ValueError(f\"Cannot parse timestamp: {s}\")\n\n    def as_datetime(self) -&gt; datetime:\n        \"\"\"Return the underlying datetime object (UTC).\"\"\"\n        return self._dt\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\n\n        Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n        This format is REQUIRED for hash stability across all CEP implementations.\n        \"\"\"\n        return self._dt.strftime(CANONICAL_FORMAT)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n        return self.to_canonical_string()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n        return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt == other._dt\n        return NotImplemented\n\n    def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt; other._dt\n        return NotImplemented\n\n    def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt;= other._dt\n        return NotImplemented\n\n    def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt; other._dt\n        return NotImplemented\n\n    def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt;= other._dt\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the timestamp.\"\"\"\n        return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt == other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than or equal to another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return the hash of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the timestamp.\"\"\"\n    return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__init__","title":"__init__","text":"<pre><code>__init__(dt: datetime) -&gt; None\n</code></pre> <p>Create a new CanonicalTimestamp from a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A datetime object. If naive, assumed to be UTC. If aware, will be converted to UTC.</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __init__(self, dt: datetime) -&gt; None:\n    \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n    Args:\n        dt: A datetime object. If naive, assumed to be UTC.\n            If aware, will be converted to UTC.\n    \"\"\"\n    if dt.tzinfo is None:\n        # Naive datetime - assume UTC\n        self._dt = dt.replace(tzinfo=UTC)\n    else:\n        # Convert to UTC\n        self._dt = dt.astimezone(UTC)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__le__","title":"__le__","text":"<pre><code>__le__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than or equal to another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the developer-friendly representation of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n    return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the canonical string representation of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n    return self.to_canonical_string()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.as_datetime","title":"as_datetime","text":"<pre><code>as_datetime() -&gt; datetime\n</code></pre> <p>Return the underlying datetime object (UTC).</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def as_datetime(self) -&gt; datetime:\n    \"\"\"Return the underlying datetime object (UTC).\"\"\"\n    return self._dt\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.now","title":"now  <code>classmethod</code>","text":"<pre><code>now() -&gt; CanonicalTimestamp\n</code></pre> <p>Return the current UTC time as a CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n    return cls(datetime.now(UTC))\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(s: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse an ISO 8601 timestamp string.</p> <p>Accepts formats: - 2025-11-28T14:30:00.123456Z - 2025-11-28T14:30:00.123456+00:00 - 2025-11-28T14:30:00Z (will add .000000)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The timestamp string to parse.</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>A CanonicalTimestamp instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string cannot be parsed.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Parse an ISO 8601 timestamp string.\n\n    Accepts formats:\n    - 2025-11-28T14:30:00.123456Z\n    - 2025-11-28T14:30:00.123456+00:00\n    - 2025-11-28T14:30:00Z (will add .000000)\n\n    Args:\n        s: The timestamp string to parse.\n\n    Returns:\n        A CanonicalTimestamp instance.\n\n    Raises:\n        ValueError: If the string cannot be parsed.\n    \"\"\"\n    # Handle Z suffix\n    if s.endswith(\"Z\"):\n        s = s[:-1] + \"+00:00\"\n\n    # Try parsing with microseconds\n    try:\n        dt = datetime.fromisoformat(s)\n        return cls(dt)\n    except ValueError:\n        pass\n\n    # Try without microseconds and add them\n    try:\n        # Remove timezone for parsing, then add back\n        if \"+\" in s:\n            base, tz = s.rsplit(\"+\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n        if s.count(\"-\") &gt; 2:  # Has negative offset\n            base, tz = s.rsplit(\"-\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n    except ValueError:\n        pass\n\n    raise ValueError(f\"Cannot parse timestamp: {s}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CanonicalTimestamp.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> <p>Format: YYYY-MM-DDTHH:MM:SS.ffffffZ</p> <p>This format is REQUIRED for hash stability across all CEP implementations.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\n\n    Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n    This format is REQUIRED for hash stability across all CEP implementations.\n    \"\"\"\n    return self._dt.strftime(CANONICAL_FORMAT)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for types that can be serialized to a canonical string for hashing.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>class Canonicalize(ABC):\n    \"\"\"Base class for types that can be serialized to a canonical string for hashing.\"\"\"\n\n    @abstractmethod\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the ordered map of field names to their canonical string values.\n\n        Fields with None/null/empty values should NOT be included in the dict.\n        The dict will be sorted alphabetically by key.\n\n        Returns:\n            A dictionary of field names to string values.\n        \"\"\"\n        pass\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Generate the canonical string representation for hashing.\n\n        Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n        Fields are ordered alphabetically by key.\n\n        Returns:\n            The canonical string.\n        \"\"\"\n        fields = self.canonical_fields()\n        # Sort by key alphabetically\n        sorted_items = sorted(fields.items(), key=lambda x: x[0])\n        parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n        return \",\".join(parts)\n\n    def calculate_hash(self) -&gt; CanonicalHash:\n        \"\"\"Compute the SHA-256 hash of the canonical string.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Canonicalize.calculate_hash","title":"calculate_hash","text":"<pre><code>calculate_hash() -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the canonical string.</p> <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def calculate_hash(self) -&gt; CanonicalHash:\n    \"\"\"Compute the SHA-256 hash of the canonical string.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Canonicalize.canonical_fields","title":"canonical_fields  <code>abstractmethod</code>","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the ordered map of field names to their canonical string values.</p> <p>Fields with None/null/empty values should NOT be included in the dict. The dict will be sorted alphabetically by key.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of field names to string values.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>@abstractmethod\ndef canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the ordered map of field names to their canonical string values.\n\n    Fields with None/null/empty values should NOT be included in the dict.\n    The dict will be sorted alphabetically by key.\n\n    Returns:\n        A dictionary of field names to string values.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.Canonicalize.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Generate the canonical string representation for hashing.</p> <p>Format: \"field1\":\"value1\",\"field2\":\"value2\",...</p> <p>Fields are ordered alphabetically by key.</p> <p>Returns:</p> Type Description <code>str</code> <p>The canonical string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Generate the canonical string representation for hashing.\n\n    Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n    Fields are ordered alphabetically by key.\n\n    Returns:\n        The canonical string.\n    \"\"\"\n    fields = self.canonical_fields()\n    # Sort by key alphabetically\n    sorted_items = sorted(fields.items(), key=lambda x: x[0])\n    parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n    return \",\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.CepError","title":"CepError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for CEP operations.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class CepError(Exception):\n    \"\"\"Base exception for CEP operations.\"\"\"\n\n    pass\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.HashMismatchError","title":"HashMismatchError","text":"<p>               Bases: <code>CepError</code></p> <p>Hash verification failed.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class HashMismatchError(CepError):\n    \"\"\"Hash verification failed.\"\"\"\n\n    def __init__(self, expected: str, actual: str) -&gt; None:\n        \"\"\"Initialize with expected and actual hash values.\"\"\"\n        super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n        self.expected = expected\n        self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.HashMismatchError.__init__","title":"__init__","text":"<pre><code>__init__(expected: str, actual: str) -&gt; None\n</code></pre> <p>Initialize with expected and actual hash values.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, expected: str, actual: str) -&gt; None:\n    \"\"\"Initialize with expected and actual hash values.\"\"\"\n    super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidHashError","title":"InvalidHashError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid hash format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidHashError(CepError):\n    \"\"\"Invalid hash format.\"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Initialize with the invalid hash value.\"\"\"\n        super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidHashError.__init__","title":"__init__","text":"<pre><code>__init__(value: str) -&gt; None\n</code></pre> <p>Initialize with the invalid hash value.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize with the invalid hash value.\"\"\"\n    super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidIdentifierError","title":"InvalidIdentifierError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid identifier format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidIdentifierError(CepError):\n    \"\"\"Invalid identifier format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid identifier.\"\"\"\n        super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidIdentifierError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid identifier.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid identifier.\"\"\"\n    super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidTimestampError","title":"InvalidTimestampError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid timestamp format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidTimestampError(CepError):\n    \"\"\"Invalid timestamp format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n        super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.InvalidTimestampError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n    super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.MissingFieldError","title":"MissingFieldError","text":"<p>               Bases: <code>CepError</code></p> <p>Missing required field.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class MissingFieldError(CepError):\n    \"\"\"Missing required field.\"\"\"\n\n    def __init__(self, field: str) -&gt; None:\n        \"\"\"Initialize with the name of the missing field.\"\"\"\n        super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.MissingFieldError.__init__","title":"__init__","text":"<pre><code>__init__(field: str) -&gt; None\n</code></pre> <p>Initialize with the name of the missing field.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, field: str) -&gt; None:\n    \"\"\"Initialize with the name of the missing field.\"\"\"\n    super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.ProofPurpose","title":"ProofPurpose","text":"<p>               Bases: <code>Enum</code></p> <p>The purpose of a cryptographic proof.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>class ProofPurpose(Enum):\n    \"\"\"The purpose of a cryptographic proof.\"\"\"\n\n    ASSERTION_METHOD = \"assertionMethod\"\n    AUTHENTICATION = \"authentication\"\n    CAPABILITY_DELEGATION = \"capabilityDelegation\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.ProofPurpose.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.RevisionChainError","title":"RevisionChainError","text":"<p>               Bases: <code>CepError</code></p> <p>Revision chain error.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class RevisionChainError(CepError):\n    \"\"\"Revision chain error.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about revision chain.\"\"\"\n        super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.RevisionChainError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about revision chain.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about revision chain.\"\"\"\n    super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.UnsupportedVersionError","title":"UnsupportedVersionError","text":"<p>               Bases: <code>CepError</code></p> <p>Schema version mismatch.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class UnsupportedVersionError(CepError):\n    \"\"\"Schema version mismatch.\"\"\"\n\n    def __init__(self, version: str) -&gt; None:\n        \"\"\"Initialize with the unsupported version string.\"\"\"\n        super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.UnsupportedVersionError.__init__","title":"__init__","text":"<pre><code>__init__(version: str) -&gt; None\n</code></pre> <p>Initialize with the unsupported version string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, version: str) -&gt; None:\n    \"\"\"Initialize with the unsupported version string.\"\"\"\n    super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.format_amount","title":"format_amount","text":"<pre><code>format_amount(amount: float) -&gt; str\n</code></pre> <p>Format a monetary amount with exactly 2 decimal places.</p> <p>This ensures consistent formatting across all implementations: - 100 becomes \"100.00\" - 100.5 becomes \"100.50\" - 100.756 becomes \"100.76\" (rounded)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The monetary amount.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted string with exactly 2 decimal places.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def format_amount(amount: float) -&gt; str:\n    \"\"\"Format a monetary amount with exactly 2 decimal places.\n\n    This ensures consistent formatting across all implementations:\n    - 100 becomes \"100.00\"\n    - 100.5 becomes \"100.50\"\n    - 100.756 becomes \"100.76\" (rounded)\n\n    Args:\n        amount: The monetary amount.\n\n    Returns:\n        The formatted string with exactly 2 decimal places.\n    \"\"\"\n    # Use Decimal for precise rounding\n    d = Decimal(str(amount))\n    rounded = d.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n    return f\"{rounded:.2f}\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.insert_if_present","title":"insert_if_present","text":"<pre><code>insert_if_present(\n    fields: dict[str, str], key: str, value: str | None\n) -&gt; None\n</code></pre> <p>Add a field to the dict only if the value is not None and not empty.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str | None</code> <p>The field value (may be None or empty).</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def insert_if_present(fields: dict[str, str], key: str, value: str | None) -&gt; None:\n    \"\"\"Add a field to the dict only if the value is not None and not empty.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value (may be None or empty).\n    \"\"\"\n    if value is not None and value != \"\":\n        fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.insert_required","title":"insert_required","text":"<pre><code>insert_required(\n    fields: dict[str, str], key: str, value: str\n) -&gt; None\n</code></pre> <p>Add a required field to the dict.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str</code> <p>The field value.</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def insert_required(fields: dict[str, str], key: str, value: str) -&gt; None:\n    \"\"\"Add a required field to the dict.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value.\n    \"\"\"\n    fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation","title":"attestation","text":"<p>Attestation and cryptographic proof types for CEP records.</p> <p>Every CEP record includes an attestation block that proves: - Who attested to the record (attestor_id) - When it was attested (attestation_timestamp) - Cryptographic proof of integrity (proof_type, proof_value, verification_method_uri)</p>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation","title":"Attestation  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Cryptographic attestation proving record authenticity and integrity.</p> <p>This structure aligns with W3C Verifiable Credentials Data Integrity.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>@dataclass\nclass Attestation(Canonicalize):\n    \"\"\"Cryptographic attestation proving record authenticity and integrity.\n\n    This structure aligns with W3C Verifiable Credentials Data Integrity.\n    \"\"\"\n\n    # Verifiable ID of the entity or node attesting to this record\n    attestor_id: str\n\n    # When the attestation was created\n    attestation_timestamp: CanonicalTimestamp\n\n    # The proof algorithm identifier\n    # Examples: \"Ed25519Signature2020\", \"EcdsaSecp256k1Signature2019\", \"DataIntegrityProof\"\n    proof_type: str\n\n    # The cryptographic signature or proof value\n    proof_value: str\n\n    # URI resolving to the public key or DID document for verification\n    verification_method_uri: str\n\n    # The purpose of the proof\n    proof_purpose: ProofPurpose = field(default=ProofPurpose.ASSERTION_METHOD)\n\n    # Optional URI to a timestamping authority or DLT anchor\n    anchor_uri: str | None = None\n\n    @classmethod\n    def new(\n        cls,\n        attestor_id: str,\n        attestation_timestamp: CanonicalTimestamp,\n        proof_type: str,\n        proof_value: str,\n        verification_method_uri: str,\n    ) -&gt; \"Attestation\":\n        \"\"\"Create a new Attestation with required fields.\"\"\"\n        return cls(\n            attestor_id=attestor_id,\n            attestation_timestamp=attestation_timestamp,\n            proof_type=proof_type,\n            proof_value=proof_value,\n            verification_method_uri=verification_method_uri,\n        )\n\n    def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=purpose,\n            anchor_uri=self.anchor_uri,\n        )\n\n    def with_anchor(self, uri: str) -&gt; \"Attestation\":\n        \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n        return Attestation(\n            attestor_id=self.attestor_id,\n            attestation_timestamp=self.attestation_timestamp,\n            proof_type=self.proof_type,\n            proof_value=self.proof_value,\n            verification_method_uri=self.verification_method_uri,\n            proof_purpose=self.proof_purpose,\n            anchor_uri=uri,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Fields in alphabetical order\n        insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n        insert_required(\n            fields,\n            \"attestationTimestamp\",\n            self.attestation_timestamp.to_canonical_string(),\n        )\n        insert_required(fields, \"attestorId\", self.attestor_id)\n        insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n        insert_required(fields, \"proofType\", self.proof_type)\n        insert_required(fields, \"proofValue\", self.proof_value)\n        insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Fields in alphabetical order\n    insert_if_present(fields, \"anchorUri\", self.anchor_uri)\n    insert_required(\n        fields,\n        \"attestationTimestamp\",\n        self.attestation_timestamp.to_canonical_string(),\n    )\n    insert_required(fields, \"attestorId\", self.attestor_id)\n    insert_required(fields, \"proofPurpose\", self.proof_purpose.as_str())\n    insert_required(fields, \"proofType\", self.proof_type)\n    insert_required(fields, \"proofValue\", self.proof_value)\n    insert_required(fields, \"verificationMethodUri\", self.verification_method_uri)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; Attestation\n</code></pre> <p>Create a new Attestation with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    attestor_id: str,\n    attestation_timestamp: CanonicalTimestamp,\n    proof_type: str,\n    proof_value: str,\n    verification_method_uri: str,\n) -&gt; \"Attestation\":\n    \"\"\"Create a new Attestation with required fields.\"\"\"\n    return cls(\n        attestor_id=attestor_id,\n        attestation_timestamp=attestation_timestamp,\n        proof_type=proof_type,\n        proof_value=proof_value,\n        verification_method_uri=verification_method_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation.with_anchor","title":"with_anchor","text":"<pre><code>with_anchor(uri: str) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified anchor URI.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def with_anchor(self, uri: str) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified anchor URI.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=self.proof_purpose,\n        anchor_uri=uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.Attestation.with_purpose","title":"with_purpose","text":"<pre><code>with_purpose(purpose: ProofPurpose) -&gt; Attestation\n</code></pre> <p>Return a new Attestation with the specified proof purpose.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def with_purpose(self, purpose: ProofPurpose) -&gt; \"Attestation\":\n    \"\"\"Return a new Attestation with the specified proof purpose.\"\"\"\n    return Attestation(\n        attestor_id=self.attestor_id,\n        attestation_timestamp=self.attestation_timestamp,\n        proof_type=self.proof_type,\n        proof_value=self.proof_value,\n        verification_method_uri=self.verification_method_uri,\n        proof_purpose=purpose,\n        anchor_uri=self.anchor_uri,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.ProofPurpose","title":"ProofPurpose","text":"<p>               Bases: <code>Enum</code></p> <p>The purpose of a cryptographic proof.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>class ProofPurpose(Enum):\n    \"\"\"The purpose of a cryptographic proof.\"\"\"\n\n    ASSERTION_METHOD = \"assertionMethod\"\n    AUTHENTICATION = \"authentication\"\n    CAPABILITY_DELEGATION = \"capabilityDelegation\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.attestation.ProofPurpose.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/attestation.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical","title":"canonical","text":"<p>Canonical serialization for CEP records.</p> <p>This module provides the base class and utilities for generating deterministic canonical strings from CEP records. The canonical string is the input to SHA-256 hashing for record integrity verification.</p> <p>Canonicalization Rules: 1. Field Order: Fields MUST be serialized in alphabetical order. 2. Null/Empty Omission: Fields with None or empty string values    MUST be omitted entirely from the canonical string. 3. Timestamp Format: All timestamps MUST use YYYY-MM-DDTHH:MM:SS.ffffffZ    with exactly 6 decimal places for microseconds. 4. Numeric Format: Monetary amounts MUST use exactly 2 decimal places.    Integers MUST NOT have decimal points. 5. String Escaping: Strings are NOT JSON-escaped in the canonical form.    The canonical string is a simple key:value concatenation. 6. Encoding: The canonical string MUST be UTF-8 encoded.</p>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for types that can be serialized to a canonical string for hashing.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>class Canonicalize(ABC):\n    \"\"\"Base class for types that can be serialized to a canonical string for hashing.\"\"\"\n\n    @abstractmethod\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the ordered map of field names to their canonical string values.\n\n        Fields with None/null/empty values should NOT be included in the dict.\n        The dict will be sorted alphabetically by key.\n\n        Returns:\n            A dictionary of field names to string values.\n        \"\"\"\n        pass\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Generate the canonical string representation for hashing.\n\n        Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n        Fields are ordered alphabetically by key.\n\n        Returns:\n            The canonical string.\n        \"\"\"\n        fields = self.canonical_fields()\n        # Sort by key alphabetically\n        sorted_items = sorted(fields.items(), key=lambda x: x[0])\n        parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n        return \",\".join(parts)\n\n    def calculate_hash(self) -&gt; CanonicalHash:\n        \"\"\"Compute the SHA-256 hash of the canonical string.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.Canonicalize.calculate_hash","title":"calculate_hash","text":"<pre><code>calculate_hash() -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the canonical string.</p> <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def calculate_hash(self) -&gt; CanonicalHash:\n    \"\"\"Compute the SHA-256 hash of the canonical string.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    return CanonicalHash.from_canonical_string(self.to_canonical_string())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.Canonicalize.canonical_fields","title":"canonical_fields  <code>abstractmethod</code>","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the ordered map of field names to their canonical string values.</p> <p>Fields with None/null/empty values should NOT be included in the dict. The dict will be sorted alphabetically by key.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of field names to string values.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>@abstractmethod\ndef canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the ordered map of field names to their canonical string values.\n\n    Fields with None/null/empty values should NOT be included in the dict.\n    The dict will be sorted alphabetically by key.\n\n    Returns:\n        A dictionary of field names to string values.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.Canonicalize.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Generate the canonical string representation for hashing.</p> <p>Format: \"field1\":\"value1\",\"field2\":\"value2\",...</p> <p>Fields are ordered alphabetically by key.</p> <p>Returns:</p> Type Description <code>str</code> <p>The canonical string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Generate the canonical string representation for hashing.\n\n    Format: \"field1\":\"value1\",\"field2\":\"value2\",...\n\n    Fields are ordered alphabetically by key.\n\n    Returns:\n        The canonical string.\n    \"\"\"\n    fields = self.canonical_fields()\n    # Sort by key alphabetically\n    sorted_items = sorted(fields.items(), key=lambda x: x[0])\n    parts = [f'\"{k}\":\"{v}\"' for k, v in sorted_items]\n    return \",\".join(parts)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.format_amount","title":"format_amount","text":"<pre><code>format_amount(amount: float) -&gt; str\n</code></pre> <p>Format a monetary amount with exactly 2 decimal places.</p> <p>This ensures consistent formatting across all implementations: - 100 becomes \"100.00\" - 100.5 becomes \"100.50\" - 100.756 becomes \"100.76\" (rounded)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The monetary amount.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted string with exactly 2 decimal places.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def format_amount(amount: float) -&gt; str:\n    \"\"\"Format a monetary amount with exactly 2 decimal places.\n\n    This ensures consistent formatting across all implementations:\n    - 100 becomes \"100.00\"\n    - 100.5 becomes \"100.50\"\n    - 100.756 becomes \"100.76\" (rounded)\n\n    Args:\n        amount: The monetary amount.\n\n    Returns:\n        The formatted string with exactly 2 decimal places.\n    \"\"\"\n    # Use Decimal for precise rounding\n    d = Decimal(str(amount))\n    rounded = d.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n    return f\"{rounded:.2f}\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.insert_if_present","title":"insert_if_present","text":"<pre><code>insert_if_present(\n    fields: dict[str, str], key: str, value: str | None\n) -&gt; None\n</code></pre> <p>Add a field to the dict only if the value is not None and not empty.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str | None</code> <p>The field value (may be None or empty).</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def insert_if_present(fields: dict[str, str], key: str, value: str | None) -&gt; None:\n    \"\"\"Add a field to the dict only if the value is not None and not empty.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value (may be None or empty).\n    \"\"\"\n    if value is not None and value != \"\":\n        fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.canonical.insert_required","title":"insert_required","text":"<pre><code>insert_required(\n    fields: dict[str, str], key: str, value: str\n) -&gt; None\n</code></pre> <p>Add a required field to the dict.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, str]</code> <p>The dictionary to add to.</p> required <code>key</code> <code>str</code> <p>The field name.</p> required <code>value</code> <code>str</code> <p>The field value.</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/canonical.py</code> <pre><code>def insert_required(fields: dict[str, str], key: str, value: str) -&gt; None:\n    \"\"\"Add a required field to the dict.\n\n    Args:\n        fields: The dictionary to add to.\n        key: The field name.\n        value: The field value.\n    \"\"\"\n    fields[key] = value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error","title":"error","text":"<p>Error types for CEP operations.</p>"},{"location":"en/api/#civic_exchange_protocol.core.error.CepError","title":"CepError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for CEP operations.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class CepError(Exception):\n    \"\"\"Base exception for CEP operations.\"\"\"\n\n    pass\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.HashMismatchError","title":"HashMismatchError","text":"<p>               Bases: <code>CepError</code></p> <p>Hash verification failed.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class HashMismatchError(CepError):\n    \"\"\"Hash verification failed.\"\"\"\n\n    def __init__(self, expected: str, actual: str) -&gt; None:\n        \"\"\"Initialize with expected and actual hash values.\"\"\"\n        super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n        self.expected = expected\n        self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.HashMismatchError.__init__","title":"__init__","text":"<pre><code>__init__(expected: str, actual: str) -&gt; None\n</code></pre> <p>Initialize with expected and actual hash values.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, expected: str, actual: str) -&gt; None:\n    \"\"\"Initialize with expected and actual hash values.\"\"\"\n    super().__init__(f\"hash verification failed: expected {expected}, got {actual}\")\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidHashError","title":"InvalidHashError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid hash format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidHashError(CepError):\n    \"\"\"Invalid hash format.\"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Initialize with the invalid hash value.\"\"\"\n        super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidHashError.__init__","title":"__init__","text":"<pre><code>__init__(value: str) -&gt; None\n</code></pre> <p>Initialize with the invalid hash value.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Initialize with the invalid hash value.\"\"\"\n    super().__init__(f\"invalid hash: expected 64 hex characters, got {value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidIdentifierError","title":"InvalidIdentifierError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid identifier format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidIdentifierError(CepError):\n    \"\"\"Invalid identifier format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid identifier.\"\"\"\n        super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidIdentifierError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid identifier.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid identifier.\"\"\"\n    super().__init__(f\"invalid identifier: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidTimestampError","title":"InvalidTimestampError","text":"<p>               Bases: <code>CepError</code></p> <p>Invalid timestamp format.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class InvalidTimestampError(CepError):\n    \"\"\"Invalid timestamp format.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n        super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.InvalidTimestampError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about invalid timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about invalid timestamp.\"\"\"\n    super().__init__(f\"invalid timestamp: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.MissingFieldError","title":"MissingFieldError","text":"<p>               Bases: <code>CepError</code></p> <p>Missing required field.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class MissingFieldError(CepError):\n    \"\"\"Missing required field.\"\"\"\n\n    def __init__(self, field: str) -&gt; None:\n        \"\"\"Initialize with the name of the missing field.\"\"\"\n        super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.MissingFieldError.__init__","title":"__init__","text":"<pre><code>__init__(field: str) -&gt; None\n</code></pre> <p>Initialize with the name of the missing field.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, field: str) -&gt; None:\n    \"\"\"Initialize with the name of the missing field.\"\"\"\n    super().__init__(f\"missing required field: {field}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.RevisionChainError","title":"RevisionChainError","text":"<p>               Bases: <code>CepError</code></p> <p>Revision chain error.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class RevisionChainError(CepError):\n    \"\"\"Revision chain error.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        \"\"\"Initialize with error message about revision chain.\"\"\"\n        super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.RevisionChainError.__init__","title":"__init__","text":"<pre><code>__init__(message: str) -&gt; None\n</code></pre> <p>Initialize with error message about revision chain.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize with error message about revision chain.\"\"\"\n    super().__init__(f\"revision chain error: {message}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.UnsupportedVersionError","title":"UnsupportedVersionError","text":"<p>               Bases: <code>CepError</code></p> <p>Schema version mismatch.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>class UnsupportedVersionError(CepError):\n    \"\"\"Schema version mismatch.\"\"\"\n\n    def __init__(self, version: str) -&gt; None:\n        \"\"\"Initialize with the unsupported version string.\"\"\"\n        super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.error.UnsupportedVersionError.__init__","title":"__init__","text":"<pre><code>__init__(version: str) -&gt; None\n</code></pre> <p>Initialize with the unsupported version string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/error.py</code> <pre><code>def __init__(self, version: str) -&gt; None:\n    \"\"\"Initialize with the unsupported version string.\"\"\"\n    super().__init__(f\"unsupported schema version: {version}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash","title":"hash","text":"<p>Cryptographic hashing utilities for CEP records.</p> <p>All CEP hashes are SHA-256, represented as lowercase hexadecimal strings.</p>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash","title":"CanonicalHash","text":"<p>A SHA-256 hash value represented as a 64-character lowercase hex string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>class CanonicalHash:\n    \"\"\"A SHA-256 hash value represented as a 64-character lowercase hex string.\"\"\"\n\n    __slots__ = (\"_hex\",)\n\n    def __init__(self, hex_value: str) -&gt; None:\n        \"\"\"Create a CanonicalHash from a hex string.\n\n        Args:\n            hex_value: A 64-character hexadecimal string.\n\n        Raises:\n            ValueError: If the string is not valid.\n        \"\"\"\n        if len(hex_value) != 64:\n            raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n        if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n            raise ValueError(\"Hash must contain only hexadecimal characters\")\n        self._hex = hex_value.lower()\n\n    @classmethod\n    def from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n        \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n        Args:\n            canonical: The canonical string to hash.\n\n        Returns:\n            A CanonicalHash instance.\n        \"\"\"\n        hasher = hashlib.sha256()\n        hasher.update(canonical.encode(\"utf-8\"))\n        return cls(hasher.hexdigest())\n\n    @classmethod\n    def from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n        \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n        Args:\n            hex_value: A hexadecimal string.\n\n        Returns:\n            A CanonicalHash instance, or None if invalid.\n        \"\"\"\n        try:\n            return cls(hex_value)\n        except ValueError:\n            return None\n\n    def as_hex(self) -&gt; str:\n        \"\"\"Return the hash as a lowercase hex string.\"\"\"\n        return self._hex\n\n    def as_bytes(self) -&gt; bytes:\n        \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n        return bytes.fromhex(self._hex)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the hash.\"\"\"\n        return self._hex\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a detailed string representation of the hash.\"\"\"\n        return f\"CanonicalHash({self._hex!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n        if isinstance(other, CanonicalHash):\n            return self._hex == other._hex\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n        return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalHash instance.\"\"\"\n    if isinstance(other, CanonicalHash):\n        return self._hex == other._hex\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the CanonicalHash instance.\"\"\"\n    return hash(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__init__","title":"__init__","text":"<pre><code>__init__(hex_value: str) -&gt; None\n</code></pre> <p>Create a CanonicalHash from a hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A 64-character hexadecimal string.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not valid.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __init__(self, hex_value: str) -&gt; None:\n    \"\"\"Create a CanonicalHash from a hex string.\n\n    Args:\n        hex_value: A 64-character hexadecimal string.\n\n    Raises:\n        ValueError: If the string is not valid.\n    \"\"\"\n    if len(hex_value) != 64:\n        raise ValueError(f\"Hash must be 64 hex characters, got {len(hex_value)}\")\n    if not all(c in \"0123456789abcdefABCDEF\" for c in hex_value):\n        raise ValueError(\"Hash must contain only hexadecimal characters\")\n    self._hex = hex_value.lower()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a detailed string representation of the hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a detailed string representation of the hash.\"\"\"\n    return f\"CanonicalHash({self._hex!r})\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the hash.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.as_bytes","title":"as_bytes","text":"<pre><code>as_bytes() -&gt; bytes\n</code></pre> <p>Return the hash as bytes (32 bytes).</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def as_bytes(self) -&gt; bytes:\n    \"\"\"Return the hash as bytes (32 bytes).\"\"\"\n    return bytes.fromhex(self._hex)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Return the hash as a lowercase hex string.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>def as_hex(self) -&gt; str:\n    \"\"\"Return the hash as a lowercase hex string.\"\"\"\n    return self._hex\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.from_canonical_string","title":"from_canonical_string  <code>classmethod</code>","text":"<pre><code>from_canonical_string(canonical: str) -&gt; CanonicalHash\n</code></pre> <p>Compute the SHA-256 hash of the given canonical string.</p> <p>Parameters:</p> Name Type Description Default <code>canonical</code> <code>str</code> <p>The canonical string to hash.</p> required <p>Returns:</p> Type Description <code>CanonicalHash</code> <p>A CanonicalHash instance.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>@classmethod\ndef from_canonical_string(cls, canonical: str) -&gt; \"CanonicalHash\":\n    \"\"\"Compute the SHA-256 hash of the given canonical string.\n\n    Args:\n        canonical: The canonical string to hash.\n\n    Returns:\n        A CanonicalHash instance.\n    \"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(canonical.encode(\"utf-8\"))\n    return cls(hasher.hexdigest())\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.hash.CanonicalHash.from_hex","title":"from_hex  <code>classmethod</code>","text":"<pre><code>from_hex(hex_value: str) -&gt; Optional[CanonicalHash]\n</code></pre> <p>Create a CanonicalHash from a pre-computed hex string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>A hexadecimal string.</p> required <p>Returns:</p> Type Description <code>Optional[CanonicalHash]</code> <p>A CanonicalHash instance, or None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/hash.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex_value: str) -&gt; Optional[\"CanonicalHash\"]:\n    \"\"\"Create a CanonicalHash from a pre-computed hex string.\n\n    Args:\n        hex_value: A hexadecimal string.\n\n    Returns:\n        A CanonicalHash instance, or None if invalid.\n    \"\"\"\n    try:\n        return cls(hex_value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp","title":"timestamp","text":"<p>Canonical timestamp handling for CEP records.</p> <p>All CEP timestamps MUST be: - UTC timezone (indicated by 'Z' suffix) - ISO 8601 format - Microsecond precision (exactly 6 decimal places)</p> <p>Example: 2025-11-28T14:30:00.000000Z</p>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp","title":"CanonicalTimestamp","text":"<p>A canonical CEP timestamp with mandatory microsecond precision.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>class CanonicalTimestamp:\n    \"\"\"A canonical CEP timestamp with mandatory microsecond precision.\"\"\"\n\n    __slots__ = (\"_dt\",)\n\n    def __init__(self, dt: datetime) -&gt; None:\n        \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n        Args:\n            dt: A datetime object. If naive, assumed to be UTC.\n                If aware, will be converted to UTC.\n        \"\"\"\n        if dt.tzinfo is None:\n            # Naive datetime - assume UTC\n            self._dt = dt.replace(tzinfo=UTC)\n        else:\n            # Convert to UTC\n            self._dt = dt.astimezone(UTC)\n\n    @classmethod\n    def now(cls) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n        return cls(datetime.now(UTC))\n\n    @classmethod\n    def parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n        \"\"\"Parse an ISO 8601 timestamp string.\n\n        Accepts formats:\n        - 2025-11-28T14:30:00.123456Z\n        - 2025-11-28T14:30:00.123456+00:00\n        - 2025-11-28T14:30:00Z (will add .000000)\n\n        Args:\n            s: The timestamp string to parse.\n\n        Returns:\n            A CanonicalTimestamp instance.\n\n        Raises:\n            ValueError: If the string cannot be parsed.\n        \"\"\"\n        # Handle Z suffix\n        if s.endswith(\"Z\"):\n            s = s[:-1] + \"+00:00\"\n\n        # Try parsing with microseconds\n        try:\n            dt = datetime.fromisoformat(s)\n            return cls(dt)\n        except ValueError:\n            pass\n\n        # Try without microseconds and add them\n        try:\n            # Remove timezone for parsing, then add back\n            if \"+\" in s:\n                base, tz = s.rsplit(\"+\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n            if s.count(\"-\") &gt; 2:  # Has negative offset\n                base, tz = s.rsplit(\"-\", 1)\n                dt = datetime.fromisoformat(base)\n                dt = dt.replace(tzinfo=UTC)\n                return cls(dt)\n        except ValueError:\n            pass\n\n        raise ValueError(f\"Cannot parse timestamp: {s}\")\n\n    def as_datetime(self) -&gt; datetime:\n        \"\"\"Return the underlying datetime object (UTC).\"\"\"\n        return self._dt\n\n    def to_canonical_string(self) -&gt; str:\n        \"\"\"Return the canonical string representation.\n\n        Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n        This format is REQUIRED for hash stability across all CEP implementations.\n        \"\"\"\n        return self._dt.strftime(CANONICAL_FORMAT)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n        return self.to_canonical_string()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n        return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt == other._dt\n        return NotImplemented\n\n    def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt; other._dt\n        return NotImplemented\n\n    def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &lt;= other._dt\n        return NotImplemented\n\n    def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt; other._dt\n        return NotImplemented\n\n    def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n        \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n        if isinstance(other, CanonicalTimestamp):\n            return self._dt &gt;= other._dt\n        return NotImplemented\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the timestamp.\"\"\"\n        return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another CanonicalTimestamp.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt == other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than or equal to another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __ge__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is greater than another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __gt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is greater than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &gt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return the hash of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the timestamp.\"\"\"\n    return hash(self._dt)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__init__","title":"__init__","text":"<pre><code>__init__(dt: datetime) -&gt; None\n</code></pre> <p>Create a new CanonicalTimestamp from a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>A datetime object. If naive, assumed to be UTC. If aware, will be converted to UTC.</p> required Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __init__(self, dt: datetime) -&gt; None:\n    \"\"\"Create a new CanonicalTimestamp from a datetime.\n\n    Args:\n        dt: A datetime object. If naive, assumed to be UTC.\n            If aware, will be converted to UTC.\n    \"\"\"\n    if dt.tzinfo is None:\n        # Naive datetime - assume UTC\n        self._dt = dt.replace(tzinfo=UTC)\n    else:\n        # Convert to UTC\n        self._dt = dt.astimezone(UTC)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__le__","title":"__le__","text":"<pre><code>__le__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than or equal to another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __le__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than or equal to another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt;= other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: CanonicalTimestamp) -&gt; bool\n</code></pre> <p>Check if this timestamp is less than another.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __lt__(self, other: \"CanonicalTimestamp\") -&gt; bool:\n    \"\"\"Check if this timestamp is less than another.\"\"\"\n    if isinstance(other, CanonicalTimestamp):\n        return self._dt &lt; other._dt\n    return NotImplemented\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the developer-friendly representation of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the developer-friendly representation of the timestamp.\"\"\"\n    return f\"CanonicalTimestamp({self.to_canonical_string()!r})\"\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the canonical string representation of the timestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the canonical string representation of the timestamp.\"\"\"\n    return self.to_canonical_string()\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.as_datetime","title":"as_datetime","text":"<pre><code>as_datetime() -&gt; datetime\n</code></pre> <p>Return the underlying datetime object (UTC).</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def as_datetime(self) -&gt; datetime:\n    \"\"\"Return the underlying datetime object (UTC).\"\"\"\n    return self._dt\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.now","title":"now  <code>classmethod</code>","text":"<pre><code>now() -&gt; CanonicalTimestamp\n</code></pre> <p>Return the current UTC time as a CanonicalTimestamp.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Return the current UTC time as a CanonicalTimestamp.\"\"\"\n    return cls(datetime.now(UTC))\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(s: str) -&gt; CanonicalTimestamp\n</code></pre> <p>Parse an ISO 8601 timestamp string.</p> <p>Accepts formats: - 2025-11-28T14:30:00.123456Z - 2025-11-28T14:30:00.123456+00:00 - 2025-11-28T14:30:00Z (will add .000000)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The timestamp string to parse.</p> required <p>Returns:</p> Type Description <code>CanonicalTimestamp</code> <p>A CanonicalTimestamp instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string cannot be parsed.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>@classmethod\ndef parse(cls, s: str) -&gt; \"CanonicalTimestamp\":\n    \"\"\"Parse an ISO 8601 timestamp string.\n\n    Accepts formats:\n    - 2025-11-28T14:30:00.123456Z\n    - 2025-11-28T14:30:00.123456+00:00\n    - 2025-11-28T14:30:00Z (will add .000000)\n\n    Args:\n        s: The timestamp string to parse.\n\n    Returns:\n        A CanonicalTimestamp instance.\n\n    Raises:\n        ValueError: If the string cannot be parsed.\n    \"\"\"\n    # Handle Z suffix\n    if s.endswith(\"Z\"):\n        s = s[:-1] + \"+00:00\"\n\n    # Try parsing with microseconds\n    try:\n        dt = datetime.fromisoformat(s)\n        return cls(dt)\n    except ValueError:\n        pass\n\n    # Try without microseconds and add them\n    try:\n        # Remove timezone for parsing, then add back\n        if \"+\" in s:\n            base, tz = s.rsplit(\"+\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n        if s.count(\"-\") &gt; 2:  # Has negative offset\n            base, tz = s.rsplit(\"-\", 1)\n            dt = datetime.fromisoformat(base)\n            dt = dt.replace(tzinfo=UTC)\n            return cls(dt)\n    except ValueError:\n        pass\n\n    raise ValueError(f\"Cannot parse timestamp: {s}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.core.timestamp.CanonicalTimestamp.to_canonical_string","title":"to_canonical_string","text":"<pre><code>to_canonical_string() -&gt; str\n</code></pre> <p>Return the canonical string representation.</p> <p>Format: YYYY-MM-DDTHH:MM:SS.ffffffZ</p> <p>This format is REQUIRED for hash stability across all CEP implementations.</p> Source code in <code>src/python/src/civic_exchange_protocol/core/timestamp.py</code> <pre><code>def to_canonical_string(self) -&gt; str:\n    \"\"\"Return the canonical string representation.\n\n    Format: YYYY-MM-DDTHH:MM:SS.ffffffZ\n\n    This format is REQUIRED for hash stability across all CEP implementations.\n    \"\"\"\n    return self._dt.strftime(CANONICAL_FORMAT)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity","title":"entity","text":"<p>CEP Entity - Entity records for the Civic Exchange Protocol.</p> <p>This package defines the EntityRecord type, which represents a verified civic entity. Entities are the foundational primitive in CEP\u2014all relationships and exchanges reference attested entities.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.AdditionalScheme","title":"AdditionalScheme  <code>dataclass</code>","text":"<p>An additional identifier scheme not explicitly defined in the schema.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass\nclass AdditionalScheme:\n    \"\"\"An additional identifier scheme not explicitly defined in the schema.\"\"\"\n\n    scheme_uri: str\n    value: str\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.CanadianBn","title":"CanadianBn  <code>dataclass</code>","text":"<p>Canadian Business Number with program account.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass CanadianBn:\n    \"\"\"Canadian Business Number with program account.\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the Canadian BN format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid Canadian BN: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        # Pattern: 9 digits + 2 letters + 4 digits (e.g., 123456789RC0001)\n        if len(value) != 15:\n            return False\n        digits1 = value[:9]\n        letters = value[9:11]\n        digits2 = value[11:15]\n        return digits1.isdigit() and letters.isalpha() and letters.isupper() and digits2.isdigit()\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"CanadianBn\"]:\n        \"\"\"Create a new Canadian BN, returning None if invalid.\"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the Canadian BN as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.CanadianBn.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the Canadian BN format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the Canadian BN format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid Canadian BN: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.CanadianBn.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the Canadian BN as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the Canadian BN as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.CanadianBn.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[CanadianBn]\n</code></pre> <p>Create a new Canadian BN, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"CanadianBn\"]:\n    \"\"\"Create a new Canadian BN, returning None if invalid.\"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers","title":"EntityIdentifiers  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Collection of all known identifiers for an entity.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass\nclass EntityIdentifiers(Canonicalize):\n    \"\"\"Collection of all known identifiers for an entity.\"\"\"\n\n    sam_uei: SamUei | None = None\n    lei: Lei | None = None\n    snfei: Snfei | None = None\n    canadian_bn: CanadianBn | None = None\n    additional_schemes: list[AdditionalScheme] | None = None\n\n    def with_sam_uei(self, uei: SamUei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the SAM UEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=uei,\n            lei=self.lei,\n            snfei=self.snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def with_lei(self, lei: Lei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the LEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=self.sam_uei,\n            lei=lei,\n            snfei=self.snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def with_snfei(self, snfei: Snfei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the SNFEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=self.sam_uei,\n            lei=self.lei,\n            snfei=snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if at least one identifier is present.\"\"\"\n        return (\n            self.sam_uei is not None\n            or self.lei is not None\n            or self.snfei is not None\n            or self.canadian_bn is not None\n            or (self.additional_schemes is not None and len(self.additional_schemes) &gt; 0)\n        )\n\n    def primary_identifier(self) -&gt; str | None:\n        \"\"\"Return the 'best' identifier for use as the verifiable ID.\n\n        Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional\n        \"\"\"\n        if self.lei is not None:\n            return f\"cep-entity:lei:{self.lei.as_str()}\"\n        if self.sam_uei is not None:\n            return f\"cep-entity:sam-uei:{self.sam_uei.as_str()}\"\n        if self.snfei is not None:\n            return f\"cep-entity:snfei:{self.snfei.as_str()}\"\n        if self.canadian_bn is not None:\n            return f\"cep-entity:canadian-bn:{self.canadian_bn.as_str()}\"\n        if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n            return f\"cep-entity:other:{self.additional_schemes[0].value}\"\n        return None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Additional schemes serialized as JSON array string\n        if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n            sorted_schemes = sorted(self.additional_schemes, key=lambda x: x.scheme_uri)\n            schemes_data = [{\"schemeUri\": s.scheme_uri, \"value\": s.value} for s in sorted_schemes]\n            fields[\"additionalSchemes\"] = json.dumps(schemes_data, separators=(\",\", \":\"))\n\n        insert_if_present(\n            fields, \"canadianBn\", self.canadian_bn.as_str() if self.canadian_bn else None\n        )\n        insert_if_present(fields, \"lei\", self.lei.as_str() if self.lei else None)\n        insert_if_present(fields, \"samUei\", self.sam_uei.as_str() if self.sam_uei else None)\n        insert_if_present(fields, \"snfei\", self.snfei.as_str() if self.snfei else None)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Additional schemes serialized as JSON array string\n    if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n        sorted_schemes = sorted(self.additional_schemes, key=lambda x: x.scheme_uri)\n        schemes_data = [{\"schemeUri\": s.scheme_uri, \"value\": s.value} for s in sorted_schemes]\n        fields[\"additionalSchemes\"] = json.dumps(schemes_data, separators=(\",\", \":\"))\n\n    insert_if_present(\n        fields, \"canadianBn\", self.canadian_bn.as_str() if self.canadian_bn else None\n    )\n    insert_if_present(fields, \"lei\", self.lei.as_str() if self.lei else None)\n    insert_if_present(fields, \"samUei\", self.sam_uei.as_str() if self.sam_uei else None)\n    insert_if_present(fields, \"snfei\", self.snfei.as_str() if self.snfei else None)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if at least one identifier is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if at least one identifier is present.\"\"\"\n    return (\n        self.sam_uei is not None\n        or self.lei is not None\n        or self.snfei is not None\n        or self.canadian_bn is not None\n        or (self.additional_schemes is not None and len(self.additional_schemes) &gt; 0)\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.primary_identifier","title":"primary_identifier","text":"<pre><code>primary_identifier() -&gt; str | None\n</code></pre> <p>Return the 'best' identifier for use as the verifiable ID.</p> <p>Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def primary_identifier(self) -&gt; str | None:\n    \"\"\"Return the 'best' identifier for use as the verifiable ID.\n\n    Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional\n    \"\"\"\n    if self.lei is not None:\n        return f\"cep-entity:lei:{self.lei.as_str()}\"\n    if self.sam_uei is not None:\n        return f\"cep-entity:sam-uei:{self.sam_uei.as_str()}\"\n    if self.snfei is not None:\n        return f\"cep-entity:snfei:{self.snfei.as_str()}\"\n    if self.canadian_bn is not None:\n        return f\"cep-entity:canadian-bn:{self.canadian_bn.as_str()}\"\n    if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n        return f\"cep-entity:other:{self.additional_schemes[0].value}\"\n    return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.with_lei","title":"with_lei","text":"<pre><code>with_lei(lei: Lei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the LEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_lei(self, lei: Lei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the LEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=self.sam_uei,\n        lei=lei,\n        snfei=self.snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.with_sam_uei","title":"with_sam_uei","text":"<pre><code>with_sam_uei(uei: SamUei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the SAM UEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_sam_uei(self, uei: SamUei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the SAM UEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=uei,\n        lei=self.lei,\n        snfei=self.snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityIdentifiers.with_snfei","title":"with_snfei","text":"<pre><code>with_snfei(snfei: Snfei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the SNFEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_snfei(self, snfei: Snfei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the SNFEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=self.sam_uei,\n        lei=self.lei,\n        snfei=snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord","title":"EntityRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Entity Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass EntityRecord(Canonicalize):\n    \"\"\"A complete CEP Entity Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    identifiers: EntityIdentifiers\n    legal_name: str\n    jurisdiction_iso: str\n    status: EntityStatus\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    legal_name_normalized: str | None = None\n    entity_type_uri: str | None = None\n    naics_code: str | None = None\n    resolution_confidence: ResolutionConfidence | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new(\n        cls,\n        verifiable_id: str,\n        identifiers: EntityIdentifiers,\n        legal_name: str,\n        jurisdiction_iso: str,\n        status: EntityStatus,\n        attestation: Attestation,\n    ) -&gt; \"EntityRecord\":\n        \"\"\"Create a new EntityRecord with required fields.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            identifiers=identifiers,\n            legal_name=legal_name,\n            jurisdiction_iso=jurisdiction_iso,\n            status=status,\n            attestation=attestation,\n        )\n\n    def with_normalized_name(self, name: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the normalized name set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=name,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_entity_type(self, uri: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the entity type URI set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_naics(self, code: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the NAICS code set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_resolution_confidence(self, confidence: ResolutionConfidence) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with resolution confidence set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the previous hash set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the revision number set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate that the record has all required fields properly set.\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        if self.schema_version != SCHEMA_VERSION:\n            raise ValueError(f\"Unsupported schema version: {self.schema_version}\")\n        if not self.verifiable_id:\n            raise ValueError(\"verifiableId is required\")\n        if not self.identifiers.has_any():\n            raise ValueError(\"At least one identifier is required\")\n        if not self.legal_name:\n            raise ValueError(\"legalName is required\")\n        if not self.jurisdiction_iso:\n            raise ValueError(\"jurisdictionIso is required\")\n        if self.revision_number &lt; 1:\n            raise ValueError(\"revisionNumber must be &gt;= 1\")\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n        insert_if_present(fields, \"entityTypeUri\", self.entity_type_uri)\n\n        # Identifiers is a nested object\n        identifiers_canonical = self.identifiers.to_canonical_string()\n        if identifiers_canonical:\n            insert_required(fields, \"identifiers\", identifiers_canonical)\n\n        insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n        insert_required(fields, \"legalName\", self.legal_name)\n        insert_if_present(fields, \"legalNameNormalized\", self.legal_name_normalized)\n        insert_if_present(fields, \"naicsCode\", self.naics_code)\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n        # Resolution confidence is a nested object\n        if self.resolution_confidence is not None:\n            insert_required(\n                fields, \"resolutionConfidence\", self.resolution_confidence.to_canonical_string()\n            )\n\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Status is a nested object\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n    insert_if_present(fields, \"entityTypeUri\", self.entity_type_uri)\n\n    # Identifiers is a nested object\n    identifiers_canonical = self.identifiers.to_canonical_string()\n    if identifiers_canonical:\n        insert_required(fields, \"identifiers\", identifiers_canonical)\n\n    insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n    insert_required(fields, \"legalName\", self.legal_name)\n    insert_if_present(fields, \"legalNameNormalized\", self.legal_name_normalized)\n    insert_if_present(fields, \"naicsCode\", self.naics_code)\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n    # Resolution confidence is a nested object\n    if self.resolution_confidence is not None:\n        insert_required(\n            fields, \"resolutionConfidence\", self.resolution_confidence.to_canonical_string()\n        )\n\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Status is a nested object\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    verifiable_id: str,\n    identifiers: EntityIdentifiers,\n    legal_name: str,\n    jurisdiction_iso: str,\n    status: EntityStatus,\n    attestation: Attestation,\n) -&gt; EntityRecord\n</code></pre> <p>Create a new EntityRecord with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    verifiable_id: str,\n    identifiers: EntityIdentifiers,\n    legal_name: str,\n    jurisdiction_iso: str,\n    status: EntityStatus,\n    attestation: Attestation,\n) -&gt; \"EntityRecord\":\n    \"\"\"Create a new EntityRecord with required fields.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        identifiers=identifiers,\n        legal_name=legal_name,\n        jurisdiction_iso=jurisdiction_iso,\n        status=status,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate that the record has all required fields properly set.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate that the record has all required fields properly set.\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    if self.schema_version != SCHEMA_VERSION:\n        raise ValueError(f\"Unsupported schema version: {self.schema_version}\")\n    if not self.verifiable_id:\n        raise ValueError(\"verifiableId is required\")\n    if not self.identifiers.has_any():\n        raise ValueError(\"At least one identifier is required\")\n    if not self.legal_name:\n        raise ValueError(\"legalName is required\")\n    if not self.jurisdiction_iso:\n        raise ValueError(\"jurisdictionIso is required\")\n    if self.revision_number &lt; 1:\n        raise ValueError(\"revisionNumber must be &gt;= 1\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_entity_type","title":"with_entity_type","text":"<pre><code>with_entity_type(uri: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the entity type URI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_entity_type(self, uri: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the entity type URI set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_naics","title":"with_naics","text":"<pre><code>with_naics(code: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the NAICS code set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_naics(self, code: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the NAICS code set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_normalized_name","title":"with_normalized_name","text":"<pre><code>with_normalized_name(name: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the normalized name set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_normalized_name(self, name: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the normalized name set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=name,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(hash_val: CanonicalHash) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the previous hash set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_resolution_confidence","title":"with_resolution_confidence","text":"<pre><code>with_resolution_confidence(\n    confidence: ResolutionConfidence,\n) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with resolution confidence set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_resolution_confidence(self, confidence: ResolutionConfidence) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with resolution confidence set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the revision number set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatus","title":"EntityStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Entity status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass EntityStatus(Canonicalize):\n    \"\"\"Entity status information.\"\"\"\n\n    status_code: EntityStatusCode\n    status_effective_date: str  # YYYY-MM-DD format\n    status_termination_date: str | None = None\n    successor_entity_id: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for entity status.\n\n        Returns:\n        dict[str, str]\n            A dictionary containing the canonical representation of status fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(fields, \"statusEffectiveDate\", self.status_effective_date)\n        insert_if_present(fields, \"statusTerminationDate\", self.status_termination_date)\n        insert_if_present(fields, \"successorEntityId\", self.successor_entity_id)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for entity status.</p> <p>dict[str, str]     A dictionary containing the canonical representation of status fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for entity status.\n\n    Returns:\n    dict[str, str]\n        A dictionary containing the canonical representation of status fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(fields, \"statusEffectiveDate\", self.status_effective_date)\n    insert_if_present(fields, \"statusTerminationDate\", self.status_termination_date)\n    insert_if_present(fields, \"successorEntityId\", self.successor_entity_id)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatusCode","title":"EntityStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Entity operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>class EntityStatusCode(Enum):\n    \"\"\"Entity operational status.\"\"\"\n\n    ACTIVE = \"ACTIVE\"\n    INACTIVE = \"INACTIVE\"\n    SUSPENDED = \"SUSPENDED\"\n    DISSOLVED = \"DISSOLVED\"\n    MERGED = \"MERGED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string representation of the status code.\n\n        Returns:\n        -------\n        str\n            The status code value as a string.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string representation of the status code.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.EntityStatusCode.as_str--returns","title":"Returns:","text":"<p>str     The status code value as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string representation of the status code.\n\n    Returns:\n    -------\n    str\n        The status code value as a string.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Lei","title":"Lei  <code>dataclass</code>","text":"<p>Legal Entity Identifier per ISO 17442 (20 alphanumeric characters).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass Lei:\n    \"\"\"Legal Entity Identifier per ISO 17442 (20 alphanumeric characters).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the LEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid LEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return len(value) == 20 and value.isalnum()\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"Lei\"]:\n        \"\"\"Create a new LEI, returning None if invalid.\"\"\"\n        try:\n            return cls(value.upper())\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the LEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Lei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the LEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the LEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid LEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Lei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the LEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the LEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Lei.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[Lei]\n</code></pre> <p>Create a new LEI, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"Lei\"]:\n    \"\"\"Create a new LEI, returning None if invalid.\"\"\"\n    try:\n        return cls(value.upper())\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.ResolutionConfidence","title":"ResolutionConfidence  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Entity resolution confidence metadata.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass ResolutionConfidence(Canonicalize):\n    \"\"\"Entity resolution confidence metadata.\"\"\"\n\n    score: float  # 0.0 to 1.0\n    method_uri: str | None = None\n    source_record_count: int | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for resolution confidence.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical representation of resolution confidence fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"methodUri\", self.method_uri)\n        # Score formatted to 2 decimal places\n        insert_required(fields, \"score\", f\"{self.score:.2f}\")\n        if self.source_record_count is not None:\n            insert_required(fields, \"sourceRecordCount\", str(self.source_record_count))\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.ResolutionConfidence.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for resolution confidence.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.ResolutionConfidence.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical representation of resolution confidence fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for resolution confidence.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical representation of resolution confidence fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"methodUri\", self.method_uri)\n    # Score formatted to 2 decimal places\n    insert_required(fields, \"score\", f\"{self.score:.2f}\")\n    if self.source_record_count is not None:\n        insert_required(fields, \"sourceRecordCount\", str(self.source_record_count))\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.SamUei","title":"SamUei  <code>dataclass</code>","text":"<p>SAM.gov Unique Entity Identifier (12 alphanumeric characters).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass SamUei:\n    \"\"\"SAM.gov Unique Entity Identifier (12 alphanumeric characters).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the SAM UEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid SAM UEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return (\n            len(value) == 12 and all(c.isupper() or c.isdigit() for c in value) and value.isalnum()\n        )\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"SamUei\"]:\n        \"\"\"Create a new SAM UEI, returning None if invalid.\"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the SAM UEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.SamUei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the SAM UEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the SAM UEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid SAM UEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.SamUei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the SAM UEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the SAM UEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.SamUei.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[SamUei]\n</code></pre> <p>Create a new SAM UEI, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"SamUei\"]:\n    \"\"\"Create a new SAM UEI, returning None if invalid.\"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei","title":"Snfei  <code>dataclass</code>","text":"<p>Sub-National Federated Entity Identifier (64-character hex hash).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass Snfei:\n    \"\"\"Sub-National Federated Entity Identifier (64-character hex hash).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the SNFEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid SNFEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return len(value) == 64 and all(c in \"0123456789abcdef\" for c in value.lower())\n\n    @classmethod\n    def from_hash(cls, hash_value: str) -&gt; Optional[\"Snfei\"]:\n        \"\"\"Create an SNFEI from a pre-computed hash.\"\"\"\n        try:\n            return cls(hash_value.lower())\n        except ValueError:\n            return None\n\n    @classmethod\n    def generate(cls, normalized_name: str, jurisdiction_iso: str) -&gt; \"Snfei\":\n        \"\"\"Generate an SNFEI from a normalized name and jurisdiction.\"\"\"\n        input_str = f\"{normalized_name}|{jurisdiction_iso}\"\n        hash_value = hashlib.sha256(input_str.encode(\"utf-8\")).hexdigest()\n        return cls(hash_value)\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the SNFEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the SNFEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the SNFEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid SNFEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the SNFEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the SNFEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.from_hash","title":"from_hash  <code>classmethod</code>","text":"<pre><code>from_hash(hash_value: str) -&gt; Optional[Snfei]\n</code></pre> <p>Create an SNFEI from a pre-computed hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef from_hash(cls, hash_value: str) -&gt; Optional[\"Snfei\"]:\n    \"\"\"Create an SNFEI from a pre-computed hash.\"\"\"\n    try:\n        return cls(hash_value.lower())\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.Snfei.generate","title":"generate  <code>classmethod</code>","text":"<pre><code>generate(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; Snfei\n</code></pre> <p>Generate an SNFEI from a normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef generate(cls, normalized_name: str, jurisdiction_iso: str) -&gt; \"Snfei\":\n    \"\"\"Generate an SNFEI from a normalized name and jurisdiction.\"\"\"\n    input_str = f\"{normalized_name}|{jurisdiction_iso}\"\n    hash_value = hashlib.sha256(input_str.encode(\"utf-8\")).hexdigest()\n    return cls(hash_value)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity","title":"entity","text":"<p>CEP Entity Record definition.</p> <p>The Entity Record is the foundational primitive in CEP. It represents a verified civic entity (government agency, contractor, nonprofit, individual). All relationships and exchanges reference attested entities.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord","title":"EntityRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Entity Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass EntityRecord(Canonicalize):\n    \"\"\"A complete CEP Entity Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    identifiers: EntityIdentifiers\n    legal_name: str\n    jurisdiction_iso: str\n    status: EntityStatus\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    legal_name_normalized: str | None = None\n    entity_type_uri: str | None = None\n    naics_code: str | None = None\n    resolution_confidence: ResolutionConfidence | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new(\n        cls,\n        verifiable_id: str,\n        identifiers: EntityIdentifiers,\n        legal_name: str,\n        jurisdiction_iso: str,\n        status: EntityStatus,\n        attestation: Attestation,\n    ) -&gt; \"EntityRecord\":\n        \"\"\"Create a new EntityRecord with required fields.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            identifiers=identifiers,\n            legal_name=legal_name,\n            jurisdiction_iso=jurisdiction_iso,\n            status=status,\n            attestation=attestation,\n        )\n\n    def with_normalized_name(self, name: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the normalized name set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=name,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_entity_type(self, uri: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the entity type URI set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_naics(self, code: str) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the NAICS code set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_resolution_confidence(self, confidence: ResolutionConfidence) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with resolution confidence set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the previous hash set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"EntityRecord\":\n        \"\"\"Return a new EntityRecord with the revision number set.\"\"\"\n        return EntityRecord(\n            verifiable_id=self.verifiable_id,\n            identifiers=self.identifiers,\n            legal_name=self.legal_name,\n            jurisdiction_iso=self.jurisdiction_iso,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            legal_name_normalized=self.legal_name_normalized,\n            entity_type_uri=self.entity_type_uri,\n            naics_code=self.naics_code,\n            resolution_confidence=self.resolution_confidence,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate that the record has all required fields properly set.\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        if self.schema_version != SCHEMA_VERSION:\n            raise ValueError(f\"Unsupported schema version: {self.schema_version}\")\n        if not self.verifiable_id:\n            raise ValueError(\"verifiableId is required\")\n        if not self.identifiers.has_any():\n            raise ValueError(\"At least one identifier is required\")\n        if not self.legal_name:\n            raise ValueError(\"legalName is required\")\n        if not self.jurisdiction_iso:\n            raise ValueError(\"jurisdictionIso is required\")\n        if self.revision_number &lt; 1:\n            raise ValueError(\"revisionNumber must be &gt;= 1\")\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n        insert_if_present(fields, \"entityTypeUri\", self.entity_type_uri)\n\n        # Identifiers is a nested object\n        identifiers_canonical = self.identifiers.to_canonical_string()\n        if identifiers_canonical:\n            insert_required(fields, \"identifiers\", identifiers_canonical)\n\n        insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n        insert_required(fields, \"legalName\", self.legal_name)\n        insert_if_present(fields, \"legalNameNormalized\", self.legal_name_normalized)\n        insert_if_present(fields, \"naicsCode\", self.naics_code)\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n        # Resolution confidence is a nested object\n        if self.resolution_confidence is not None:\n            insert_required(\n                fields, \"resolutionConfidence\", self.resolution_confidence.to_canonical_string()\n            )\n\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Status is a nested object\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n    insert_if_present(fields, \"entityTypeUri\", self.entity_type_uri)\n\n    # Identifiers is a nested object\n    identifiers_canonical = self.identifiers.to_canonical_string()\n    if identifiers_canonical:\n        insert_required(fields, \"identifiers\", identifiers_canonical)\n\n    insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n    insert_required(fields, \"legalName\", self.legal_name)\n    insert_if_present(fields, \"legalNameNormalized\", self.legal_name_normalized)\n    insert_if_present(fields, \"naicsCode\", self.naics_code)\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n    # Resolution confidence is a nested object\n    if self.resolution_confidence is not None:\n        insert_required(\n            fields, \"resolutionConfidence\", self.resolution_confidence.to_canonical_string()\n        )\n\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Status is a nested object\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    verifiable_id: str,\n    identifiers: EntityIdentifiers,\n    legal_name: str,\n    jurisdiction_iso: str,\n    status: EntityStatus,\n    attestation: Attestation,\n) -&gt; EntityRecord\n</code></pre> <p>Create a new EntityRecord with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    verifiable_id: str,\n    identifiers: EntityIdentifiers,\n    legal_name: str,\n    jurisdiction_iso: str,\n    status: EntityStatus,\n    attestation: Attestation,\n) -&gt; \"EntityRecord\":\n    \"\"\"Create a new EntityRecord with required fields.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        identifiers=identifiers,\n        legal_name=legal_name,\n        jurisdiction_iso=jurisdiction_iso,\n        status=status,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate that the record has all required fields properly set.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate that the record has all required fields properly set.\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    if self.schema_version != SCHEMA_VERSION:\n        raise ValueError(f\"Unsupported schema version: {self.schema_version}\")\n    if not self.verifiable_id:\n        raise ValueError(\"verifiableId is required\")\n    if not self.identifiers.has_any():\n        raise ValueError(\"At least one identifier is required\")\n    if not self.legal_name:\n        raise ValueError(\"legalName is required\")\n    if not self.jurisdiction_iso:\n        raise ValueError(\"jurisdictionIso is required\")\n    if self.revision_number &lt; 1:\n        raise ValueError(\"revisionNumber must be &gt;= 1\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_entity_type","title":"with_entity_type","text":"<pre><code>with_entity_type(uri: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the entity type URI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_entity_type(self, uri: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the entity type URI set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_naics","title":"with_naics","text":"<pre><code>with_naics(code: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the NAICS code set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_naics(self, code: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the NAICS code set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_normalized_name","title":"with_normalized_name","text":"<pre><code>with_normalized_name(name: str) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the normalized name set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_normalized_name(self, name: str) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the normalized name set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=name,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(hash_val: CanonicalHash) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the previous hash set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_resolution_confidence","title":"with_resolution_confidence","text":"<pre><code>with_resolution_confidence(\n    confidence: ResolutionConfidence,\n) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with resolution confidence set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_resolution_confidence(self, confidence: ResolutionConfidence) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with resolution confidence set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; EntityRecord\n</code></pre> <p>Return a new EntityRecord with the revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"EntityRecord\":\n    \"\"\"Return a new EntityRecord with the revision number set.\"\"\"\n    return EntityRecord(\n        verifiable_id=self.verifiable_id,\n        identifiers=self.identifiers,\n        legal_name=self.legal_name,\n        jurisdiction_iso=self.jurisdiction_iso,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        legal_name_normalized=self.legal_name_normalized,\n        entity_type_uri=self.entity_type_uri,\n        naics_code=self.naics_code,\n        resolution_confidence=self.resolution_confidence,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatus","title":"EntityStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Entity status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass EntityStatus(Canonicalize):\n    \"\"\"Entity status information.\"\"\"\n\n    status_code: EntityStatusCode\n    status_effective_date: str  # YYYY-MM-DD format\n    status_termination_date: str | None = None\n    successor_entity_id: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for entity status.\n\n        Returns:\n        dict[str, str]\n            A dictionary containing the canonical representation of status fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(fields, \"statusEffectiveDate\", self.status_effective_date)\n        insert_if_present(fields, \"statusTerminationDate\", self.status_termination_date)\n        insert_if_present(fields, \"successorEntityId\", self.successor_entity_id)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for entity status.</p> <p>dict[str, str]     A dictionary containing the canonical representation of status fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for entity status.\n\n    Returns:\n    dict[str, str]\n        A dictionary containing the canonical representation of status fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(fields, \"statusEffectiveDate\", self.status_effective_date)\n    insert_if_present(fields, \"statusTerminationDate\", self.status_termination_date)\n    insert_if_present(fields, \"successorEntityId\", self.successor_entity_id)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatusCode","title":"EntityStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Entity operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>class EntityStatusCode(Enum):\n    \"\"\"Entity operational status.\"\"\"\n\n    ACTIVE = \"ACTIVE\"\n    INACTIVE = \"INACTIVE\"\n    SUSPENDED = \"SUSPENDED\"\n    DISSOLVED = \"DISSOLVED\"\n    MERGED = \"MERGED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string representation of the status code.\n\n        Returns:\n        -------\n        str\n            The status code value as a string.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string representation of the status code.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.EntityStatusCode.as_str--returns","title":"Returns:","text":"<p>str     The status code value as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string representation of the status code.\n\n    Returns:\n    -------\n    str\n        The status code value as a string.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.ResolutionConfidence","title":"ResolutionConfidence  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Entity resolution confidence metadata.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>@dataclass\nclass ResolutionConfidence(Canonicalize):\n    \"\"\"Entity resolution confidence metadata.\"\"\"\n\n    score: float  # 0.0 to 1.0\n    method_uri: str | None = None\n    source_record_count: int | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for resolution confidence.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical representation of resolution confidence fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"methodUri\", self.method_uri)\n        # Score formatted to 2 decimal places\n        insert_required(fields, \"score\", f\"{self.score:.2f}\")\n        if self.source_record_count is not None:\n            insert_required(fields, \"sourceRecordCount\", str(self.source_record_count))\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.ResolutionConfidence.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for resolution confidence.</p>"},{"location":"en/api/#civic_exchange_protocol.entity.entity.ResolutionConfidence.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical representation of resolution confidence fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/entity.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for resolution confidence.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical representation of resolution confidence fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"methodUri\", self.method_uri)\n    # Score formatted to 2 decimal places\n    insert_required(fields, \"score\", f\"{self.score:.2f}\")\n    if self.source_record_count is not None:\n        insert_required(fields, \"sourceRecordCount\", str(self.source_record_count))\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers","title":"identifiers","text":"<p>Entity identifier types for CEP.</p> <p>CEP supports multiple identifier schemes organized into tiers:</p> <ul> <li>Tier 1 (Global): LEI (Legal Entity Identifier)</li> <li>Tier 2 (Federal): SAM.gov UEI</li> <li>Tier 3 (Sub-National): SNFEI (generated hash-based identifier)</li> <li>Extended: Canadian BN, UK Companies House, etc.</li> </ul>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.AdditionalScheme","title":"AdditionalScheme  <code>dataclass</code>","text":"<p>An additional identifier scheme not explicitly defined in the schema.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass\nclass AdditionalScheme:\n    \"\"\"An additional identifier scheme not explicitly defined in the schema.\"\"\"\n\n    scheme_uri: str\n    value: str\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.CanadianBn","title":"CanadianBn  <code>dataclass</code>","text":"<p>Canadian Business Number with program account.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass CanadianBn:\n    \"\"\"Canadian Business Number with program account.\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the Canadian BN format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid Canadian BN: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        # Pattern: 9 digits + 2 letters + 4 digits (e.g., 123456789RC0001)\n        if len(value) != 15:\n            return False\n        digits1 = value[:9]\n        letters = value[9:11]\n        digits2 = value[11:15]\n        return digits1.isdigit() and letters.isalpha() and letters.isupper() and digits2.isdigit()\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"CanadianBn\"]:\n        \"\"\"Create a new Canadian BN, returning None if invalid.\"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the Canadian BN as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.CanadianBn.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the Canadian BN format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the Canadian BN format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid Canadian BN: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.CanadianBn.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the Canadian BN as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the Canadian BN as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.CanadianBn.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[CanadianBn]\n</code></pre> <p>Create a new Canadian BN, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"CanadianBn\"]:\n    \"\"\"Create a new Canadian BN, returning None if invalid.\"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers","title":"EntityIdentifiers  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Collection of all known identifiers for an entity.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass\nclass EntityIdentifiers(Canonicalize):\n    \"\"\"Collection of all known identifiers for an entity.\"\"\"\n\n    sam_uei: SamUei | None = None\n    lei: Lei | None = None\n    snfei: Snfei | None = None\n    canadian_bn: CanadianBn | None = None\n    additional_schemes: list[AdditionalScheme] | None = None\n\n    def with_sam_uei(self, uei: SamUei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the SAM UEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=uei,\n            lei=self.lei,\n            snfei=self.snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def with_lei(self, lei: Lei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the LEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=self.sam_uei,\n            lei=lei,\n            snfei=self.snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def with_snfei(self, snfei: Snfei) -&gt; \"EntityIdentifiers\":\n        \"\"\"Return a new EntityIdentifiers with the SNFEI set.\"\"\"\n        return EntityIdentifiers(\n            sam_uei=self.sam_uei,\n            lei=self.lei,\n            snfei=snfei,\n            canadian_bn=self.canadian_bn,\n            additional_schemes=self.additional_schemes,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if at least one identifier is present.\"\"\"\n        return (\n            self.sam_uei is not None\n            or self.lei is not None\n            or self.snfei is not None\n            or self.canadian_bn is not None\n            or (self.additional_schemes is not None and len(self.additional_schemes) &gt; 0)\n        )\n\n    def primary_identifier(self) -&gt; str | None:\n        \"\"\"Return the 'best' identifier for use as the verifiable ID.\n\n        Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional\n        \"\"\"\n        if self.lei is not None:\n            return f\"cep-entity:lei:{self.lei.as_str()}\"\n        if self.sam_uei is not None:\n            return f\"cep-entity:sam-uei:{self.sam_uei.as_str()}\"\n        if self.snfei is not None:\n            return f\"cep-entity:snfei:{self.snfei.as_str()}\"\n        if self.canadian_bn is not None:\n            return f\"cep-entity:canadian-bn:{self.canadian_bn.as_str()}\"\n        if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n            return f\"cep-entity:other:{self.additional_schemes[0].value}\"\n        return None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Additional schemes serialized as JSON array string\n        if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n            sorted_schemes = sorted(self.additional_schemes, key=lambda x: x.scheme_uri)\n            schemes_data = [{\"schemeUri\": s.scheme_uri, \"value\": s.value} for s in sorted_schemes]\n            fields[\"additionalSchemes\"] = json.dumps(schemes_data, separators=(\",\", \":\"))\n\n        insert_if_present(\n            fields, \"canadianBn\", self.canadian_bn.as_str() if self.canadian_bn else None\n        )\n        insert_if_present(fields, \"lei\", self.lei.as_str() if self.lei else None)\n        insert_if_present(fields, \"samUei\", self.sam_uei.as_str() if self.sam_uei else None)\n        insert_if_present(fields, \"snfei\", self.snfei.as_str() if self.snfei else None)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Additional schemes serialized as JSON array string\n    if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n        sorted_schemes = sorted(self.additional_schemes, key=lambda x: x.scheme_uri)\n        schemes_data = [{\"schemeUri\": s.scheme_uri, \"value\": s.value} for s in sorted_schemes]\n        fields[\"additionalSchemes\"] = json.dumps(schemes_data, separators=(\",\", \":\"))\n\n    insert_if_present(\n        fields, \"canadianBn\", self.canadian_bn.as_str() if self.canadian_bn else None\n    )\n    insert_if_present(fields, \"lei\", self.lei.as_str() if self.lei else None)\n    insert_if_present(fields, \"samUei\", self.sam_uei.as_str() if self.sam_uei else None)\n    insert_if_present(fields, \"snfei\", self.snfei.as_str() if self.snfei else None)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if at least one identifier is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if at least one identifier is present.\"\"\"\n    return (\n        self.sam_uei is not None\n        or self.lei is not None\n        or self.snfei is not None\n        or self.canadian_bn is not None\n        or (self.additional_schemes is not None and len(self.additional_schemes) &gt; 0)\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.primary_identifier","title":"primary_identifier","text":"<pre><code>primary_identifier() -&gt; str | None\n</code></pre> <p>Return the 'best' identifier for use as the verifiable ID.</p> <p>Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def primary_identifier(self) -&gt; str | None:\n    \"\"\"Return the 'best' identifier for use as the verifiable ID.\n\n    Priority: LEI &gt; SAM UEI &gt; SNFEI &gt; Canadian BN &gt; first additional\n    \"\"\"\n    if self.lei is not None:\n        return f\"cep-entity:lei:{self.lei.as_str()}\"\n    if self.sam_uei is not None:\n        return f\"cep-entity:sam-uei:{self.sam_uei.as_str()}\"\n    if self.snfei is not None:\n        return f\"cep-entity:snfei:{self.snfei.as_str()}\"\n    if self.canadian_bn is not None:\n        return f\"cep-entity:canadian-bn:{self.canadian_bn.as_str()}\"\n    if self.additional_schemes and len(self.additional_schemes) &gt; 0:\n        return f\"cep-entity:other:{self.additional_schemes[0].value}\"\n    return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.with_lei","title":"with_lei","text":"<pre><code>with_lei(lei: Lei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the LEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_lei(self, lei: Lei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the LEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=self.sam_uei,\n        lei=lei,\n        snfei=self.snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.with_sam_uei","title":"with_sam_uei","text":"<pre><code>with_sam_uei(uei: SamUei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the SAM UEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_sam_uei(self, uei: SamUei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the SAM UEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=uei,\n        lei=self.lei,\n        snfei=self.snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.EntityIdentifiers.with_snfei","title":"with_snfei","text":"<pre><code>with_snfei(snfei: Snfei) -&gt; EntityIdentifiers\n</code></pre> <p>Return a new EntityIdentifiers with the SNFEI set.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def with_snfei(self, snfei: Snfei) -&gt; \"EntityIdentifiers\":\n    \"\"\"Return a new EntityIdentifiers with the SNFEI set.\"\"\"\n    return EntityIdentifiers(\n        sam_uei=self.sam_uei,\n        lei=self.lei,\n        snfei=snfei,\n        canadian_bn=self.canadian_bn,\n        additional_schemes=self.additional_schemes,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Lei","title":"Lei  <code>dataclass</code>","text":"<p>Legal Entity Identifier per ISO 17442 (20 alphanumeric characters).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass Lei:\n    \"\"\"Legal Entity Identifier per ISO 17442 (20 alphanumeric characters).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the LEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid LEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return len(value) == 20 and value.isalnum()\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"Lei\"]:\n        \"\"\"Create a new LEI, returning None if invalid.\"\"\"\n        try:\n            return cls(value.upper())\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the LEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Lei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the LEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the LEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid LEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Lei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the LEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the LEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Lei.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[Lei]\n</code></pre> <p>Create a new LEI, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"Lei\"]:\n    \"\"\"Create a new LEI, returning None if invalid.\"\"\"\n    try:\n        return cls(value.upper())\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.SamUei","title":"SamUei  <code>dataclass</code>","text":"<p>SAM.gov Unique Entity Identifier (12 alphanumeric characters).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass SamUei:\n    \"\"\"SAM.gov Unique Entity Identifier (12 alphanumeric characters).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the SAM UEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid SAM UEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return (\n            len(value) == 12 and all(c.isupper() or c.isdigit() for c in value) and value.isalnum()\n        )\n\n    @classmethod\n    def new(cls, value: str) -&gt; Optional[\"SamUei\"]:\n        \"\"\"Create a new SAM UEI, returning None if invalid.\"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            return None\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the SAM UEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.SamUei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the SAM UEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the SAM UEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid SAM UEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.SamUei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the SAM UEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the SAM UEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.SamUei.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(value: str) -&gt; Optional[SamUei]\n</code></pre> <p>Create a new SAM UEI, returning None if invalid.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef new(cls, value: str) -&gt; Optional[\"SamUei\"]:\n    \"\"\"Create a new SAM UEI, returning None if invalid.\"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Snfei","title":"Snfei  <code>dataclass</code>","text":"<p>Sub-National Federated Entity Identifier (64-character hex hash).</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@dataclass(frozen=True)\nclass Snfei:\n    \"\"\"Sub-National Federated Entity Identifier (64-character hex hash).\"\"\"\n\n    value: str\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the SNFEI format after initialization.\"\"\"\n        if not self._is_valid(self.value):\n            raise ValueError(f\"Invalid SNFEI: {self.value}\")\n\n    @staticmethod\n    def _is_valid(value: str) -&gt; bool:\n        return len(value) == 64 and all(c in \"0123456789abcdef\" for c in value.lower())\n\n    @classmethod\n    def from_hash(cls, hash_value: str) -&gt; Optional[\"Snfei\"]:\n        \"\"\"Create an SNFEI from a pre-computed hash.\"\"\"\n        try:\n            return cls(hash_value.lower())\n        except ValueError:\n            return None\n\n    @classmethod\n    def generate(cls, normalized_name: str, jurisdiction_iso: str) -&gt; \"Snfei\":\n        \"\"\"Generate an SNFEI from a normalized name and jurisdiction.\"\"\"\n        input_str = f\"{normalized_name}|{jurisdiction_iso}\"\n        hash_value = hashlib.sha256(input_str.encode(\"utf-8\")).hexdigest()\n        return cls(hash_value)\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the SNFEI as a string.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Snfei.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the SNFEI format after initialization.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the SNFEI format after initialization.\"\"\"\n    if not self._is_valid(self.value):\n        raise ValueError(f\"Invalid SNFEI: {self.value}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Snfei.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the SNFEI as a string.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the SNFEI as a string.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Snfei.from_hash","title":"from_hash  <code>classmethod</code>","text":"<pre><code>from_hash(hash_value: str) -&gt; Optional[Snfei]\n</code></pre> <p>Create an SNFEI from a pre-computed hash.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef from_hash(cls, hash_value: str) -&gt; Optional[\"Snfei\"]:\n    \"\"\"Create an SNFEI from a pre-computed hash.\"\"\"\n    try:\n        return cls(hash_value.lower())\n    except ValueError:\n        return None\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.entity.identifiers.Snfei.generate","title":"generate  <code>classmethod</code>","text":"<pre><code>generate(\n    normalized_name: str, jurisdiction_iso: str\n) -&gt; Snfei\n</code></pre> <p>Generate an SNFEI from a normalized name and jurisdiction.</p> Source code in <code>src/python/src/civic_exchange_protocol/entity/identifiers.py</code> <pre><code>@classmethod\ndef generate(cls, normalized_name: str, jurisdiction_iso: str) -&gt; \"Snfei\":\n    \"\"\"Generate an SNFEI from a normalized name and jurisdiction.\"\"\"\n    input_str = f\"{normalized_name}|{jurisdiction_iso}\"\n    hash_value = hashlib.sha256(input_str.encode(\"utf-8\")).hexdigest()\n    return cls(hash_value)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange","title":"exchange","text":"<p>CEP Exchange - Exchange records for the Civic Exchange Protocol.</p> <p>This package defines the ExchangeRecord type, which represents a verifiable value exchange (financial, in-kind, or informational) between entities within an established relationship. This is the atomic unit of civic transparency.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization","title":"ExchangeCategorization  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Categorization codes for reporting and analysis.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass ExchangeCategorization(Canonicalize):\n    \"\"\"Categorization codes for reporting and analysis.\"\"\"\n\n    cfda_number: str | None = None\n    naics_code: str | None = None\n    gtas_account_code: str | None = None\n    local_category_code: str | None = None\n    local_category_label: str | None = None\n\n    def with_cfda(self, cfda: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with CFDA set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=cfda,\n            naics_code=self.naics_code,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_naics(self, naics: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with NAICS set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=naics,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_gtas(self, gtas: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with GTAS set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=self.naics_code,\n            gtas_account_code=gtas,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_local_category(self, code: str, label: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with local category set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=self.naics_code,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=code,\n            local_category_label=label,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if any categorization is present.\"\"\"\n        return (\n            self.cfda_number is not None\n            or self.naics_code is not None\n            or self.gtas_account_code is not None\n            or self.local_category_code is not None\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the exchange categorization.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"cfdaNumber\", self.cfda_number)\n        insert_if_present(fields, \"gtasAccountCode\", self.gtas_account_code)\n        insert_if_present(fields, \"localCategoryCode\", self.local_category_code)\n        insert_if_present(fields, \"localCategoryLabel\", self.local_category_label)\n        insert_if_present(fields, \"naicsCode\", self.naics_code)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the exchange categorization.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the exchange categorization.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"cfdaNumber\", self.cfda_number)\n    insert_if_present(fields, \"gtasAccountCode\", self.gtas_account_code)\n    insert_if_present(fields, \"localCategoryCode\", self.local_category_code)\n    insert_if_present(fields, \"localCategoryLabel\", self.local_category_label)\n    insert_if_present(fields, \"naicsCode\", self.naics_code)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if any categorization is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if any categorization is present.\"\"\"\n    return (\n        self.cfda_number is not None\n        or self.naics_code is not None\n        or self.gtas_account_code is not None\n        or self.local_category_code is not None\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.with_cfda","title":"with_cfda","text":"<pre><code>with_cfda(cfda: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with CFDA set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_cfda(self, cfda: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with CFDA set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=cfda,\n        naics_code=self.naics_code,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.with_gtas","title":"with_gtas","text":"<pre><code>with_gtas(gtas: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with GTAS set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_gtas(self, gtas: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with GTAS set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=self.naics_code,\n        gtas_account_code=gtas,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.with_local_category","title":"with_local_category","text":"<pre><code>with_local_category(\n    code: str, label: str\n) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with local category set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_local_category(self, code: str, label: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with local category set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=self.naics_code,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=code,\n        local_category_label=label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeCategorization.with_naics","title":"with_naics","text":"<pre><code>with_naics(naics: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with NAICS set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_naics(self, naics: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with NAICS set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=naics,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty","title":"ExchangeParty  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A party in an exchange (source or recipient).</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ExchangeParty(Canonicalize):\n    \"\"\"A party in an exchange (source or recipient).\"\"\"\n\n    entity_id: str\n    role_uri: str | None = None\n    account_identifier: str | None = None\n\n    def with_role(self, role_uri: str) -&gt; \"ExchangeParty\":\n        \"\"\"Return a new ExchangeParty with role set.\"\"\"\n        return ExchangeParty(\n            entity_id=self.entity_id,\n            role_uri=role_uri,\n            account_identifier=self.account_identifier,\n        )\n\n    def with_account(self, account: str) -&gt; \"ExchangeParty\":\n        \"\"\"Return a new ExchangeParty with account identifier set.\"\"\"\n        return ExchangeParty(\n            entity_id=self.entity_id,\n            role_uri=self.role_uri,\n            account_identifier=account,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of this party as a dictionary.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields for this exchange party.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"accountIdentifier\", self.account_identifier)\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_if_present(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of this party as a dictionary.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields for this exchange party.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of this party as a dictionary.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields for this exchange party.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"accountIdentifier\", self.account_identifier)\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_if_present(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty.with_account","title":"with_account","text":"<pre><code>with_account(account: str) -&gt; ExchangeParty\n</code></pre> <p>Return a new ExchangeParty with account identifier set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def with_account(self, account: str) -&gt; \"ExchangeParty\":\n    \"\"\"Return a new ExchangeParty with account identifier set.\"\"\"\n    return ExchangeParty(\n        entity_id=self.entity_id,\n        role_uri=self.role_uri,\n        account_identifier=account,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeParty.with_role","title":"with_role","text":"<pre><code>with_role(role_uri: str) -&gt; ExchangeParty\n</code></pre> <p>Return a new ExchangeParty with role set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def with_role(self, role_uri: str) -&gt; \"ExchangeParty\":\n    \"\"\"Return a new ExchangeParty with role set.\"\"\"\n    return ExchangeParty(\n        entity_id=self.entity_id,\n        role_uri=role_uri,\n        account_identifier=self.account_identifier,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord","title":"ExchangeRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Exchange Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass ExchangeRecord(Canonicalize):\n    \"\"\"A complete CEP Exchange Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    relationship_id: str\n    exchange_type_uri: str\n    source_entity: ExchangeParty\n    recipient_entity: ExchangeParty\n    value: ExchangeValue\n    occurred_timestamp: CanonicalTimestamp\n    status: ExchangeStatus\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    provenance_chain: ProvenanceChain | None = None\n    categorization: ExchangeCategorization | None = None\n    source_references: list[SourceReference] | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new(\n        cls,\n        verifiable_id: str,\n        relationship_id: str,\n        exchange_type_uri: str,\n        source_entity: ExchangeParty,\n        recipient_entity: ExchangeParty,\n        value: ExchangeValue,\n        occurred_timestamp: CanonicalTimestamp,\n        status: ExchangeStatus,\n        attestation: Attestation,\n    ) -&gt; \"ExchangeRecord\":\n        \"\"\"Create a new ExchangeRecord with required fields.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_id=relationship_id,\n            exchange_type_uri=exchange_type_uri,\n            source_entity=source_entity,\n            recipient_entity=recipient_entity,\n            value=value,\n            occurred_timestamp=occurred_timestamp,\n            status=status,\n            attestation=attestation,\n        )\n\n    def with_provenance(self, chain: ProvenanceChain) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with provenance chain set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_categorization(self, cat: ExchangeCategorization) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with categorization set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=cat,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_source_reference(self, reference: SourceReference) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with a source reference added.\"\"\"\n        refs = list(self.source_references) if self.source_references else []\n        refs.append(reference)\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=refs,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with previous hash set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with revision number set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n\n        if self.categorization is not None and self.categorization.has_any():\n            insert_required(fields, \"categorization\", self.categorization.to_canonical_string())\n\n        insert_required(fields, \"exchangeTypeUri\", self.exchange_type_uri)\n        insert_required(fields, \"occurredTimestamp\", self.occurred_timestamp.to_canonical_string())\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n        if self.provenance_chain is not None and self.provenance_chain.has_any():\n            insert_required(fields, \"provenanceChain\", self.provenance_chain.to_canonical_string())\n\n        insert_required(fields, \"recipientEntity\", self.recipient_entity.to_canonical_string())\n        insert_required(fields, \"relationshipId\", self.relationship_id)\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Source references sorted by sourceSystemUri then sourceRecordId\n        if self.source_references:\n            sorted_refs = sorted(\n                self.source_references,\n                key=lambda r: (r.source_system_uri, r.source_record_id),\n            )\n            refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n            fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n        insert_required(fields, \"sourceEntity\", self.source_entity.to_canonical_string())\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n        insert_required(fields, \"value\", self.value.to_canonical_string())\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n\n    if self.categorization is not None and self.categorization.has_any():\n        insert_required(fields, \"categorization\", self.categorization.to_canonical_string())\n\n    insert_required(fields, \"exchangeTypeUri\", self.exchange_type_uri)\n    insert_required(fields, \"occurredTimestamp\", self.occurred_timestamp.to_canonical_string())\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n    if self.provenance_chain is not None and self.provenance_chain.has_any():\n        insert_required(fields, \"provenanceChain\", self.provenance_chain.to_canonical_string())\n\n    insert_required(fields, \"recipientEntity\", self.recipient_entity.to_canonical_string())\n    insert_required(fields, \"relationshipId\", self.relationship_id)\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Source references sorted by sourceSystemUri then sourceRecordId\n    if self.source_references:\n        sorted_refs = sorted(\n            self.source_references,\n            key=lambda r: (r.source_system_uri, r.source_record_id),\n        )\n        refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n        fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n    insert_required(fields, \"sourceEntity\", self.source_entity.to_canonical_string())\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n    insert_required(fields, \"value\", self.value.to_canonical_string())\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    verifiable_id: str,\n    relationship_id: str,\n    exchange_type_uri: str,\n    source_entity: ExchangeParty,\n    recipient_entity: ExchangeParty,\n    value: ExchangeValue,\n    occurred_timestamp: CanonicalTimestamp,\n    status: ExchangeStatus,\n    attestation: Attestation,\n) -&gt; ExchangeRecord\n</code></pre> <p>Create a new ExchangeRecord with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    verifiable_id: str,\n    relationship_id: str,\n    exchange_type_uri: str,\n    source_entity: ExchangeParty,\n    recipient_entity: ExchangeParty,\n    value: ExchangeValue,\n    occurred_timestamp: CanonicalTimestamp,\n    status: ExchangeStatus,\n    attestation: Attestation,\n) -&gt; \"ExchangeRecord\":\n    \"\"\"Create a new ExchangeRecord with required fields.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_id=relationship_id,\n        exchange_type_uri=exchange_type_uri,\n        source_entity=source_entity,\n        recipient_entity=recipient_entity,\n        value=value,\n        occurred_timestamp=occurred_timestamp,\n        status=status,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_categorization","title":"with_categorization","text":"<pre><code>with_categorization(\n    cat: ExchangeCategorization,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with categorization set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_categorization(self, cat: ExchangeCategorization) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with categorization set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=cat,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(\n    hash_val: CanonicalHash,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with previous hash set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_provenance","title":"with_provenance","text":"<pre><code>with_provenance(chain: ProvenanceChain) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with provenance chain set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_provenance(self, chain: ProvenanceChain) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with provenance chain set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with revision number set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeRecord.with_source_reference","title":"with_source_reference","text":"<pre><code>with_source_reference(\n    reference: SourceReference,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with a source reference added.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_source_reference(self, reference: SourceReference) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with a source reference added.\"\"\"\n    refs = list(self.source_references) if self.source_references else []\n    refs.append(reference)\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=refs,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatus","title":"ExchangeStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Exchange status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass ExchangeStatus(Canonicalize):\n    \"\"\"Exchange status information.\"\"\"\n\n    status_code: ExchangeStatusCode\n    status_effective_timestamp: CanonicalTimestamp\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the exchange status.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(\n            fields,\n            \"statusEffectiveTimestamp\",\n            self.status_effective_timestamp.to_canonical_string(),\n        )\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the exchange status.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatus.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the exchange status.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(\n        fields,\n        \"statusEffectiveTimestamp\",\n        self.status_effective_timestamp.to_canonical_string(),\n    )\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatusCode","title":"ExchangeStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Exchange operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>class ExchangeStatusCode(Enum):\n    \"\"\"Exchange operational status.\"\"\"\n\n    PENDING = \"PENDING\"\n    COMPLETED = \"COMPLETED\"\n    REVERSED = \"REVERSED\"\n    CANCELED = \"CANCELED\"\n    DISPUTED = \"DISPUTED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string value of the exchange status code.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string value of the exchange status code.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string value of the exchange status code.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue","title":"ExchangeValue  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>The value being exchanged.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ExchangeValue(Canonicalize):\n    \"\"\"The value being exchanged.\"\"\"\n\n    amount: float\n    currency_code: str = \"USD\"\n    value_type_uri: str = DEFAULT_VALUE_TYPE_URI\n    in_kind_description: str | None = None\n\n    @classmethod\n    def monetary(cls, amount: float, currency_code: str = \"USD\") -&gt; \"ExchangeValue\":\n        \"\"\"Create a new monetary value.\"\"\"\n        return cls(amount=amount, currency_code=currency_code)\n\n    @classmethod\n    def usd(cls, amount: float) -&gt; \"ExchangeValue\":\n        \"\"\"Create a new USD monetary value.\"\"\"\n        return cls.monetary(amount, \"USD\")\n\n    @classmethod\n    def in_kind(cls, amount: float, description: str) -&gt; \"ExchangeValue\":\n        \"\"\"Create an in-kind value with description.\"\"\"\n        return cls(\n            amount=amount,\n            currency_code=\"USD\",\n            value_type_uri=ValueType.in_kind().type_uri,\n            in_kind_description=description,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of this value as a dictionary.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields for this exchange value.\n        \"\"\"\n        fields: dict[str, str] = {}\n        # Amount formatted to exactly 2 decimal places\n        insert_required(fields, \"amount\", format_amount(self.amount))\n        insert_required(fields, \"currencyCode\", self.currency_code)\n        insert_if_present(fields, \"inKindDescription\", self.in_kind_description)\n        insert_required(fields, \"valueTypeUri\", self.value_type_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of this value as a dictionary.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields for this exchange value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of this value as a dictionary.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields for this exchange value.\n    \"\"\"\n    fields: dict[str, str] = {}\n    # Amount formatted to exactly 2 decimal places\n    insert_required(fields, \"amount\", format_amount(self.amount))\n    insert_required(fields, \"currencyCode\", self.currency_code)\n    insert_if_present(fields, \"inKindDescription\", self.in_kind_description)\n    insert_required(fields, \"valueTypeUri\", self.value_type_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.in_kind","title":"in_kind  <code>classmethod</code>","text":"<pre><code>in_kind(amount: float, description: str) -&gt; ExchangeValue\n</code></pre> <p>Create an in-kind value with description.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef in_kind(cls, amount: float, description: str) -&gt; \"ExchangeValue\":\n    \"\"\"Create an in-kind value with description.\"\"\"\n    return cls(\n        amount=amount,\n        currency_code=\"USD\",\n        value_type_uri=ValueType.in_kind().type_uri,\n        in_kind_description=description,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.monetary","title":"monetary  <code>classmethod</code>","text":"<pre><code>monetary(\n    amount: float, currency_code: str = 'USD'\n) -&gt; ExchangeValue\n</code></pre> <p>Create a new monetary value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef monetary(cls, amount: float, currency_code: str = \"USD\") -&gt; \"ExchangeValue\":\n    \"\"\"Create a new monetary value.\"\"\"\n    return cls(amount=amount, currency_code=currency_code)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ExchangeValue.usd","title":"usd  <code>classmethod</code>","text":"<pre><code>usd(amount: float) -&gt; ExchangeValue\n</code></pre> <p>Create a new USD monetary value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef usd(cls, amount: float) -&gt; \"ExchangeValue\":\n    \"\"\"Create a new USD monetary value.\"\"\"\n    return cls.monetary(amount, \"USD\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.IntermediaryEntity","title":"IntermediaryEntity  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>An intermediary entity in the funding chain.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass IntermediaryEntity(Canonicalize):\n    \"\"\"An intermediary entity in the funding chain.\"\"\"\n\n    entity_id: str\n    role_uri: str | None = None\n\n    def with_role(self, role_uri: str) -&gt; \"IntermediaryEntity\":\n        \"\"\"Return a new IntermediaryEntity with role set.\"\"\"\n        return IntermediaryEntity(entity_id=self.entity_id, role_uri=role_uri)\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the intermediary entity.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_if_present(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.IntermediaryEntity.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the intermediary entity.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.IntermediaryEntity.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the intermediary entity.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_if_present(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.IntermediaryEntity.with_role","title":"with_role","text":"<pre><code>with_role(role_uri: str) -&gt; IntermediaryEntity\n</code></pre> <p>Return a new IntermediaryEntity with role set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_role(self, role_uri: str) -&gt; \"IntermediaryEntity\":\n    \"\"\"Return a new IntermediaryEntity with role set.\"\"\"\n    return IntermediaryEntity(entity_id=self.entity_id, role_uri=role_uri)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain","title":"ProvenanceChain  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Provenance chain tracing the flow of funds.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass ProvenanceChain(Canonicalize):\n    \"\"\"Provenance chain tracing the flow of funds.\"\"\"\n\n    funding_chain_tag: str | None = None\n    ultimate_source_entity_id: str | None = None\n    intermediary_entities: list[IntermediaryEntity] | None = None\n    parent_exchange_id: str | None = None\n\n    def with_funding_chain_tag(self, tag: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with funding chain tag set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_ultimate_source(self, entity_id: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with ultimate source set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_intermediary(self, entity: IntermediaryEntity) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with an intermediary added.\"\"\"\n        entities = list(self.intermediary_entities) if self.intermediary_entities else []\n        entities.append(entity)\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_parent_exchange(self, exchange_id: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with parent exchange set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=exchange_id,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if any provenance information is present.\"\"\"\n        return (\n            self.funding_chain_tag is not None\n            or self.ultimate_source_entity_id is not None\n            or (self.intermediary_entities is not None and len(self.intermediary_entities) &gt; 0)\n            or self.parent_exchange_id is not None\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the provenance chain.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n\n        insert_if_present(fields, \"fundingChainTag\", self.funding_chain_tag)\n\n        # Intermediary entities serialized as array\n        if self.intermediary_entities:\n            entities_json = \",\".join(e.to_canonical_string() for e in self.intermediary_entities)\n            fields[\"intermediaryEntities\"] = f\"[{entities_json}]\"\n\n        insert_if_present(fields, \"parentExchangeId\", self.parent_exchange_id)\n        insert_if_present(fields, \"ultimateSourceEntityId\", self.ultimate_source_entity_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the provenance chain.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the provenance chain.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n\n    insert_if_present(fields, \"fundingChainTag\", self.funding_chain_tag)\n\n    # Intermediary entities serialized as array\n    if self.intermediary_entities:\n        entities_json = \",\".join(e.to_canonical_string() for e in self.intermediary_entities)\n        fields[\"intermediaryEntities\"] = f\"[{entities_json}]\"\n\n    insert_if_present(fields, \"parentExchangeId\", self.parent_exchange_id)\n    insert_if_present(fields, \"ultimateSourceEntityId\", self.ultimate_source_entity_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if any provenance information is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if any provenance information is present.\"\"\"\n    return (\n        self.funding_chain_tag is not None\n        or self.ultimate_source_entity_id is not None\n        or (self.intermediary_entities is not None and len(self.intermediary_entities) &gt; 0)\n        or self.parent_exchange_id is not None\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.with_funding_chain_tag","title":"with_funding_chain_tag","text":"<pre><code>with_funding_chain_tag(tag: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with funding chain tag set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_funding_chain_tag(self, tag: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with funding chain tag set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.with_intermediary","title":"with_intermediary","text":"<pre><code>with_intermediary(\n    entity: IntermediaryEntity,\n) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with an intermediary added.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_intermediary(self, entity: IntermediaryEntity) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with an intermediary added.\"\"\"\n    entities = list(self.intermediary_entities) if self.intermediary_entities else []\n    entities.append(entity)\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.with_parent_exchange","title":"with_parent_exchange","text":"<pre><code>with_parent_exchange(exchange_id: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with parent exchange set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_parent_exchange(self, exchange_id: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with parent exchange set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ProvenanceChain.with_ultimate_source","title":"with_ultimate_source","text":"<pre><code>with_ultimate_source(entity_id: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with ultimate source set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_ultimate_source(self, entity_id: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with ultimate source set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.SourceReference","title":"SourceReference  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Reference to an authoritative source record.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass SourceReference(Canonicalize):\n    \"\"\"Reference to an authoritative source record.\"\"\"\n\n    source_system_uri: str\n    source_record_id: str\n    source_url: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the source reference.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"sourceRecordId\", self.source_record_id)\n        insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n        insert_if_present(fields, \"sourceUrl\", self.source_url)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.SourceReference.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the source reference.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.SourceReference.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the source reference.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"sourceRecordId\", self.source_record_id)\n    insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n    insert_if_present(fields, \"sourceUrl\", self.source_url)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ValueType","title":"ValueType  <code>dataclass</code>","text":"<p>The type of value being exchanged.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ValueType:\n    \"\"\"The type of value being exchanged.\"\"\"\n\n    type_uri: str\n\n    @classmethod\n    def monetary(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for monetary exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#monetary\"\n        )\n\n    @classmethod\n    def in_kind(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for in-kind exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#in-kind\"\n        )\n\n    @classmethod\n    def service_hours(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for service hours exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#service-hours\"\n        )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ValueType.in_kind","title":"in_kind  <code>classmethod</code>","text":"<pre><code>in_kind() -&gt; ValueType\n</code></pre> <p>Return a ValueType for in-kind exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef in_kind(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for in-kind exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#in-kind\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ValueType.monetary","title":"monetary  <code>classmethod</code>","text":"<pre><code>monetary() -&gt; ValueType\n</code></pre> <p>Return a ValueType for monetary exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef monetary(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for monetary exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#monetary\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.ValueType.service_hours","title":"service_hours  <code>classmethod</code>","text":"<pre><code>service_hours() -&gt; ValueType\n</code></pre> <p>Return a ValueType for service hours exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef service_hours(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for service hours exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#service-hours\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange","title":"exchange","text":"<p>CEP Exchange Record definition.</p> <p>An Exchange Record represents a verifiable value exchange (financial, in-kind, or informational) between entities within an established relationship. This is the atomic unit of civic transparency.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord","title":"ExchangeRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Exchange Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass ExchangeRecord(Canonicalize):\n    \"\"\"A complete CEP Exchange Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    relationship_id: str\n    exchange_type_uri: str\n    source_entity: ExchangeParty\n    recipient_entity: ExchangeParty\n    value: ExchangeValue\n    occurred_timestamp: CanonicalTimestamp\n    status: ExchangeStatus\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    provenance_chain: ProvenanceChain | None = None\n    categorization: ExchangeCategorization | None = None\n    source_references: list[SourceReference] | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new(\n        cls,\n        verifiable_id: str,\n        relationship_id: str,\n        exchange_type_uri: str,\n        source_entity: ExchangeParty,\n        recipient_entity: ExchangeParty,\n        value: ExchangeValue,\n        occurred_timestamp: CanonicalTimestamp,\n        status: ExchangeStatus,\n        attestation: Attestation,\n    ) -&gt; \"ExchangeRecord\":\n        \"\"\"Create a new ExchangeRecord with required fields.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_id=relationship_id,\n            exchange_type_uri=exchange_type_uri,\n            source_entity=source_entity,\n            recipient_entity=recipient_entity,\n            value=value,\n            occurred_timestamp=occurred_timestamp,\n            status=status,\n            attestation=attestation,\n        )\n\n    def with_provenance(self, chain: ProvenanceChain) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with provenance chain set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_categorization(self, cat: ExchangeCategorization) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with categorization set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=cat,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_source_reference(self, reference: SourceReference) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with a source reference added.\"\"\"\n        refs = list(self.source_references) if self.source_references else []\n        refs.append(reference)\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=refs,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with previous hash set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"ExchangeRecord\":\n        \"\"\"Return a new ExchangeRecord with revision number set.\"\"\"\n        return ExchangeRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_id=self.relationship_id,\n            exchange_type_uri=self.exchange_type_uri,\n            source_entity=self.source_entity,\n            recipient_entity=self.recipient_entity,\n            value=self.value,\n            occurred_timestamp=self.occurred_timestamp,\n            status=self.status,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            provenance_chain=self.provenance_chain,\n            categorization=self.categorization,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n\n        if self.categorization is not None and self.categorization.has_any():\n            insert_required(fields, \"categorization\", self.categorization.to_canonical_string())\n\n        insert_required(fields, \"exchangeTypeUri\", self.exchange_type_uri)\n        insert_required(fields, \"occurredTimestamp\", self.occurred_timestamp.to_canonical_string())\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n        if self.provenance_chain is not None and self.provenance_chain.has_any():\n            insert_required(fields, \"provenanceChain\", self.provenance_chain.to_canonical_string())\n\n        insert_required(fields, \"recipientEntity\", self.recipient_entity.to_canonical_string())\n        insert_required(fields, \"relationshipId\", self.relationship_id)\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Source references sorted by sourceSystemUri then sourceRecordId\n        if self.source_references:\n            sorted_refs = sorted(\n                self.source_references,\n                key=lambda r: (r.source_system_uri, r.source_record_id),\n            )\n            refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n            fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n        insert_required(fields, \"sourceEntity\", self.source_entity.to_canonical_string())\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n        insert_required(fields, \"value\", self.value.to_canonical_string())\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n\n    if self.categorization is not None and self.categorization.has_any():\n        insert_required(fields, \"categorization\", self.categorization.to_canonical_string())\n\n    insert_required(fields, \"exchangeTypeUri\", self.exchange_type_uri)\n    insert_required(fields, \"occurredTimestamp\", self.occurred_timestamp.to_canonical_string())\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n\n    if self.provenance_chain is not None and self.provenance_chain.has_any():\n        insert_required(fields, \"provenanceChain\", self.provenance_chain.to_canonical_string())\n\n    insert_required(fields, \"recipientEntity\", self.recipient_entity.to_canonical_string())\n    insert_required(fields, \"relationshipId\", self.relationship_id)\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Source references sorted by sourceSystemUri then sourceRecordId\n    if self.source_references:\n        sorted_refs = sorted(\n            self.source_references,\n            key=lambda r: (r.source_system_uri, r.source_record_id),\n        )\n        refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n        fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n    insert_required(fields, \"sourceEntity\", self.source_entity.to_canonical_string())\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n    insert_required(fields, \"value\", self.value.to_canonical_string())\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    verifiable_id: str,\n    relationship_id: str,\n    exchange_type_uri: str,\n    source_entity: ExchangeParty,\n    recipient_entity: ExchangeParty,\n    value: ExchangeValue,\n    occurred_timestamp: CanonicalTimestamp,\n    status: ExchangeStatus,\n    attestation: Attestation,\n) -&gt; ExchangeRecord\n</code></pre> <p>Create a new ExchangeRecord with required fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    verifiable_id: str,\n    relationship_id: str,\n    exchange_type_uri: str,\n    source_entity: ExchangeParty,\n    recipient_entity: ExchangeParty,\n    value: ExchangeValue,\n    occurred_timestamp: CanonicalTimestamp,\n    status: ExchangeStatus,\n    attestation: Attestation,\n) -&gt; \"ExchangeRecord\":\n    \"\"\"Create a new ExchangeRecord with required fields.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_id=relationship_id,\n        exchange_type_uri=exchange_type_uri,\n        source_entity=source_entity,\n        recipient_entity=recipient_entity,\n        value=value,\n        occurred_timestamp=occurred_timestamp,\n        status=status,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_categorization","title":"with_categorization","text":"<pre><code>with_categorization(\n    cat: ExchangeCategorization,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with categorization set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_categorization(self, cat: ExchangeCategorization) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with categorization set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=cat,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(\n    hash_val: CanonicalHash,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with previous hash set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_provenance","title":"with_provenance","text":"<pre><code>with_provenance(chain: ProvenanceChain) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with provenance chain set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_provenance(self, chain: ProvenanceChain) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with provenance chain set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with revision number set.\"\"\"\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeRecord.with_source_reference","title":"with_source_reference","text":"<pre><code>with_source_reference(\n    reference: SourceReference,\n) -&gt; ExchangeRecord\n</code></pre> <p>Return a new ExchangeRecord with a source reference added.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def with_source_reference(self, reference: SourceReference) -&gt; \"ExchangeRecord\":\n    \"\"\"Return a new ExchangeRecord with a source reference added.\"\"\"\n    refs = list(self.source_references) if self.source_references else []\n    refs.append(reference)\n    return ExchangeRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_id=self.relationship_id,\n        exchange_type_uri=self.exchange_type_uri,\n        source_entity=self.source_entity,\n        recipient_entity=self.recipient_entity,\n        value=self.value,\n        occurred_timestamp=self.occurred_timestamp,\n        status=self.status,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        provenance_chain=self.provenance_chain,\n        categorization=self.categorization,\n        source_references=refs,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatus","title":"ExchangeStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Exchange status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass ExchangeStatus(Canonicalize):\n    \"\"\"Exchange status information.\"\"\"\n\n    status_code: ExchangeStatusCode\n    status_effective_timestamp: CanonicalTimestamp\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the exchange status.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(\n            fields,\n            \"statusEffectiveTimestamp\",\n            self.status_effective_timestamp.to_canonical_string(),\n        )\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the exchange status.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatus.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the exchange status.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(\n        fields,\n        \"statusEffectiveTimestamp\",\n        self.status_effective_timestamp.to_canonical_string(),\n    )\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatusCode","title":"ExchangeStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Exchange operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>class ExchangeStatusCode(Enum):\n    \"\"\"Exchange operational status.\"\"\"\n\n    PENDING = \"PENDING\"\n    COMPLETED = \"COMPLETED\"\n    REVERSED = \"REVERSED\"\n    CANCELED = \"CANCELED\"\n    DISPUTED = \"DISPUTED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string value of the exchange status code.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.ExchangeStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string value of the exchange status code.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string value of the exchange status code.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.SourceReference","title":"SourceReference  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Reference to an authoritative source record.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>@dataclass\nclass SourceReference(Canonicalize):\n    \"\"\"Reference to an authoritative source record.\"\"\"\n\n    source_system_uri: str\n    source_record_id: str\n    source_url: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the source reference.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical fields.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"sourceRecordId\", self.source_record_id)\n        insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n        insert_if_present(fields, \"sourceUrl\", self.source_url)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.SourceReference.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the source reference.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.exchange.SourceReference.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/exchange.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the source reference.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical fields.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"sourceRecordId\", self.source_record_id)\n    insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n    insert_if_present(fields, \"sourceUrl\", self.source_url)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance","title":"provenance","text":"<p>Provenance chain tracking for CEP exchanges.</p> <p>Traces the compositional flow of funds through the civic graph. This is the Category Theory morphism path implementation.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization","title":"ExchangeCategorization  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Categorization codes for reporting and analysis.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass ExchangeCategorization(Canonicalize):\n    \"\"\"Categorization codes for reporting and analysis.\"\"\"\n\n    cfda_number: str | None = None\n    naics_code: str | None = None\n    gtas_account_code: str | None = None\n    local_category_code: str | None = None\n    local_category_label: str | None = None\n\n    def with_cfda(self, cfda: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with CFDA set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=cfda,\n            naics_code=self.naics_code,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_naics(self, naics: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with NAICS set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=naics,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_gtas(self, gtas: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with GTAS set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=self.naics_code,\n            gtas_account_code=gtas,\n            local_category_code=self.local_category_code,\n            local_category_label=self.local_category_label,\n        )\n\n    def with_local_category(self, code: str, label: str) -&gt; \"ExchangeCategorization\":\n        \"\"\"Return a new ExchangeCategorization with local category set.\"\"\"\n        return ExchangeCategorization(\n            cfda_number=self.cfda_number,\n            naics_code=self.naics_code,\n            gtas_account_code=self.gtas_account_code,\n            local_category_code=code,\n            local_category_label=label,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if any categorization is present.\"\"\"\n        return (\n            self.cfda_number is not None\n            or self.naics_code is not None\n            or self.gtas_account_code is not None\n            or self.local_category_code is not None\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the exchange categorization.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"cfdaNumber\", self.cfda_number)\n        insert_if_present(fields, \"gtasAccountCode\", self.gtas_account_code)\n        insert_if_present(fields, \"localCategoryCode\", self.local_category_code)\n        insert_if_present(fields, \"localCategoryLabel\", self.local_category_label)\n        insert_if_present(fields, \"naicsCode\", self.naics_code)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the exchange categorization.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the exchange categorization.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"cfdaNumber\", self.cfda_number)\n    insert_if_present(fields, \"gtasAccountCode\", self.gtas_account_code)\n    insert_if_present(fields, \"localCategoryCode\", self.local_category_code)\n    insert_if_present(fields, \"localCategoryLabel\", self.local_category_label)\n    insert_if_present(fields, \"naicsCode\", self.naics_code)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if any categorization is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if any categorization is present.\"\"\"\n    return (\n        self.cfda_number is not None\n        or self.naics_code is not None\n        or self.gtas_account_code is not None\n        or self.local_category_code is not None\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.with_cfda","title":"with_cfda","text":"<pre><code>with_cfda(cfda: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with CFDA set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_cfda(self, cfda: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with CFDA set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=cfda,\n        naics_code=self.naics_code,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.with_gtas","title":"with_gtas","text":"<pre><code>with_gtas(gtas: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with GTAS set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_gtas(self, gtas: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with GTAS set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=self.naics_code,\n        gtas_account_code=gtas,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.with_local_category","title":"with_local_category","text":"<pre><code>with_local_category(\n    code: str, label: str\n) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with local category set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_local_category(self, code: str, label: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with local category set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=self.naics_code,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=code,\n        local_category_label=label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ExchangeCategorization.with_naics","title":"with_naics","text":"<pre><code>with_naics(naics: str) -&gt; ExchangeCategorization\n</code></pre> <p>Return a new ExchangeCategorization with NAICS set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_naics(self, naics: str) -&gt; \"ExchangeCategorization\":\n    \"\"\"Return a new ExchangeCategorization with NAICS set.\"\"\"\n    return ExchangeCategorization(\n        cfda_number=self.cfda_number,\n        naics_code=naics,\n        gtas_account_code=self.gtas_account_code,\n        local_category_code=self.local_category_code,\n        local_category_label=self.local_category_label,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.IntermediaryEntity","title":"IntermediaryEntity  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>An intermediary entity in the funding chain.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass IntermediaryEntity(Canonicalize):\n    \"\"\"An intermediary entity in the funding chain.\"\"\"\n\n    entity_id: str\n    role_uri: str | None = None\n\n    def with_role(self, role_uri: str) -&gt; \"IntermediaryEntity\":\n        \"\"\"Return a new IntermediaryEntity with role set.\"\"\"\n        return IntermediaryEntity(entity_id=self.entity_id, role_uri=role_uri)\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the intermediary entity.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_if_present(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.IntermediaryEntity.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the intermediary entity.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.IntermediaryEntity.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the intermediary entity.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_if_present(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.IntermediaryEntity.with_role","title":"with_role","text":"<pre><code>with_role(role_uri: str) -&gt; IntermediaryEntity\n</code></pre> <p>Return a new IntermediaryEntity with role set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_role(self, role_uri: str) -&gt; \"IntermediaryEntity\":\n    \"\"\"Return a new IntermediaryEntity with role set.\"\"\"\n    return IntermediaryEntity(entity_id=self.entity_id, role_uri=role_uri)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain","title":"ProvenanceChain  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Provenance chain tracing the flow of funds.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>@dataclass\nclass ProvenanceChain(Canonicalize):\n    \"\"\"Provenance chain tracing the flow of funds.\"\"\"\n\n    funding_chain_tag: str | None = None\n    ultimate_source_entity_id: str | None = None\n    intermediary_entities: list[IntermediaryEntity] | None = None\n    parent_exchange_id: str | None = None\n\n    def with_funding_chain_tag(self, tag: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with funding chain tag set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_ultimate_source(self, entity_id: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with ultimate source set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_intermediary(self, entity: IntermediaryEntity) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with an intermediary added.\"\"\"\n        entities = list(self.intermediary_entities) if self.intermediary_entities else []\n        entities.append(entity)\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=entities,\n            parent_exchange_id=self.parent_exchange_id,\n        )\n\n    def with_parent_exchange(self, exchange_id: str) -&gt; \"ProvenanceChain\":\n        \"\"\"Return a new ProvenanceChain with parent exchange set.\"\"\"\n        return ProvenanceChain(\n            funding_chain_tag=self.funding_chain_tag,\n            ultimate_source_entity_id=self.ultimate_source_entity_id,\n            intermediary_entities=self.intermediary_entities,\n            parent_exchange_id=exchange_id,\n        )\n\n    def has_any(self) -&gt; bool:\n        \"\"\"Return True if any provenance information is present.\"\"\"\n        return (\n            self.funding_chain_tag is not None\n            or self.ultimate_source_entity_id is not None\n            or (self.intermediary_entities is not None and len(self.intermediary_entities) &gt; 0)\n            or self.parent_exchange_id is not None\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields for the provenance chain.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical field names and values.\n        \"\"\"\n        fields: dict[str, str] = {}\n\n        insert_if_present(fields, \"fundingChainTag\", self.funding_chain_tag)\n\n        # Intermediary entities serialized as array\n        if self.intermediary_entities:\n            entities_json = \",\".join(e.to_canonical_string() for e in self.intermediary_entities)\n            fields[\"intermediaryEntities\"] = f\"[{entities_json}]\"\n\n        insert_if_present(fields, \"parentExchangeId\", self.parent_exchange_id)\n        insert_if_present(fields, \"ultimateSourceEntityId\", self.ultimate_source_entity_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields for the provenance chain.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical field names and values.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields for the provenance chain.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical field names and values.\n    \"\"\"\n    fields: dict[str, str] = {}\n\n    insert_if_present(fields, \"fundingChainTag\", self.funding_chain_tag)\n\n    # Intermediary entities serialized as array\n    if self.intermediary_entities:\n        entities_json = \",\".join(e.to_canonical_string() for e in self.intermediary_entities)\n        fields[\"intermediaryEntities\"] = f\"[{entities_json}]\"\n\n    insert_if_present(fields, \"parentExchangeId\", self.parent_exchange_id)\n    insert_if_present(fields, \"ultimateSourceEntityId\", self.ultimate_source_entity_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.has_any","title":"has_any","text":"<pre><code>has_any() -&gt; bool\n</code></pre> <p>Return True if any provenance information is present.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def has_any(self) -&gt; bool:\n    \"\"\"Return True if any provenance information is present.\"\"\"\n    return (\n        self.funding_chain_tag is not None\n        or self.ultimate_source_entity_id is not None\n        or (self.intermediary_entities is not None and len(self.intermediary_entities) &gt; 0)\n        or self.parent_exchange_id is not None\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.with_funding_chain_tag","title":"with_funding_chain_tag","text":"<pre><code>with_funding_chain_tag(tag: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with funding chain tag set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_funding_chain_tag(self, tag: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with funding chain tag set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.with_intermediary","title":"with_intermediary","text":"<pre><code>with_intermediary(\n    entity: IntermediaryEntity,\n) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with an intermediary added.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_intermediary(self, entity: IntermediaryEntity) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with an intermediary added.\"\"\"\n    entities = list(self.intermediary_entities) if self.intermediary_entities else []\n    entities.append(entity)\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.with_parent_exchange","title":"with_parent_exchange","text":"<pre><code>with_parent_exchange(exchange_id: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with parent exchange set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_parent_exchange(self, exchange_id: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with parent exchange set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=self.ultimate_source_entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.provenance.ProvenanceChain.with_ultimate_source","title":"with_ultimate_source","text":"<pre><code>with_ultimate_source(entity_id: str) -&gt; ProvenanceChain\n</code></pre> <p>Return a new ProvenanceChain with ultimate source set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/provenance.py</code> <pre><code>def with_ultimate_source(self, entity_id: str) -&gt; \"ProvenanceChain\":\n    \"\"\"Return a new ProvenanceChain with ultimate source set.\"\"\"\n    return ProvenanceChain(\n        funding_chain_tag=self.funding_chain_tag,\n        ultimate_source_entity_id=entity_id,\n        intermediary_entities=self.intermediary_entities,\n        parent_exchange_id=self.parent_exchange_id,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value","title":"value","text":"<p>Value types for CEP exchanges.</p> <p>Supports monetary values (with currency) and in-kind contributions.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty","title":"ExchangeParty  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A party in an exchange (source or recipient).</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ExchangeParty(Canonicalize):\n    \"\"\"A party in an exchange (source or recipient).\"\"\"\n\n    entity_id: str\n    role_uri: str | None = None\n    account_identifier: str | None = None\n\n    def with_role(self, role_uri: str) -&gt; \"ExchangeParty\":\n        \"\"\"Return a new ExchangeParty with role set.\"\"\"\n        return ExchangeParty(\n            entity_id=self.entity_id,\n            role_uri=role_uri,\n            account_identifier=self.account_identifier,\n        )\n\n    def with_account(self, account: str) -&gt; \"ExchangeParty\":\n        \"\"\"Return a new ExchangeParty with account identifier set.\"\"\"\n        return ExchangeParty(\n            entity_id=self.entity_id,\n            role_uri=self.role_uri,\n            account_identifier=account,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of this party as a dictionary.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields for this exchange party.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_if_present(fields, \"accountIdentifier\", self.account_identifier)\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_if_present(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of this party as a dictionary.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields for this exchange party.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of this party as a dictionary.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields for this exchange party.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_if_present(fields, \"accountIdentifier\", self.account_identifier)\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_if_present(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty.with_account","title":"with_account","text":"<pre><code>with_account(account: str) -&gt; ExchangeParty\n</code></pre> <p>Return a new ExchangeParty with account identifier set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def with_account(self, account: str) -&gt; \"ExchangeParty\":\n    \"\"\"Return a new ExchangeParty with account identifier set.\"\"\"\n    return ExchangeParty(\n        entity_id=self.entity_id,\n        role_uri=self.role_uri,\n        account_identifier=account,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeParty.with_role","title":"with_role","text":"<pre><code>with_role(role_uri: str) -&gt; ExchangeParty\n</code></pre> <p>Return a new ExchangeParty with role set.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def with_role(self, role_uri: str) -&gt; \"ExchangeParty\":\n    \"\"\"Return a new ExchangeParty with role set.\"\"\"\n    return ExchangeParty(\n        entity_id=self.entity_id,\n        role_uri=role_uri,\n        account_identifier=self.account_identifier,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue","title":"ExchangeValue  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>The value being exchanged.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ExchangeValue(Canonicalize):\n    \"\"\"The value being exchanged.\"\"\"\n\n    amount: float\n    currency_code: str = \"USD\"\n    value_type_uri: str = DEFAULT_VALUE_TYPE_URI\n    in_kind_description: str | None = None\n\n    @classmethod\n    def monetary(cls, amount: float, currency_code: str = \"USD\") -&gt; \"ExchangeValue\":\n        \"\"\"Create a new monetary value.\"\"\"\n        return cls(amount=amount, currency_code=currency_code)\n\n    @classmethod\n    def usd(cls, amount: float) -&gt; \"ExchangeValue\":\n        \"\"\"Create a new USD monetary value.\"\"\"\n        return cls.monetary(amount, \"USD\")\n\n    @classmethod\n    def in_kind(cls, amount: float, description: str) -&gt; \"ExchangeValue\":\n        \"\"\"Create an in-kind value with description.\"\"\"\n        return cls(\n            amount=amount,\n            currency_code=\"USD\",\n            value_type_uri=ValueType.in_kind().type_uri,\n            in_kind_description=description,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of this value as a dictionary.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields for this exchange value.\n        \"\"\"\n        fields: dict[str, str] = {}\n        # Amount formatted to exactly 2 decimal places\n        insert_required(fields, \"amount\", format_amount(self.amount))\n        insert_required(fields, \"currencyCode\", self.currency_code)\n        insert_if_present(fields, \"inKindDescription\", self.in_kind_description)\n        insert_required(fields, \"valueTypeUri\", self.value_type_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of this value as a dictionary.</p>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields for this exchange value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of this value as a dictionary.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields for this exchange value.\n    \"\"\"\n    fields: dict[str, str] = {}\n    # Amount formatted to exactly 2 decimal places\n    insert_required(fields, \"amount\", format_amount(self.amount))\n    insert_required(fields, \"currencyCode\", self.currency_code)\n    insert_if_present(fields, \"inKindDescription\", self.in_kind_description)\n    insert_required(fields, \"valueTypeUri\", self.value_type_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.in_kind","title":"in_kind  <code>classmethod</code>","text":"<pre><code>in_kind(amount: float, description: str) -&gt; ExchangeValue\n</code></pre> <p>Create an in-kind value with description.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef in_kind(cls, amount: float, description: str) -&gt; \"ExchangeValue\":\n    \"\"\"Create an in-kind value with description.\"\"\"\n    return cls(\n        amount=amount,\n        currency_code=\"USD\",\n        value_type_uri=ValueType.in_kind().type_uri,\n        in_kind_description=description,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.monetary","title":"monetary  <code>classmethod</code>","text":"<pre><code>monetary(\n    amount: float, currency_code: str = 'USD'\n) -&gt; ExchangeValue\n</code></pre> <p>Create a new monetary value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef monetary(cls, amount: float, currency_code: str = \"USD\") -&gt; \"ExchangeValue\":\n    \"\"\"Create a new monetary value.\"\"\"\n    return cls(amount=amount, currency_code=currency_code)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ExchangeValue.usd","title":"usd  <code>classmethod</code>","text":"<pre><code>usd(amount: float) -&gt; ExchangeValue\n</code></pre> <p>Create a new USD monetary value.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef usd(cls, amount: float) -&gt; \"ExchangeValue\":\n    \"\"\"Create a new USD monetary value.\"\"\"\n    return cls.monetary(amount, \"USD\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ValueType","title":"ValueType  <code>dataclass</code>","text":"<p>The type of value being exchanged.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@dataclass\nclass ValueType:\n    \"\"\"The type of value being exchanged.\"\"\"\n\n    type_uri: str\n\n    @classmethod\n    def monetary(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for monetary exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#monetary\"\n        )\n\n    @classmethod\n    def in_kind(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for in-kind exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#in-kind\"\n        )\n\n    @classmethod\n    def service_hours(cls) -&gt; \"ValueType\":\n        \"\"\"Return a ValueType for service hours exchanges.\"\"\"\n        return cls(\n            \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#service-hours\"\n        )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ValueType.in_kind","title":"in_kind  <code>classmethod</code>","text":"<pre><code>in_kind() -&gt; ValueType\n</code></pre> <p>Return a ValueType for in-kind exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef in_kind(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for in-kind exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#in-kind\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ValueType.monetary","title":"monetary  <code>classmethod</code>","text":"<pre><code>monetary() -&gt; ValueType\n</code></pre> <p>Return a ValueType for monetary exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef monetary(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for monetary exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#monetary\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.exchange.value.ValueType.service_hours","title":"service_hours  <code>classmethod</code>","text":"<pre><code>service_hours() -&gt; ValueType\n</code></pre> <p>Return a ValueType for service hours exchanges.</p> Source code in <code>src/python/src/civic_exchange_protocol/exchange/value.py</code> <pre><code>@classmethod\ndef service_hours(cls) -&gt; \"ValueType\":\n    \"\"\"Return a ValueType for service hours exchanges.\"\"\"\n    return cls(\n        \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/value-type.json#service-hours\"\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship","title":"relationship","text":"<p>CEP Relationship - Relationship records for the Civic Exchange Protocol.</p> <p>This package defines the RelationshipRecord type, which represents a verifiable legal or functional relationship between two or more attested entities.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.BilateralParties","title":"BilateralParties  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Bilateral parties in a two-party relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>@dataclass\nclass BilateralParties(Canonicalize):\n    \"\"\"Bilateral parties in a two-party relationship.\"\"\"\n\n    party_a: Party  # Initiating, granting, or contracting party\n    party_b: Party  # Receiving, performing, or beneficiary party\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of bilateral parties.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields with partyA and partyB.\n        \"\"\"\n        fields: dict[str, str] = {}\n        # Nested objects serialized as their canonical strings\n        insert_required(fields, \"partyA\", self.party_a.to_canonical_string())\n        insert_required(fields, \"partyB\", self.party_b.to_canonical_string())\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.BilateralParties.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of bilateral parties.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.BilateralParties.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields with partyA and partyB.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of bilateral parties.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields with partyA and partyB.\n    \"\"\"\n    fields: dict[str, str] = {}\n    # Nested objects serialized as their canonical strings\n    insert_required(fields, \"partyA\", self.party_a.to_canonical_string())\n    insert_required(fields, \"partyB\", self.party_b.to_canonical_string())\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.FinancialTerms","title":"FinancialTerms  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Financial terms of a relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass FinancialTerms(Canonicalize):\n    \"\"\"Financial terms of a relationship.\"\"\"\n\n    total_value: float | None = None\n    obligated_value: float | None = None\n    currency_code: str = \"USD\"\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of financial terms fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"currencyCode\", self.currency_code)\n        if self.obligated_value is not None:\n            insert_required(fields, \"obligatedValue\", format_amount(self.obligated_value))\n        if self.total_value is not None:\n            insert_required(fields, \"totalValue\", format_amount(self.total_value))\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.FinancialTerms.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of financial terms fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.FinancialTerms.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of financial terms fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"currencyCode\", self.currency_code)\n    if self.obligated_value is not None:\n        insert_required(fields, \"obligatedValue\", format_amount(self.obligated_value))\n    if self.total_value is not None:\n        insert_required(fields, \"totalValue\", format_amount(self.total_value))\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Member","title":"Member  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A member in a multilateral relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>@dataclass\nclass Member(Canonicalize):\n    \"\"\"A member in a multilateral relationship.\"\"\"\n\n    entity_id: str\n    role_uri: str\n    participation_share: float | None = None\n\n    def with_share(self, share: float) -&gt; \"Member\":\n        \"\"\"Return a new Member with the participation share set.\"\"\"\n        return Member(\n            entity_id=self.entity_id,\n            role_uri=self.role_uri,\n            participation_share=share,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the member.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing entityId, roleUri, and optionally participationShare.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        if self.participation_share is not None:\n            insert_required(fields, \"participationShare\", f\"{self.participation_share:.4f}\")\n        insert_required(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Member.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the member.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.Member.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing entityId, roleUri, and optionally participationShare.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the member.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing entityId, roleUri, and optionally participationShare.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    if self.participation_share is not None:\n        insert_required(fields, \"participationShare\", f\"{self.participation_share:.4f}\")\n    insert_required(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Member.with_share","title":"with_share","text":"<pre><code>with_share(share: float) -&gt; Member\n</code></pre> <p>Return a new Member with the participation share set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def with_share(self, share: float) -&gt; \"Member\":\n    \"\"\"Return a new Member with the participation share set.\"\"\"\n    return Member(\n        entity_id=self.entity_id,\n        role_uri=self.role_uri,\n        participation_share=share,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers","title":"MultilateralMembers","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A collection of members in a multilateral relationship.</p> <p>Members are automatically sorted by entity_id to ensure hash stability regardless of insertion order.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>class MultilateralMembers(Canonicalize):\n    \"\"\"A collection of members in a multilateral relationship.\n\n    Members are automatically sorted by entity_id to ensure\n    hash stability regardless of insertion order.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty collection of multilateral relationship members.\"\"\"\n        self._members: list[Member] = []\n\n    def add(self, member: Member) -&gt; None:\n        \"\"\"Add a member to the set.\"\"\"\n        # Check for duplicate entity_id\n        for existing in self._members:\n            if existing.entity_id == member.entity_id:\n                return  # Already exists\n        self._members.append(member)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of members in the collection.\"\"\"\n        return len(self._members)\n\n    def __iter__(self) -&gt; Iterator[Member]:\n        \"\"\"Iterate over members in sorted order by entity_id.\"\"\"\n        return iter(sorted(self._members, key=lambda m: m.entity_id))\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the collection has no members.\n\n        Returns:\n        -------\n        bool\n            True if the collection is empty, False otherwise.\n        \"\"\"\n        return len(self._members) == 0\n\n    def validate_shares(self) -&gt; None:\n        \"\"\"Validate that all participation shares sum to 1.0 (if present).\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        shares = [m.participation_share for m in self._members if m.participation_share is not None]\n\n        if not shares:\n            return\n\n        if len(shares) != len(self._members):\n            raise ValueError(\"All members must have participation shares if any do\")\n\n        total = sum(shares)\n        if abs(total - 1.0) &gt; 0.0001:\n            raise ValueError(f\"Participation shares must sum to 1.0, got {total:.4f}\")\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Serialize as array, members sorted by entity_id\n        if self._members:\n            sorted_members = sorted(self._members, key=lambda m: m.entity_id)\n            members_json = \",\".join(m.to_canonical_string() for m in sorted_members)\n            fields[\"members\"] = f\"[{members_json}]\"\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize an empty collection of multilateral relationship members.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty collection of multilateral relationship members.\"\"\"\n    self._members: list[Member] = []\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Member]\n</code></pre> <p>Iterate over members in sorted order by entity_id.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Member]:\n    \"\"\"Iterate over members in sorted order by entity_id.\"\"\"\n    return iter(sorted(self._members, key=lambda m: m.entity_id))\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of members in the collection.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of members in the collection.\"\"\"\n    return len(self._members)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.add","title":"add","text":"<pre><code>add(member: Member) -&gt; None\n</code></pre> <p>Add a member to the set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def add(self, member: Member) -&gt; None:\n    \"\"\"Add a member to the set.\"\"\"\n    # Check for duplicate entity_id\n    for existing in self._members:\n        if existing.entity_id == member.entity_id:\n            return  # Already exists\n    self._members.append(member)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Serialize as array, members sorted by entity_id\n    if self._members:\n        sorted_members = sorted(self._members, key=lambda m: m.entity_id)\n        members_json = \",\".join(m.to_canonical_string() for m in sorted_members)\n        fields[\"members\"] = f\"[{members_json}]\"\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the collection has no members.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.is_empty--returns","title":"Returns:","text":"<p>bool     True if the collection is empty, False otherwise.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the collection has no members.\n\n    Returns:\n    -------\n    bool\n        True if the collection is empty, False otherwise.\n    \"\"\"\n    return len(self._members) == 0\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.MultilateralMembers.validate_shares","title":"validate_shares","text":"<pre><code>validate_shares() -&gt; None\n</code></pre> <p>Validate that all participation shares sum to 1.0 (if present).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def validate_shares(self) -&gt; None:\n    \"\"\"Validate that all participation shares sum to 1.0 (if present).\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    shares = [m.participation_share for m in self._members if m.participation_share is not None]\n\n    if not shares:\n        return\n\n    if len(shares) != len(self._members):\n        raise ValueError(\"All members must have participation shares if any do\")\n\n    total = sum(shares)\n    if abs(total - 1.0) &gt; 0.0001:\n        raise ValueError(f\"Participation shares must sum to 1.0, got {total:.4f}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Party","title":"Party  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A party in a bilateral relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>@dataclass\nclass Party(Canonicalize):\n    \"\"\"A party in a bilateral relationship.\"\"\"\n\n    entity_id: str\n    role_uri: str\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the party.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields with entityId and roleUri.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_required(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.Party.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the party.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.Party.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields with entityId and roleUri.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the party.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields with entityId and roleUri.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_required(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord","title":"RelationshipRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Relationship Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass RelationshipRecord(Canonicalize):\n    \"\"\"A complete CEP Relationship Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    relationship_type_uri: str\n    parties: Parties\n    effective_timestamp: CanonicalTimestamp\n    status: RelationshipStatus\n    jurisdiction_iso: str\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    parent_relationship_id: str | None = None\n    expiration_timestamp: CanonicalTimestamp | None = None\n    financial_terms: FinancialTerms | None = None\n    terms_attributes: dict[str, str] | None = None\n    source_references: list[SourceReference] | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new_bilateral(\n        cls,\n        verifiable_id: str,\n        relationship_type_uri: str,\n        parties: BilateralParties,\n        effective_timestamp: CanonicalTimestamp,\n        status: RelationshipStatus,\n        jurisdiction_iso: str,\n        attestation: Attestation,\n    ) -&gt; \"RelationshipRecord\":\n        \"\"\"Create a new bilateral RelationshipRecord.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_type_uri=relationship_type_uri,\n            parties=parties,\n            effective_timestamp=effective_timestamp,\n            status=status,\n            jurisdiction_iso=jurisdiction_iso,\n            attestation=attestation,\n        )\n\n    @classmethod\n    def new_multilateral(\n        cls,\n        verifiable_id: str,\n        relationship_type_uri: str,\n        members: MultilateralMembers,\n        effective_timestamp: CanonicalTimestamp,\n        status: RelationshipStatus,\n        jurisdiction_iso: str,\n        attestation: Attestation,\n    ) -&gt; \"RelationshipRecord\":\n        \"\"\"Create a new multilateral RelationshipRecord.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_type_uri=relationship_type_uri,\n            parties=members,\n            effective_timestamp=effective_timestamp,\n            status=status,\n            jurisdiction_iso=jurisdiction_iso,\n            attestation=attestation,\n        )\n\n    def with_parent(self, parent_id: str) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with parent relationship set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=parent_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_expiration(self, timestamp: CanonicalTimestamp) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with expiration timestamp set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_financial_terms(self, terms: FinancialTerms) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with financial terms set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_source_reference(self, reference: SourceReference) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with a source reference added.\"\"\"\n        refs = list(self.source_references) if self.source_references else []\n        refs.append(reference)\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=refs,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with previous hash set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with revision number set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n        insert_required(\n            fields, \"effectiveTimestamp\", self.effective_timestamp.to_canonical_string()\n        )\n        if self.expiration_timestamp is not None:\n            insert_required(\n                fields, \"expirationTimestamp\", self.expiration_timestamp.to_canonical_string()\n            )\n        if self.financial_terms is not None:\n            insert_required(fields, \"financialTerms\", self.financial_terms.to_canonical_string())\n        insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n        insert_if_present(fields, \"parentRelationshipId\", self.parent_relationship_id)\n\n        # Parties (bilateral or multilateral)\n        if isinstance(self.parties, BilateralParties):\n            insert_required(fields, \"bilateralParties\", self.parties.to_canonical_string())\n        else:\n            insert_required(fields, \"multilateralMembers\", self.parties.to_canonical_string())\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n        insert_required(fields, \"relationshipTypeUri\", self.relationship_type_uri)\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Source references sorted by sourceSystemUri then sourceRecordId\n        if self.source_references:\n            sorted_refs = sorted(\n                self.source_references,\n                key=lambda r: (r.source_system_uri, r.source_record_id),\n            )\n            refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n            fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n\n        # Terms attributes (already sorted as dict)\n        if self.terms_attributes:\n            import json\n\n            fields[\"termsAttributes\"] = json.dumps(\n                dict(sorted(self.terms_attributes.items())), separators=(\",\", \":\")\n            )\n\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n    insert_required(\n        fields, \"effectiveTimestamp\", self.effective_timestamp.to_canonical_string()\n    )\n    if self.expiration_timestamp is not None:\n        insert_required(\n            fields, \"expirationTimestamp\", self.expiration_timestamp.to_canonical_string()\n        )\n    if self.financial_terms is not None:\n        insert_required(fields, \"financialTerms\", self.financial_terms.to_canonical_string())\n    insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n    insert_if_present(fields, \"parentRelationshipId\", self.parent_relationship_id)\n\n    # Parties (bilateral or multilateral)\n    if isinstance(self.parties, BilateralParties):\n        insert_required(fields, \"bilateralParties\", self.parties.to_canonical_string())\n    else:\n        insert_required(fields, \"multilateralMembers\", self.parties.to_canonical_string())\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n    insert_required(fields, \"relationshipTypeUri\", self.relationship_type_uri)\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Source references sorted by sourceSystemUri then sourceRecordId\n    if self.source_references:\n        sorted_refs = sorted(\n            self.source_references,\n            key=lambda r: (r.source_system_uri, r.source_record_id),\n        )\n        refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n        fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n\n    # Terms attributes (already sorted as dict)\n    if self.terms_attributes:\n        import json\n\n        fields[\"termsAttributes\"] = json.dumps(\n            dict(sorted(self.terms_attributes.items())), separators=(\",\", \":\")\n        )\n\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.new_bilateral","title":"new_bilateral  <code>classmethod</code>","text":"<pre><code>new_bilateral(\n    verifiable_id: str,\n    relationship_type_uri: str,\n    parties: BilateralParties,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; RelationshipRecord\n</code></pre> <p>Create a new bilateral RelationshipRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@classmethod\ndef new_bilateral(\n    cls,\n    verifiable_id: str,\n    relationship_type_uri: str,\n    parties: BilateralParties,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; \"RelationshipRecord\":\n    \"\"\"Create a new bilateral RelationshipRecord.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_type_uri=relationship_type_uri,\n        parties=parties,\n        effective_timestamp=effective_timestamp,\n        status=status,\n        jurisdiction_iso=jurisdiction_iso,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.new_multilateral","title":"new_multilateral  <code>classmethod</code>","text":"<pre><code>new_multilateral(\n    verifiable_id: str,\n    relationship_type_uri: str,\n    members: MultilateralMembers,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; RelationshipRecord\n</code></pre> <p>Create a new multilateral RelationshipRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@classmethod\ndef new_multilateral(\n    cls,\n    verifiable_id: str,\n    relationship_type_uri: str,\n    members: MultilateralMembers,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; \"RelationshipRecord\":\n    \"\"\"Create a new multilateral RelationshipRecord.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_type_uri=relationship_type_uri,\n        parties=members,\n        effective_timestamp=effective_timestamp,\n        status=status,\n        jurisdiction_iso=jurisdiction_iso,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_expiration","title":"with_expiration","text":"<pre><code>with_expiration(\n    timestamp: CanonicalTimestamp,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with expiration timestamp set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_expiration(self, timestamp: CanonicalTimestamp) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with expiration timestamp set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_financial_terms","title":"with_financial_terms","text":"<pre><code>with_financial_terms(\n    terms: FinancialTerms,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with financial terms set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_financial_terms(self, terms: FinancialTerms) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with financial terms set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_parent","title":"with_parent","text":"<pre><code>with_parent(parent_id: str) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with parent relationship set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_parent(self, parent_id: str) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with parent relationship set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=parent_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(\n    hash_val: CanonicalHash,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with previous hash set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with revision number set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipRecord.with_source_reference","title":"with_source_reference","text":"<pre><code>with_source_reference(\n    reference: SourceReference,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with a source reference added.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_source_reference(self, reference: SourceReference) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with a source reference added.\"\"\"\n    refs = list(self.source_references) if self.source_references else []\n    refs.append(reference)\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=refs,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatus","title":"RelationshipStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Relationship status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass RelationshipStatus(Canonicalize):\n    \"\"\"Relationship status information.\"\"\"\n\n    status_code: RelationshipStatusCode\n    status_effective_timestamp: CanonicalTimestamp\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of relationship status fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(\n            fields,\n            \"statusEffectiveTimestamp\",\n            self.status_effective_timestamp.to_canonical_string(),\n        )\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of relationship status fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatus.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of relationship status fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(\n        fields,\n        \"statusEffectiveTimestamp\",\n        self.status_effective_timestamp.to_canonical_string(),\n    )\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatusCode","title":"RelationshipStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Relationship operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>class RelationshipStatusCode(Enum):\n    \"\"\"Relationship operational status.\"\"\"\n\n    PENDING = \"PENDING\"\n    ACTIVE = \"ACTIVE\"\n    SUSPENDED = \"SUSPENDED\"\n    COMPLETED = \"COMPLETED\"\n    TERMINATED = \"TERMINATED\"\n    AMENDED = \"AMENDED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string value of the relationship status code.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.RelationshipStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string value of the relationship status code.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string value of the relationship status code.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.SourceReference","title":"SourceReference  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Reference to an authoritative source record.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass SourceReference(Canonicalize):\n    \"\"\"Reference to an authoritative source record.\"\"\"\n\n    source_system_uri: str\n    source_record_id: str\n    source_url: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of source reference fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"sourceRecordId\", self.source_record_id)\n        insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n        insert_if_present(fields, \"sourceUrl\", self.source_url)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.SourceReference.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of source reference fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.SourceReference.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of source reference fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"sourceRecordId\", self.source_record_id)\n    insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n    insert_if_present(fields, \"sourceUrl\", self.source_url)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral","title":"bilateral","text":"<p>Bilateral party definitions for two-party relationships.</p> <p>Bilateral relationships have clear directionality: - Party A: The initiating, granting, or contracting party - Party B: The receiving, performing, or beneficiary party</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.BilateralParties","title":"BilateralParties  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Bilateral parties in a two-party relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>@dataclass\nclass BilateralParties(Canonicalize):\n    \"\"\"Bilateral parties in a two-party relationship.\"\"\"\n\n    party_a: Party  # Initiating, granting, or contracting party\n    party_b: Party  # Receiving, performing, or beneficiary party\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of bilateral parties.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields with partyA and partyB.\n        \"\"\"\n        fields: dict[str, str] = {}\n        # Nested objects serialized as their canonical strings\n        insert_required(fields, \"partyA\", self.party_a.to_canonical_string())\n        insert_required(fields, \"partyB\", self.party_b.to_canonical_string())\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.BilateralParties.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of bilateral parties.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.BilateralParties.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields with partyA and partyB.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of bilateral parties.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields with partyA and partyB.\n    \"\"\"\n    fields: dict[str, str] = {}\n    # Nested objects serialized as their canonical strings\n    insert_required(fields, \"partyA\", self.party_a.to_canonical_string())\n    insert_required(fields, \"partyB\", self.party_b.to_canonical_string())\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.Party","title":"Party  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A party in a bilateral relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>@dataclass\nclass Party(Canonicalize):\n    \"\"\"A party in a bilateral relationship.\"\"\"\n\n    entity_id: str\n    role_uri: str\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the party.\n\n        Returns:\n        -------\n        dict[str, str]\n            A dictionary containing the canonical fields with entityId and roleUri.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        insert_required(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.Party.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the party.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.bilateral.Party.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     A dictionary containing the canonical fields with entityId and roleUri.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/bilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the party.\n\n    Returns:\n    -------\n    dict[str, str]\n        A dictionary containing the canonical fields with entityId and roleUri.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    insert_required(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral","title":"multilateral","text":"<p>Multilateral member definitions for n-ary relationships.</p> <p>Multilateral relationships involve more than two parties, such as: - Consortia - Joint ventures - Board memberships</p> <p>Members are sorted by entity_id to guarantee deterministic ordering for hash stability across all implementations.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.Member","title":"Member  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A member in a multilateral relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>@dataclass\nclass Member(Canonicalize):\n    \"\"\"A member in a multilateral relationship.\"\"\"\n\n    entity_id: str\n    role_uri: str\n    participation_share: float | None = None\n\n    def with_share(self, share: float) -&gt; \"Member\":\n        \"\"\"Return a new Member with the participation share set.\"\"\"\n        return Member(\n            entity_id=self.entity_id,\n            role_uri=self.role_uri,\n            participation_share=share,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical field representation of the member.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing entityId, roleUri, and optionally participationShare.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"entityId\", self.entity_id)\n        if self.participation_share is not None:\n            insert_required(fields, \"participationShare\", f\"{self.participation_share:.4f}\")\n        insert_required(fields, \"roleUri\", self.role_uri)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.Member.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical field representation of the member.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.Member.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing entityId, roleUri, and optionally participationShare.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical field representation of the member.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing entityId, roleUri, and optionally participationShare.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"entityId\", self.entity_id)\n    if self.participation_share is not None:\n        insert_required(fields, \"participationShare\", f\"{self.participation_share:.4f}\")\n    insert_required(fields, \"roleUri\", self.role_uri)\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.Member.with_share","title":"with_share","text":"<pre><code>with_share(share: float) -&gt; Member\n</code></pre> <p>Return a new Member with the participation share set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def with_share(self, share: float) -&gt; \"Member\":\n    \"\"\"Return a new Member with the participation share set.\"\"\"\n    return Member(\n        entity_id=self.entity_id,\n        role_uri=self.role_uri,\n        participation_share=share,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers","title":"MultilateralMembers","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A collection of members in a multilateral relationship.</p> <p>Members are automatically sorted by entity_id to ensure hash stability regardless of insertion order.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>class MultilateralMembers(Canonicalize):\n    \"\"\"A collection of members in a multilateral relationship.\n\n    Members are automatically sorted by entity_id to ensure\n    hash stability regardless of insertion order.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty collection of multilateral relationship members.\"\"\"\n        self._members: list[Member] = []\n\n    def add(self, member: Member) -&gt; None:\n        \"\"\"Add a member to the set.\"\"\"\n        # Check for duplicate entity_id\n        for existing in self._members:\n            if existing.entity_id == member.entity_id:\n                return  # Already exists\n        self._members.append(member)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of members in the collection.\"\"\"\n        return len(self._members)\n\n    def __iter__(self) -&gt; Iterator[Member]:\n        \"\"\"Iterate over members in sorted order by entity_id.\"\"\"\n        return iter(sorted(self._members, key=lambda m: m.entity_id))\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the collection has no members.\n\n        Returns:\n        -------\n        bool\n            True if the collection is empty, False otherwise.\n        \"\"\"\n        return len(self._members) == 0\n\n    def validate_shares(self) -&gt; None:\n        \"\"\"Validate that all participation shares sum to 1.0 (if present).\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        shares = [m.participation_share for m in self._members if m.participation_share is not None]\n\n        if not shares:\n            return\n\n        if len(shares) != len(self._members):\n            raise ValueError(\"All members must have participation shares if any do\")\n\n        total = sum(shares)\n        if abs(total - 1.0) &gt; 0.0001:\n            raise ValueError(f\"Participation shares must sum to 1.0, got {total:.4f}\")\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields.\"\"\"\n        fields: dict[str, str] = {}\n\n        # Serialize as array, members sorted by entity_id\n        if self._members:\n            sorted_members = sorted(self._members, key=lambda m: m.entity_id)\n            members_json = \",\".join(m.to_canonical_string() for m in sorted_members)\n            fields[\"members\"] = f\"[{members_json}]\"\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize an empty collection of multilateral relationship members.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty collection of multilateral relationship members.\"\"\"\n    self._members: list[Member] = []\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Member]\n</code></pre> <p>Iterate over members in sorted order by entity_id.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Member]:\n    \"\"\"Iterate over members in sorted order by entity_id.\"\"\"\n    return iter(sorted(self._members, key=lambda m: m.entity_id))\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of members in the collection.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of members in the collection.\"\"\"\n    return len(self._members)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.add","title":"add","text":"<pre><code>add(member: Member) -&gt; None\n</code></pre> <p>Add a member to the set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def add(self, member: Member) -&gt; None:\n    \"\"\"Add a member to the set.\"\"\"\n    # Check for duplicate entity_id\n    for existing in self._members:\n        if existing.entity_id == member.entity_id:\n            return  # Already exists\n    self._members.append(member)\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields.\"\"\"\n    fields: dict[str, str] = {}\n\n    # Serialize as array, members sorted by entity_id\n    if self._members:\n        sorted_members = sorted(self._members, key=lambda m: m.entity_id)\n        members_json = \",\".join(m.to_canonical_string() for m in sorted_members)\n        fields[\"members\"] = f\"[{members_json}]\"\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the collection has no members.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.is_empty--returns","title":"Returns:","text":"<p>bool     True if the collection is empty, False otherwise.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the collection has no members.\n\n    Returns:\n    -------\n    bool\n        True if the collection is empty, False otherwise.\n    \"\"\"\n    return len(self._members) == 0\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.multilateral.MultilateralMembers.validate_shares","title":"validate_shares","text":"<pre><code>validate_shares() -&gt; None\n</code></pre> <p>Validate that all participation shares sum to 1.0 (if present).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/multilateral.py</code> <pre><code>def validate_shares(self) -&gt; None:\n    \"\"\"Validate that all participation shares sum to 1.0 (if present).\n\n    Raises:\n        ValueError: If validation fails.\n    \"\"\"\n    shares = [m.participation_share for m in self._members if m.participation_share is not None]\n\n    if not shares:\n        return\n\n    if len(shares) != len(self._members):\n        raise ValueError(\"All members must have participation shares if any do\")\n\n    total = sum(shares)\n    if abs(total - 1.0) &gt; 0.0001:\n        raise ValueError(f\"Participation shares must sum to 1.0, got {total:.4f}\")\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship","title":"relationship","text":"<p>CEP Relationship Record definition.</p> <p>A Relationship Record represents a verifiable legal or functional relationship between two or more attested entities.</p> <p>Relationships can be: - Bilateral: Two-party relationships with clear directionality (contracts, grants) - Multilateral: N-ary relationships (consortia, boards, joint ventures)</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.FinancialTerms","title":"FinancialTerms  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Financial terms of a relationship.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass FinancialTerms(Canonicalize):\n    \"\"\"Financial terms of a relationship.\"\"\"\n\n    total_value: float | None = None\n    obligated_value: float | None = None\n    currency_code: str = \"USD\"\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of financial terms fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"currencyCode\", self.currency_code)\n        if self.obligated_value is not None:\n            insert_required(fields, \"obligatedValue\", format_amount(self.obligated_value))\n        if self.total_value is not None:\n            insert_required(fields, \"totalValue\", format_amount(self.total_value))\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.FinancialTerms.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of financial terms fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.FinancialTerms.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of financial terms fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"currencyCode\", self.currency_code)\n    if self.obligated_value is not None:\n        insert_required(fields, \"obligatedValue\", format_amount(self.obligated_value))\n    if self.total_value is not None:\n        insert_required(fields, \"totalValue\", format_amount(self.total_value))\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord","title":"RelationshipRecord  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>A complete CEP Relationship Record.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass RelationshipRecord(Canonicalize):\n    \"\"\"A complete CEP Relationship Record.\"\"\"\n\n    # Required fields\n    verifiable_id: str\n    relationship_type_uri: str\n    parties: Parties\n    effective_timestamp: CanonicalTimestamp\n    status: RelationshipStatus\n    jurisdiction_iso: str\n    attestation: Attestation\n\n    # Optional fields\n    schema_version: str = field(default=SCHEMA_VERSION)\n    parent_relationship_id: str | None = None\n    expiration_timestamp: CanonicalTimestamp | None = None\n    financial_terms: FinancialTerms | None = None\n    terms_attributes: dict[str, str] | None = None\n    source_references: list[SourceReference] | None = None\n    previous_record_hash: CanonicalHash | None = None\n    revision_number: int = 1\n\n    @classmethod\n    def new_bilateral(\n        cls,\n        verifiable_id: str,\n        relationship_type_uri: str,\n        parties: BilateralParties,\n        effective_timestamp: CanonicalTimestamp,\n        status: RelationshipStatus,\n        jurisdiction_iso: str,\n        attestation: Attestation,\n    ) -&gt; \"RelationshipRecord\":\n        \"\"\"Create a new bilateral RelationshipRecord.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_type_uri=relationship_type_uri,\n            parties=parties,\n            effective_timestamp=effective_timestamp,\n            status=status,\n            jurisdiction_iso=jurisdiction_iso,\n            attestation=attestation,\n        )\n\n    @classmethod\n    def new_multilateral(\n        cls,\n        verifiable_id: str,\n        relationship_type_uri: str,\n        members: MultilateralMembers,\n        effective_timestamp: CanonicalTimestamp,\n        status: RelationshipStatus,\n        jurisdiction_iso: str,\n        attestation: Attestation,\n    ) -&gt; \"RelationshipRecord\":\n        \"\"\"Create a new multilateral RelationshipRecord.\"\"\"\n        return cls(\n            verifiable_id=verifiable_id,\n            relationship_type_uri=relationship_type_uri,\n            parties=members,\n            effective_timestamp=effective_timestamp,\n            status=status,\n            jurisdiction_iso=jurisdiction_iso,\n            attestation=attestation,\n        )\n\n    def with_parent(self, parent_id: str) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with parent relationship set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=parent_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_expiration(self, timestamp: CanonicalTimestamp) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with expiration timestamp set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_financial_terms(self, terms: FinancialTerms) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with financial terms set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_source_reference(self, reference: SourceReference) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with a source reference added.\"\"\"\n        refs = list(self.source_references) if self.source_references else []\n        refs.append(reference)\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=refs,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=self.revision_number,\n        )\n\n    def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with previous hash set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=hash_val,\n            revision_number=self.revision_number,\n        )\n\n    def with_revision(self, revision: int) -&gt; \"RelationshipRecord\":\n        \"\"\"Return a new RelationshipRecord with revision number set.\"\"\"\n        return RelationshipRecord(\n            verifiable_id=self.verifiable_id,\n            relationship_type_uri=self.relationship_type_uri,\n            parties=self.parties,\n            effective_timestamp=self.effective_timestamp,\n            status=self.status,\n            jurisdiction_iso=self.jurisdiction_iso,\n            attestation=self.attestation,\n            schema_version=self.schema_version,\n            parent_relationship_id=self.parent_relationship_id,\n            expiration_timestamp=self.expiration_timestamp,\n            financial_terms=self.financial_terms,\n            terms_attributes=self.terms_attributes,\n            source_references=self.source_references,\n            previous_record_hash=self.previous_record_hash,\n            revision_number=revision,\n        )\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n        fields: dict[str, str] = {}\n\n        # All fields in alphabetical order\n        insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n        insert_required(\n            fields, \"effectiveTimestamp\", self.effective_timestamp.to_canonical_string()\n        )\n        if self.expiration_timestamp is not None:\n            insert_required(\n                fields, \"expirationTimestamp\", self.expiration_timestamp.to_canonical_string()\n            )\n        if self.financial_terms is not None:\n            insert_required(fields, \"financialTerms\", self.financial_terms.to_canonical_string())\n        insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n        insert_if_present(fields, \"parentRelationshipId\", self.parent_relationship_id)\n\n        # Parties (bilateral or multilateral)\n        if isinstance(self.parties, BilateralParties):\n            insert_required(fields, \"bilateralParties\", self.parties.to_canonical_string())\n        else:\n            insert_required(fields, \"multilateralMembers\", self.parties.to_canonical_string())\n\n        if self.previous_record_hash is not None:\n            insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n        insert_required(fields, \"relationshipTypeUri\", self.relationship_type_uri)\n        insert_required(fields, \"revisionNumber\", str(self.revision_number))\n        insert_required(fields, \"schemaVersion\", self.schema_version)\n\n        # Source references sorted by sourceSystemUri then sourceRecordId\n        if self.source_references:\n            sorted_refs = sorted(\n                self.source_references,\n                key=lambda r: (r.source_system_uri, r.source_record_id),\n            )\n            refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n            fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n        insert_required(fields, \"status\", self.status.to_canonical_string())\n\n        # Terms attributes (already sorted as dict)\n        if self.terms_attributes:\n            import json\n\n            fields[\"termsAttributes\"] = json.dumps(\n                dict(sorted(self.terms_attributes.items())), separators=(\",\", \":\")\n            )\n\n        insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical fields in alphabetical order.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical fields in alphabetical order.\"\"\"\n    fields: dict[str, str] = {}\n\n    # All fields in alphabetical order\n    insert_required(fields, \"attestation\", self.attestation.to_canonical_string())\n    insert_required(\n        fields, \"effectiveTimestamp\", self.effective_timestamp.to_canonical_string()\n    )\n    if self.expiration_timestamp is not None:\n        insert_required(\n            fields, \"expirationTimestamp\", self.expiration_timestamp.to_canonical_string()\n        )\n    if self.financial_terms is not None:\n        insert_required(fields, \"financialTerms\", self.financial_terms.to_canonical_string())\n    insert_required(fields, \"jurisdictionIso\", self.jurisdiction_iso)\n    insert_if_present(fields, \"parentRelationshipId\", self.parent_relationship_id)\n\n    # Parties (bilateral or multilateral)\n    if isinstance(self.parties, BilateralParties):\n        insert_required(fields, \"bilateralParties\", self.parties.to_canonical_string())\n    else:\n        insert_required(fields, \"multilateralMembers\", self.parties.to_canonical_string())\n\n    if self.previous_record_hash is not None:\n        insert_required(fields, \"previousRecordHash\", self.previous_record_hash.as_hex())\n    insert_required(fields, \"relationshipTypeUri\", self.relationship_type_uri)\n    insert_required(fields, \"revisionNumber\", str(self.revision_number))\n    insert_required(fields, \"schemaVersion\", self.schema_version)\n\n    # Source references sorted by sourceSystemUri then sourceRecordId\n    if self.source_references:\n        sorted_refs = sorted(\n            self.source_references,\n            key=lambda r: (r.source_system_uri, r.source_record_id),\n        )\n        refs_json = \",\".join(r.to_canonical_string() for r in sorted_refs)\n        fields[\"sourceReferences\"] = f\"[{refs_json}]\"\n\n    insert_required(fields, \"status\", self.status.to_canonical_string())\n\n    # Terms attributes (already sorted as dict)\n    if self.terms_attributes:\n        import json\n\n        fields[\"termsAttributes\"] = json.dumps(\n            dict(sorted(self.terms_attributes.items())), separators=(\",\", \":\")\n        )\n\n    insert_required(fields, \"verifiableId\", self.verifiable_id)\n\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.new_bilateral","title":"new_bilateral  <code>classmethod</code>","text":"<pre><code>new_bilateral(\n    verifiable_id: str,\n    relationship_type_uri: str,\n    parties: BilateralParties,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; RelationshipRecord\n</code></pre> <p>Create a new bilateral RelationshipRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@classmethod\ndef new_bilateral(\n    cls,\n    verifiable_id: str,\n    relationship_type_uri: str,\n    parties: BilateralParties,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; \"RelationshipRecord\":\n    \"\"\"Create a new bilateral RelationshipRecord.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_type_uri=relationship_type_uri,\n        parties=parties,\n        effective_timestamp=effective_timestamp,\n        status=status,\n        jurisdiction_iso=jurisdiction_iso,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.new_multilateral","title":"new_multilateral  <code>classmethod</code>","text":"<pre><code>new_multilateral(\n    verifiable_id: str,\n    relationship_type_uri: str,\n    members: MultilateralMembers,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; RelationshipRecord\n</code></pre> <p>Create a new multilateral RelationshipRecord.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@classmethod\ndef new_multilateral(\n    cls,\n    verifiable_id: str,\n    relationship_type_uri: str,\n    members: MultilateralMembers,\n    effective_timestamp: CanonicalTimestamp,\n    status: RelationshipStatus,\n    jurisdiction_iso: str,\n    attestation: Attestation,\n) -&gt; \"RelationshipRecord\":\n    \"\"\"Create a new multilateral RelationshipRecord.\"\"\"\n    return cls(\n        verifiable_id=verifiable_id,\n        relationship_type_uri=relationship_type_uri,\n        parties=members,\n        effective_timestamp=effective_timestamp,\n        status=status,\n        jurisdiction_iso=jurisdiction_iso,\n        attestation=attestation,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_expiration","title":"with_expiration","text":"<pre><code>with_expiration(\n    timestamp: CanonicalTimestamp,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with expiration timestamp set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_expiration(self, timestamp: CanonicalTimestamp) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with expiration timestamp set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_financial_terms","title":"with_financial_terms","text":"<pre><code>with_financial_terms(\n    terms: FinancialTerms,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with financial terms set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_financial_terms(self, terms: FinancialTerms) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with financial terms set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_parent","title":"with_parent","text":"<pre><code>with_parent(parent_id: str) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with parent relationship set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_parent(self, parent_id: str) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with parent relationship set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=parent_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_previous_hash","title":"with_previous_hash","text":"<pre><code>with_previous_hash(\n    hash_val: CanonicalHash,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with previous hash set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_previous_hash(self, hash_val: CanonicalHash) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with previous hash set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=hash_val,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_revision","title":"with_revision","text":"<pre><code>with_revision(revision: int) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with revision number set.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_revision(self, revision: int) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with revision number set.\"\"\"\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=self.source_references,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=revision,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipRecord.with_source_reference","title":"with_source_reference","text":"<pre><code>with_source_reference(\n    reference: SourceReference,\n) -&gt; RelationshipRecord\n</code></pre> <p>Return a new RelationshipRecord with a source reference added.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def with_source_reference(self, reference: SourceReference) -&gt; \"RelationshipRecord\":\n    \"\"\"Return a new RelationshipRecord with a source reference added.\"\"\"\n    refs = list(self.source_references) if self.source_references else []\n    refs.append(reference)\n    return RelationshipRecord(\n        verifiable_id=self.verifiable_id,\n        relationship_type_uri=self.relationship_type_uri,\n        parties=self.parties,\n        effective_timestamp=self.effective_timestamp,\n        status=self.status,\n        jurisdiction_iso=self.jurisdiction_iso,\n        attestation=self.attestation,\n        schema_version=self.schema_version,\n        parent_relationship_id=self.parent_relationship_id,\n        expiration_timestamp=self.expiration_timestamp,\n        financial_terms=self.financial_terms,\n        terms_attributes=self.terms_attributes,\n        source_references=refs,\n        previous_record_hash=self.previous_record_hash,\n        revision_number=self.revision_number,\n    )\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatus","title":"RelationshipStatus  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Relationship status information.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass RelationshipStatus(Canonicalize):\n    \"\"\"Relationship status information.\"\"\"\n\n    status_code: RelationshipStatusCode\n    status_effective_timestamp: CanonicalTimestamp\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of relationship status fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"statusCode\", self.status_code.as_str())\n        insert_required(\n            fields,\n            \"statusEffectiveTimestamp\",\n            self.status_effective_timestamp.to_canonical_string(),\n        )\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatus.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of relationship status fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatus.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of relationship status fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"statusCode\", self.status_code.as_str())\n    insert_required(\n        fields,\n        \"statusEffectiveTimestamp\",\n        self.status_effective_timestamp.to_canonical_string(),\n    )\n    return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatusCode","title":"RelationshipStatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Relationship operational status.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>class RelationshipStatusCode(Enum):\n    \"\"\"Relationship operational status.\"\"\"\n\n    PENDING = \"PENDING\"\n    ACTIVE = \"ACTIVE\"\n    SUSPENDED = \"SUSPENDED\"\n    COMPLETED = \"COMPLETED\"\n    TERMINATED = \"TERMINATED\"\n    AMENDED = \"AMENDED\"\n\n    def as_str(self) -&gt; str:\n        \"\"\"Return the string value of the relationship status code.\"\"\"\n        return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.RelationshipStatusCode.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return the string value of the relationship status code.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return the string value of the relationship status code.\"\"\"\n    return self.value\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.SourceReference","title":"SourceReference  <code>dataclass</code>","text":"<p>               Bases: <code>Canonicalize</code></p> <p>Reference to an authoritative source record.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>@dataclass\nclass SourceReference(Canonicalize):\n    \"\"\"Reference to an authoritative source record.\"\"\"\n\n    source_system_uri: str\n    source_record_id: str\n    source_url: str | None = None\n\n    def canonical_fields(self) -&gt; dict[str, str]:\n        \"\"\"Return the canonical representation of source reference fields.\n\n        Returns:\n        -------\n        dict[str, str]\n            Dictionary containing the canonical field representations.\n        \"\"\"\n        fields: dict[str, str] = {}\n        insert_required(fields, \"sourceRecordId\", self.source_record_id)\n        insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n        insert_if_present(fields, \"sourceUrl\", self.source_url)\n        return fields\n</code></pre>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.SourceReference.canonical_fields","title":"canonical_fields","text":"<pre><code>canonical_fields() -&gt; dict[str, str]\n</code></pre> <p>Return the canonical representation of source reference fields.</p>"},{"location":"en/api/#civic_exchange_protocol.relationship.relationship.SourceReference.canonical_fields--returns","title":"Returns:","text":"<p>dict[str, str]     Dictionary containing the canonical field representations.</p> Source code in <code>src/python/src/civic_exchange_protocol/relationship/relationship.py</code> <pre><code>def canonical_fields(self) -&gt; dict[str, str]:\n    \"\"\"Return the canonical representation of source reference fields.\n\n    Returns:\n    -------\n    dict[str, str]\n        Dictionary containing the canonical field representations.\n    \"\"\"\n    fields: dict[str, str] = {}\n    insert_required(fields, \"sourceRecordId\", self.source_record_id)\n    insert_required(fields, \"sourceSystemUri\", self.source_system_uri)\n    insert_if_present(fields, \"sourceUrl\", self.source_url)\n    return fields\n</code></pre>"},{"location":"en/cli/","title":"CLI Reference","text":""},{"location":"en/cli/#quick-help","title":"Quick help","text":"<pre><code># Show top-level help\ncx --help\n\n# Show help for a subcommand\ncx &lt;subcommand&gt; --help\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/","title":"Category Theory Foundation for CEP","text":""},{"location":"en/concepts/category-theory-foundation/#overview","title":"Overview","text":"<p>This document provides a formal categorical semantics for the Civic Exchange Protocol (CEP). The goal is to prove that the system's design is mathematically sound, ensuring that compositions of civic relationships and exchanges behave predictably and that the Verifiable ID system constitutes a proper universal construction.</p>"},{"location":"en/concepts/category-theory-foundation/#1-the-category-civic","title":"1. The Category Civic","text":"<p>We define a category Civic as follows:</p>"},{"location":"en/concepts/category-theory-foundation/#objects","title":"Objects","text":"<p>The objects of Civic are attested civic entities. Each object E represents: - A verified legal entity (government agency, contractor, nonprofit, individual) - With a canonical Verifiable ID - At a specific point in time (revision number)</p> <p>Formally: <code>Ob(Civic) = { E | E is a valid CEP entity record }</code></p>"},{"location":"en/concepts/category-theory-foundation/#morphisms","title":"Morphisms","text":"<p>The morphisms in Civic are relationships and exchanges between entities. A morphism <code>f: A \u2192 B</code> represents a directed flow of legal obligation, value, or authority from entity A to entity B.</p> <p>There are two kinds of morphisms:</p> <ol> <li>Relationship morphisms: Represent the legal basis for interaction</li> <li><code>grant: FederalAgency \u2192 StateAgency</code></li> <li><code>contract: Agency \u2192 Contractor</code></li> <li> <p><code>subcontract: PrimeContractor \u2192 Subcontractor</code></p> </li> <li> <p>Exchange morphisms: Represent actual value flows within relationships</p> </li> <li><code>disburse: GrantingAgency \u2192 Grantee</code></li> <li><code>pay: ContractingOffice \u2192 Vendor</code></li> </ol>"},{"location":"en/concepts/category-theory-foundation/#identity-morphism","title":"Identity Morphism","text":"<p>For each entity E, the identity morphism <code>id_E: E \u2192 E</code> represents the entity's self-attestation\u2014the record where the entity attests to its own existence and status. This is the initial entity record with <code>previousRecordHash = null</code>.</p>"},{"location":"en/concepts/category-theory-foundation/#composition","title":"Composition","text":"<p>Given morphisms <code>f: A \u2192 B</code> and <code>g: B \u2192 C</code>, the composition <code>g \u2218 f: A \u2192 C</code> represents the compositional provenance chain.</p> <p>Example: Federal grant flows through a state to a local school district:</p> <pre><code>f: FederalDOE \u2192 StateEducationDept    (grant-award relationship)\ng: StateEducationDept \u2192 LocalDistrict  (subgrant relationship)\n\ng \u2218 f: FederalDOE \u2192 LocalDistrict      (derived provenance)\n</code></pre> <p>This composition is captured in the <code>provenanceChain.fundingChainTag</code> field as <code>FEDERAL&gt;STATE&gt;LOCAL</code>.</p>"},{"location":"en/concepts/category-theory-foundation/#associativity","title":"Associativity","text":"<p>Composition must be associative: <code>(h \u2218 g) \u2218 f = h \u2218 (g \u2218 f)</code></p> <p>For provenance chains: <pre><code>FED \u2192 STATE \u2192 COUNTY \u2192 CONTRACTOR\n\n((FED \u2192 STATE) \u2192 COUNTY) \u2192 CONTRACTOR = (FED \u2192 STATE) \u2192 (COUNTY \u2192 CONTRACTOR)\n</code></pre></p> <p>Both yield the same ultimate provenance: funds originating from FED, flowing through STATE and COUNTY, to CONTRACTOR. The <code>fundingChainTag</code> is identical regardless of grouping.</p> <p>Implementation guarantee: The <code>parentRelationshipId</code> and <code>parentExchangeId</code> fields create an explicit linked list that ensures associativity. You can trace back from any exchange to its ultimate source by following the chain.</p>"},{"location":"en/concepts/category-theory-foundation/#2-the-verifiable-id-as-a-universal-property","title":"2. The Verifiable ID as a Universal Property","text":""},{"location":"en/concepts/category-theory-foundation/#the-problem-multiple-representations","title":"The Problem: Multiple Representations","text":"<p>A single real-world entity may appear in many source systems with different identifiers: - SAM.gov: <code>J6H4FB3N5YK7</code> - State campaign finance: <code>VENDOR-2024-0093</code> - County procurement: <code>Acme Consulting LLC</code> (no ID, just a name) - Federal LEI system: <code>5493001KJTIIGC8Y1R12</code></p> <p>Each source system defines its own category of records, call them SAM, StateCF, CountyProc, LEI.</p>"},{"location":"en/concepts/category-theory-foundation/#the-diagram-to-commute","title":"The Diagram to Commute","text":"<p>We have partial identity mappings (entity resolution functions) between these systems: <pre><code>        SAM\n         \u2191\n         |  \u03c6_sam\n         |\n      ENTITY  \u2190---------- LEI\n         |      \u03c6_lei\n         |\n         \u2193  \u03c6_county\n    CountyProc\n</code></pre></p> <p>Each <code>\u03c6_X</code> is a functor from the source category to Civic that maps source records to entities.</p>"},{"location":"en/concepts/category-theory-foundation/#the-limit-construction","title":"The Limit Construction","text":"<p>The Entity <code>verifiableId</code> acts as the limit (specifically, a product in the relevant slice category) of the diagram of source identifiers.</p> <p>Definition: For an entity E appearing in source systems S\u2081, S\u2082, ..., S\u2099 with identifiers id\u2081, id\u2082, ..., id\u2099 respectively, the Verifiable ID is the unique object V equipped with projections: <pre><code>\u03c0_1: V \u2192 S\u2081   (maps V to id\u2081)\n\u03c0_2: V \u2192 S\u2082   (maps V to id\u2082)\n...\n\u03c0_n: V \u2192 S\u2099   (maps V to id\u2099)\n</code></pre></p> <p>Such that for any other object W with maps to all S\u1d62, there exists a unique map <code>u: W \u2192 V</code> making all triangles commute.</p> <p>In CEP terms: The <code>identifiers</code> object in entity is exactly this limit, it holds all known identifiers for the entity:</p> <pre><code>\"identifiers\": {\n  \"samUei\": \"J6H4FB3N5YK7\",\n  \"lei\": \"5493001KJTIIGC8Y1R12\",\n  \"snfei\": \"a3b2c1d4e5f6...\",\n  \"additionalSchemes\": [\n    {\"schemeUri\": \"https://state.gov/cf\", \"value\": \"VENDOR-2024-0093\"}\n  ]\n}\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-universal-property-guarantee","title":"The Universal Property Guarantee","text":"<p>The <code>verifiableId</code> (<code>entity:{scheme}:{value}</code>) provides the universal property:</p> <ol> <li> <p>Existence: For any entity in any source system, there exists an entity record with a verifiableId that subsumes all its known identifiers.</p> </li> <li> <p>Uniqueness: If two entity records claim to represent the same entity (have overlapping source identifiers), they MUST have the same verifiableId\u2014or one is an error requiring resolution.</p> </li> <li> <p>Confidence-Weighted Resolution: The <code>resolutionConfidence.score</code> field acknowledges that in practice, entity resolution is probabilistic. A score of 1.0 indicates authoritative identity (the entity self-attested or the source is canonical). Lower scores indicate probabilistic matching.</p> </li> </ol>"},{"location":"en/concepts/category-theory-foundation/#3-functors-the-bridge-to-external-standards","title":"3. Functors: The Bridge to External Standards","text":""},{"location":"en/concepts/category-theory-foundation/#the-xbrl-functor","title":"The XBRL Functor","text":"<p>Define <code>F_xbrl: Civic \u2192 XBRL</code> as a functor mapping: - entities \u2192 XBRL reporting entities - exchanges \u2192 XBRL fact instances</p> <p>This functor must preserve composition: if <code>g \u2218 f</code> is a provenance chain in Civic, then <code>F(g) \u2218 F(f)</code> must be a valid XBRL reporting chain.</p> <p>Implementation: The <code>categorization.gtasAccountCode</code> field in exchange records provides the data needed for this functor to operate\u2014it maps CEP exchanges to Treasury reporting concepts.</p>"},{"location":"en/concepts/category-theory-foundation/#the-w3c-prov-functor","title":"The W3C PROV Functor","text":"<p>Define <code>F_prov: Civic \u2192 PROV</code> mapping: - entities \u2192 <code>prov:Entity</code> - relationships \u2192 <code>prov:Activity</code> (the act of establishing a relationship) - exchanges \u2192 <code>prov:Activity</code> (the act of exchanging value) - Attestations \u2192 <code>prov:Agent</code> + <code>prov:wasAttributedTo</code></p> <p>The <code>attestation</code> block in every CEP record provides exactly the data needed for this mapping: - <code>attestorId</code> \u2192 <code>prov:Agent</code> - <code>attestationTimestamp</code> \u2192 <code>prov:atTime</code> - <code>proofValue</code> \u2192 provenance integrity proof</p>"},{"location":"en/concepts/category-theory-foundation/#4-the-amendment-chain-as-a-categorical-construction","title":"4. The Amendment Chain as a Categorical Construction","text":""},{"location":"en/concepts/category-theory-foundation/#the-category-of-revisions","title":"The Category of Revisions","text":"<p>For a given entity E, define the category Rev(E) where: - Objects are revisions: E\u2081, E\u2082, E\u2083, ... - Morphisms are amendment relationships: <code>amend: E\u1d62 \u2192 E\u1d62\u208a\u2081</code></p> <p>This forms a total order (a thin category where there's at most one morphism between any two objects).</p>"},{"location":"en/concepts/category-theory-foundation/#hash-chains-as-functors","title":"Hash Chains as Functors","text":"<p>The <code>previousRecordHash</code> field defines a functor <code>H: Rev(E) \u2192 HashChain</code> where HashChain is the category of SHA-256 hash values with \"derived-from\" morphisms.</p> <p>Preservation property: If <code>E\u1d62 \u2192amend E\u1d62\u208a\u2081</code>, then <code>H(E\u1d62)</code> is embedded in <code>E\u1d62\u208a\u2081.previousRecordHash</code>, creating an immutable audit trail.</p> <p>This is the categorical equivalent of a blockchain's hash chain, but without requiring distributed consensus\u2014the attesting node is responsible for chain integrity.</p>"},{"location":"en/concepts/category-theory-foundation/#5-the-slice-category-for-jurisdictional-scoping","title":"5. The Slice Category for Jurisdictional Scoping","text":""},{"location":"en/concepts/category-theory-foundation/#jurisdictional-restriction","title":"Jurisdictional Restriction","text":"<p>For a given jurisdiction J (e.g., <code>US-CA</code>), define the slice category <code>Civic/J</code> where: - Objects are entities with <code>jurisdictionIso</code> compatible with J - Morphisms are relationships/exchanges within that jurisdiction</p> <p>This allows queries like \"show me all contracts in California\" to be formalized as working within <code>Civic/US-CA</code> rather than searching all of Civic.</p>"},{"location":"en/concepts/category-theory-foundation/#the-inclusion-functor","title":"The Inclusion Functor","text":"<p>The forgetful functor <code>U: Civic/J \u2192 Civic</code> embeds jurisdictional data back into the global category, enabling cross-jurisdictional queries while preserving local structure.</p>"},{"location":"en/concepts/category-theory-foundation/#6-verification-the-proof-subcategory","title":"6. Verification: The Proof Subcategory","text":""},{"location":"en/concepts/category-theory-foundation/#defining-verification","title":"Defining Verification","text":"<p>A verified object or morphism is one where: 1. The <code>attestation.proofValue</code> is cryptographically valid 2. The <code>attestation.verificationMethodUri</code> resolves to a valid public key 3. If <code>anchorUri</code> is provided, the anchor can be independently verified</p>"},{"location":"en/concepts/category-theory-foundation/#the-subcategory-of-verified-records","title":"The Subcategory of Verified Records","text":"<p>Define Civic_verified \u2282 Civic as the full subcategory of verified records.</p> <p>The inclusion <code>I: Civic_verified \u2192 Civic</code> is faithful (injective on morphisms), meaning verification status is preserved under composition.</p> <p>Practical implication: If both <code>f: A \u2192 B</code> and <code>g: B \u2192 C</code> are verified, then <code>g \u2218 f: A \u2192 C</code> can be marked as having verified provenance\u2014the entire chain is trustworthy.</p>"},{"location":"en/concepts/category-theory-foundation/#7-summary-why-category-theory","title":"7. Summary: Why Category Theory?","text":"Categorical Concept CEP Implementation Benefit Objects entities Formalized identity Morphisms relationships, exchanges Typed, directed flows Composition <code>parentRelationshipId</code>, <code>fundingChainTag</code> Provenance tracing Identity Self-attestation (revision 1) Entity lifecycle start Limit/Universal Property Verifiable ID + <code>identifiers</code> Canonical identity resolution Functors XBRL, PROV mappings Interoperability Slice categories Jurisdictional scoping Efficient local queries Hash chain functor <code>previousRecordHash</code> Immutable audit trail"},{"location":"en/concepts/category-theory-foundation/#the-core-theorem","title":"The Core Theorem","text":"<p>Theorem: The CEP system, as defined by the entity, relationship, and exchange schemas with their attestation and hash chain requirements, forms a well-defined category Civic with: 1. A universal property for entity identity (the Verifiable ID limit) 2. Associative composition for provenance chains 3. Faithful functors to external standards (XBRL, PROV) 4. A verified subcategory preserving cryptographic integrity</p> <p>Corollary: Any implementation that correctly generates canonical strings and validates attestations will produce records that compose correctly in the categorical sense\u2014provenance chains will be traceable, amendments will be auditable, and cross-system identity will be resolvable.</p>"},{"location":"en/concepts/category-theory-foundation/#appendix-diagrammatic-notation","title":"Appendix: Diagrammatic Notation","text":""},{"location":"en/concepts/category-theory-foundation/#basic-composition","title":"Basic Composition","text":"<pre><code>    grant           subgrant\nFED -----\u2192 STATE ----------\u2192 LOCAL\n\n         composed to:\n\n         federal-to-local\nFED ------------------------\u2192 LOCAL\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-limit-diagram-for-verifiable-id","title":"The Limit Diagram for Verifiable ID","text":"<pre><code>                  \u250c\u2500\u2500\u2500 SAM.gov record\n                  \u2502\n                  \u2502    \u03c0_sam\n                  \u2193\n    LEI record \u2500\u2500\u2500\u2192 Entity (Verifiable ID) \u2190\u2500\u2500\u2500 County record\n                  \u2191\n                  \u2502    \u03c0_state  \n                  \u2502\n                  \u2514\u2500\u2500\u2500 State CF record\n</code></pre>"},{"location":"en/concepts/category-theory-foundation/#the-amendment-chain","title":"The Amendment Chain","text":"<pre><code>E\u2081 \u2500\u2500amend\u2500\u2500\u2192 E\u2082 \u2500\u2500amend\u2500\u2500\u2192 E\u2083 \u2500\u2500amend\u2500\u2500\u2192 E\u2084\n\u2502              \u2502              \u2502              \u2502\n\u2502 hash         \u2502 hash         \u2502 hash         \u2502\n\u2193              \u2193              \u2193              \u2193\nH\u2081 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2082 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2083 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 H\u2084\n     (H\u2081 in        (H\u2082 in        (H\u2083 in\n      E\u2082)           E\u2083)           E\u2084)\n</code></pre> <p>This completes the categorical foundation for CEP. The schemas implement these abstract structures concretely, and the test vectors verify that implementations preserve the categorical properties.</p>"},{"location":"en/concepts/interoperability/","title":"Interoperability","text":"<p>CEP is designed to integrate with: </p> <ul> <li>Popolo - the entity + political relationships backbone of nearly every open civics project worldwide (OCD, OpenStates, etc.) includes models for Person, Organization, Membership,  Post / Role, Area, Event, Motion / Vote, Legislative Activity and works for elected officials, models boards, committees, councils, includes membership graph.</li> <li>Open Civic Data</li> <li>Open Contracting Data Standard (OCDS) - international standard for public procurement, contracts, tenders, awards, suppliers, implementation and milestone tracking.</li> <li>Schema.org - includes Organization, Person, Place, GovernmentOrganization, Grant, MonetaryGrant,  Legislation, VoteAction and enables interoperability with Google datasets, machine readability.</li> <li>Financial Taxonomies (XBRL) - good for financial reporting, auditing, interoperability with Treasury and state finance systems</li> <li>W3C PROV - good for academics and auditors, PROV guides revision chains, attestation blocks, canonical timestamps, and hash-based integrity. CEP attestation maps to PROV wasGeneratedBy, wasAttributedTo, wasDerivedFrom and CEP previousRecordHash maps to PROV wasRevisionOf.</li> <li>Open Referral Human Services Data Specification (HSDS) - has Organization, Location, Service, Funding - enables connecting public funding to outcomes</li> <li>Financial Industry Business Ontology (FIBO) - map to loan-agreement, grant-award (loosely), subsidiary.</li> </ul>"},{"location":"en/concepts/interoperability/#cep-concept-mapping-table","title":"CEP Concept Mapping Table","text":"CEP Concept CEP Term / Field CEP Vocabulary / Schema External Standard External Concept / Class / Field Mapping Type Notes Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Popolo <code>Organization</code> exactMatch Government bodies (legislatures, councils, agencies). Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> OCD <code>ocd-jurisdiction</code> exactMatch Use in <code>identifiers.additionalSchemes</code> with OCD jurisdiction IDs. Entity (organization) <code>entityTypeUri = #government-jurisdiction</code> <code>entity-type.json</code> Schema.org <code>GovernmentOrganization</code> exactMatch For web/SEO and generic data consumers. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> OCD <code>ocd-division</code> + <code>ocd-jurisdiction</code> (school districts) broadMatch Division/jurisdiction pair identifies school districts. Entity (organization) <code>entityTypeUri = #school-district</code> <code>entity-type.json</code> Schema.org <code>EducationalOrganization</code> / <code>SchoolDistrict</code> (where available) exactMatch For education analytics and public-facing data. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Popolo <code>Organization</code> with classification <code>nonprofit</code> broadMatch Nonprofits providing services, fiscal sponsors, etc. Entity (organization) <code>entityTypeUri = #nonprofit-organization</code> <code>entity-type.json</code> Schema.org <code>NGO</code> / <code>Organization</code> relatedMatch Web-compatible representation of nonprofits. Entity (organization) <code>entityTypeUri = #vendor</code> <code>entity-type.json</code> OCDS <code>Party</code> with role <code>supplier</code> exactMatch Contractors / vendors in procurement. Entity (natural person) <code>entityTypeUri = #natural-person</code> <code>entity-type.json</code> Popolo <code>Person</code> exactMatch Politicians, officials, natural-person donors, etc. Entity (natural person) <code>entityTypeUri = #elected-official</code> <code>entity-type.json</code> Popolo <code>Person</code> + <code>Membership</code> in <code>Organization</code> exactMatch Derived from Popolo membership in a legislature / council. Entity (natural person) <code>entityTypeUri = #natural-person</code> / <code>#elected-official</code> <code>entity-type.json</code> Schema.org <code>Person</code> exactMatch Generic consumer-friendly alignment. Entity (division) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division/...</code> exactMatch Political geography for school districts, counties, states, etc. Entity (jurisdiction) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-jurisdiction/...</code> exactMatch Governing bodies over divisions. Entity (organization) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-organization/...</code> exactMatch Committees, councils, agencies, boards. Entity (person) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-person/...</code> exactMatch People in OCD-compatible civic graphs. Entity (financial) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI ISO 17442 Legal Entity Identifier exactMatch Global financial identity for entities in financial transactions. Entity (federal) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov Unique Entity Identifier exactMatch U.S. federal financial identity for entities. Entity (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) Hash-based Sub-National Federated Entity Identifier newConcept Bridges UEI/LEI to local civic entities; open-source identifier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> exactMatch Prime contract between government and supplier. Relationship (contract) <code>relationshipTypeUri = #prime-contract</code> <code>relationship-type.json</code> USAspending <code>contract</code> (glossary) exactMatch Alignment with USASpending contract awards. Relationship (subcontract) <code>relationshipTypeUri = #subcontract</code> <code>relationship-type.json</code> OCDS <code>Contract</code> linked via <code>relatedProcesses</code> broadMatch Subcontracts under a prime contract. Relationship (grant) <code>relationshipTypeUri = #grant-award</code> <code>relationship-type.json</code> USAspending <code>grant</code> (glossary) exactMatch Federal grants / assistance awards. Relationship (subgrant) <code>relationshipTypeUri = #subgrant</code> <code>relationship-type.json</code> OCDS <code>Award</code> + <code>Implementation.transactions</code> for subawards broadMatch Pass-through grants from state to local entities. Relationship (coop agrmt) <code>relationshipTypeUri = #cooperative-agreement</code> <code>relationship-type.json</code> USAspending <code>cooperative agreement</code> exactMatch Cooperative federal assistance relationships. Relationship (interagency) <code>relationshipTypeUri = #interagency-agreement</code> <code>relationship-type.json</code> OCDS <code>Contract</code> or <code>Agreement</code> between government parties relatedMatch Transfer agreements between agencies. Relationship (MOU) <code>relationshipTypeUri = #memorandum-of-understanding</code> <code>relationship-type.json</code> Popolo <code>Membership</code> / <code>Organization</code> with informal cooperation relatedMatch Non-binding but structured relationships. Relationship (fiscal spon) <code>relationshipTypeUri = #fiscal-sponsorship</code> <code>relationship-type.json</code> HSDS <code>Funding</code> / <code>Service</code> provider/host relationship relatedMatch Connects projects to 501(c)(3) entities. Relationship (board) <code>relationshipTypeUri = #board-membership</code> <code>relationship-type.json</code> Popolo <code>Membership</code> (person \u2194 organization, role = board member) exactMatch Governance relationships. Relationship (employment) <code>relationshipTypeUri = #employment</code> <code>relationship-type.json</code> Popolo <code>Membership</code> or <code>Post</code> with classification <code>employment</code> exactMatch Staff roles in agencies, schools, vendors. Relationship (consulting) <code>relationshipTypeUri = #consulting-engagement</code> <code>relationship-type.json</code> Popolo <code>Membership</code> with classification <code>consultant</code> relatedMatch Non-employee professional services. Relationship (subsidiary) <code>relationshipTypeUri = #subsidiary</code> <code>relationship-type.json</code> Schema.org <code>subOrganization</code> relatedMatch Corporate ownership within civic vendor trees. Relationship (joint ven.) <code>relationshipTypeUri = #joint-venture</code> <code>relationship-type.json</code> FIBO Joint venture relationship relatedMatch Optional mapping for advanced financial/corporate semantics. Relationship (reg. reg.) <code>relationshipTypeUri = #regulatory-registration</code> <code>relationship-type.json</code> Schema.org <code>GovernmentOrganization</code> + <code>registration</code>-related properties relatedMatch Entities registered with regulatory bodies. Relationship (loan) <code>relationshipTypeUri = #loan-agreement</code> <code>relationship-type.json</code> FIBO Loan contract exactMatch For loans, bond-like instruments, and revolving credit. Relationship (bill-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Bill</code> object relatedMatch Relationship authorized or shaped by a bill. Relationship (vote-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Vote</code> object relatedMatch Relationship activated/approved by a vote. Relationship (event-ties) <code>sourceReferences</code> on Relationship <code>cep.relationship.schema.json</code> OCD <code>Event</code> object relatedMatch Relationship linked to hearings, meetings, signings. Exchange (grant) <code>exchangeTypeUri = #grant-disbursement</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type grant disbursement exactMatch Payment of grant funds under a grant-award relationship. Exchange (contract fee) <code>exchangeTypeUri = #contract-fee-payment</code> <code>exchange-type.json</code> OCDS <code>Implementation.transactions</code> of type payment exactMatch Invoice payments under contracts. Exchange (subaward) <code>exchangeTypeUri = #subgrant-disbursement</code> <code>exchange-type.json</code> USAspending Subaward transactions exactMatch Pass-through disbursements to subrecipients. Exchange (donation) <code>exchangeTypeUri = #campaign-contribution</code> <code>exchange-type.json</code> Popolo / DIME Contribution records mapped to <code>Person</code> / <code>Organization</code> donors/recipients relatedMatch Campaign finance contributions tied into CEP graph. Exchange (in-kind) <code>value.valueTypeUri = #in-kind</code> <code>value-type.json</code> Schema.org <code>Offer</code> / <code>Grant</code> with non-monetary value relatedMatch Non-monetary goods/services tracked in CEP. Exchange (service-hours) <code>value.valueTypeUri = #service-hours</code> <code>value-type.json</code> HSDS <code>Service</code> + time-based contributions relatedMatch Volunteer or staff time as value. Exchange (categorization) <code>categorization.naicsCode</code> <code>cep.exchange.schema.json</code> NAICS NAICS industry codes exactMatch Standard economic activity classification for exchanges. Exchange (categorization) <code>categorization.cfdaNumber</code> <code>cep.exchange.schema.json</code> CFDA / Assistance CFDA / Assistance Listing number exactMatch Links exchanges to federal assistance programs. Exchange (categorization) <code>categorization.gtasAccountCode</code> <code>cep.exchange.schema.json</code> GTAS Treasury Account Symbol exactMatch Aligns exchanges to Treasury reporting accounts. Exchange (source) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCDS <code>Release</code>, <code>Award</code>, <code>Contract</code>, <code>Implementation.transactions</code> relatedMatch Exchange derived from procurement data. Exchange (bill/vote) <code>sourceReferences</code> on Exchange <code>cep.exchange.schema.json</code> OCD <code>Bill</code>, <code>Vote</code>, <code>Event</code> relatedMatch Funding events tied to legislative activity. Value (monetary) <code>value.valueTypeUri = #monetary</code> <code>value-type.json</code> XBRL Monetary item types (e.g., <code>monetaryItemType</code>) exactMatch Monetary amounts aligned with financial reporting taxonomies. Value (monetary) <code>value.amount</code>, <code>value.currencyCode</code> <code>cep.exchange.schema.json</code> XBRL <code>xbrli:monetaryItemType</code>, ISO 4217 exactMatch Strictly typed monetary values. Value (provisioning) <code>valueTypeUri = #service-hours</code> / <code>#in-kind</code> <code>value-type.json</code> HSDS <code>Service</code> value dimensions relatedMatch For human services and community programs. Provenance (entity) <code>attestation</code> block on Entity <code>cep.entity.schema.json</code> W3C PROV <code>prov:Entity</code>, <code>prov:wasGeneratedBy</code>, <code>prov:wasAttributedTo</code> exactMatch Entity record as a PROV entity with associated agent/activity. Provenance (relationship) <code>attestation</code> block on Relationship <code>cep.relationship.schema.json</code> W3C PROV Same as above exactMatch Relationship record provenance in PROV terms. Provenance (exchange) <code>attestation</code> block on Exchange <code>cep.exchange.schema.json</code> W3C PROV Same as above exactMatch Exchange record provenance. Provenance (revision) <code>previousRecordHash</code>, <code>revisionNumber</code> all CEP core schemas W3C PROV <code>prov:wasRevisionOf</code>, <code>prov:qualifiedRevision</code> exactMatch Immutable revision chains expressed via hashes and monotone revisions. Provenance (hash) Canonical string + SHA-256 hash (SSOT) implementation / spec W3C PROV <code>prov:generatedAtTime</code>, <code>prov:wasDerivedFrom</code> relatedMatch Hash as integrity proof supporting PROV-compatible derivation chains. IDs (UEI) <code>identifiers.samUei</code> <code>cep.entity.schema.json</code> UEI SAM.gov UEI exactMatch Federal identity. IDs (LEI) <code>identifiers.lei</code> <code>cep.entity.schema.json</code> LEI LEI exactMatch Global financial identity. IDs (SNFEI) <code>identifiers.snfei</code> <code>cep.entity.schema.json</code> (none, new) SNFEI newConcept Open, recomputable sub-federal ID bridging UEI/LEI and local civic entities. IDs (OCD) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> OCD <code>ocd-division</code>, <code>ocd-jurisdiction</code>, <code>ocd-organization</code>, <code>ocd-person</code> exactMatch Primary bridge to the Open Civic Data topology. IDs (OCDS) <code>identifiers.additionalSchemes</code> on Entity/Relationship <code>cep.entity/relationship</code> OCDS <code>Parties</code>, <code>Award.id</code>, <code>Contract.id</code> relatedMatch Tie CEP entities/relationships back to OCDS releases. IDs (Popolo) <code>identifiers.additionalSchemes</code> <code>cep.entity.schema.json</code> Popolo <code>Person.id</code>, <code>Organization.id</code> relatedMatch Where Popolo IDs exist separately from OCD IDs."},{"location":"en/concepts/interoperability/#cep-concept-mapping-table-by-schema","title":"CEP Concept Mapping Table (by Schema)","text":"CEP Concept / Field External Standard External Concept / ID / Class Mapping Type Suggested <code>externalUri</code> / <code>schemeUri</code> example Notes Entity (general civic entity) Popolo <code>Person</code>, <code>Organization</code> broadMatch <code>http://www.popoloproject.com/specs/person.html</code>, <code>http://www.popoloproject.com/specs/organization.html</code> CEP <code>entity</code> covers both persons and orgs; Popolo separates. <code>entityTypeUri</code> <code>#natural-person</code> Popolo <code>Person</code> exactMatch <code>http://www.popoloproject.com/specs/person.html</code> For individuals (candidates, officials, donors). <code>entityTypeUri</code> <code>#organization</code> Popolo <code>Organization</code> exactMatch <code>http://www.popoloproject.com/specs/organization.html</code> Base org type, parent of more specific government / nonprofit types. <code>entityTypeUri</code> <code>#government-jurisdiction</code> Popolo/OCD Popolo <code>Organization</code> + OCD <code>jurisdiction</code> relatedMatch <code>https://opencivicdata.org/id/jurisdiction</code> A governing body; mix of org and jurisdiction. <code>identifiers.additionalSchemes</code> (division) OCD <code>ocd-division/*</code> exactMatch <code>https://opencivicdata.org/id/division</code> Store OCD division IDs as <code>schemeUri = \"https://opencivicdata.org/id/division\"</code>. <code>identifiers.additionalSchemes</code> (jurisdiction) OCD <code>ocd-jurisdiction/*</code> exactMatch <code>https://opencivicdata.org/id/jurisdiction</code> Store OCD jurisdiction IDs. <code>identifiers.additionalSchemes</code> (person) OCD / Popolo <code>ocd-person/*</code> (Popolo person) exactMatch <code>https://opencivicdata.org/id/person</code> Link CEP entity to OCD/Popolo person IDs. <code>identifiers.additionalSchemes</code> (organization) OCD / Popolo <code>ocd-organization/*</code> exactMatch <code>https://opencivicdata.org/id/organization</code> Link CEP entity to OCD/Popolo org IDs. <code>identifiers.lei</code> leif / LEI <code>LEI</code> (ISO 17442 Legal Entity Identifier) exactMatch <code>https://www.gleif.org/en/about-lei/introducing-the-legal-entity-identifier-lei</code> Already in schema; key for global finance interoperability. <code>identifiers.samUei</code> US Federal UEI (SAM.gov Unique Entity Identifier) exactMatch <code>https://www.sam.gov/</code> Tier 2 identity in our stack. <code>identifiers.additionalSchemes</code> (OCDS party) OCDS <code>parties.identifier.id</code> relatedMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Use for suppliers / buyers in procurement records. <code>entityTypeUri</code> <code>#supplier</code> / <code>#contractor</code> OCDS <code>Organization</code> with role <code>supplier</code> / <code>tenderer</code> exactMatch <code>https://standard.open-contracting.org/1.1/en/schema/reference/#parties</code> Straight mapping for vendors. <code>entityTypeUri</code> <code>#school-district</code> Schema.org <code>SchoolDistrict</code> (subtype of <code>EducationalOrganization</code>) relatedMatch <code>https://schema.org/SchoolDistrict</code> For education equity analytics. <code>entityTypeUri</code> <code>#government-agency</code> Schema.org <code>GovernmentOrganization</code> exactMatch <code>https://schema.org/GovernmentOrganization</code> For agencies at any level. Relationship (legal / functional relationships) Popolo <code>Membership</code>, <code>Post</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> CEP Relationship is more general; includes contracts, grants, etc. <code>relationshipTypeUri</code> <code>#board-membership</code> Popolo <code>Membership</code> exactMatch <code>http://www.popoloproject.com/specs/membership.html</code> Board membership of a person in an org. <code>relationshipTypeUri</code> <code>#employment</code> Popolo <code>Membership</code> (with <code>post</code> / <code>role</code>) broadMatch <code>http://www.popoloproject.com/specs/membership.html</code> Employment is a constrained membership. <code>relationshipTypeUri</code> <code>#consulting-engagement</code> Popolo <code>Membership</code> or <code>ContactDetail</code> relatedMatch <code>http://www.popoloproject.com/specs/membership.html</code> Less formal, non-employee service relationship. <code>relationshipTypeUri</code> <code>#prime-contract</code> OCDS <code>Contract</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> CEP Relationship for a prime contract matches OCDS Contract. <code>relationshipTypeUri</code> <code>#subcontract</code> OCDS <code>Contract</code> with <code>relatedProcesses</code> / <code>relatedLots</code> narrowMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#contract</code> Subcontracts are contracts linked to a parent award. <code>relationshipTypeUri</code> <code>#grant-award</code> OCDS <code>Award</code> relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#award</code> OCDS is procurement-focused; grants are adjacent. <code>relationshipTypeUri</code> <code>#cooperative-agreement</code> OCDS <code>Award</code> or <code>Contract</code> (context-specific) relatedMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/</code> Map conceptually to awarded agreements. <code>relationshipTypeUri</code> <code>#loan-agreement</code> FIBO <code>LoanAgreement</code> exactMatch <code>https://spec.edmcouncil.org/fibo/ontology/FBC/DebtAndEquities/Debt/LoanAgreement</code> Optional FIBO mapping; useful for financial instruments. <code>relationshipTypeUri</code> <code>#subsidiary</code> Schema.org <code>subOrganization</code> relatedMatch <code>https://schema.org/subOrganization</code> See vocab.mappings. <code>relationshipTypeUri</code> <code>#joint-venture</code> Schema.org <code>Organization</code> with <code>memberOf</code> relatedMatch <code>https://schema.org/Organization</code> Joint ventures as special multi-party orgs. <code>relationshipTypeUri</code> <code>#regulatory-registration</code> Schema.org <code>GovernmentOrganization</code> / <code>Service</code> relatedMatch <code>https://schema.org/GovernmentOrganization</code> Registration with a regulator. <code>relationshipTypeUri</code> <code>#fiscal-sponsorship</code> HSDS / Nonprofit HSDS <code>Funding</code> or <code>Service</code> relatedMatch <code>https://github.com/openreferral/specification</code> For nonprofit fiscal sponsor relationships. Exchange (value transfer events) OCDS <code>Implementation.transactions[]</code> exactMatch <code>https://standard.open-contracting.org/latest/en/schema/reference/#implementation</code> CEP Exchange is very close to OCDS transaction-level data. <code>exchangeTypeUri</code> <code>#grant-disbursement</code> Schema.org <code>MonetaryGrant</code> exactMatch <code>https://schema.org/MonetaryGrant</code> Core pattern for education &amp; campaign finance. <code>exchangeTypeUri</code> <code>#contract-fee-payment</code> Schema.org <code>Payment</code> / <code>Invoice</code> relatedMatch <code>https://schema.org/Invoice</code> Payment for contracted services. <code>exchangeTypeUri</code> <code>#donation</code> (if defined) Schema.org <code>DonateAction</code> relatedMatch <code>https://schema.org/DonateAction</code> Campaign or charitable donations. <code>exchangeTypeUri</code> <code>#loan-disbursement</code> FIBO <code>LoanPrincipalPayment</code> relatedMatch FIBO debt concepts More detailed financial modeling if needed. Value &amp; Categorization XBRL GAAP / GRT financial elements exactMatch e.g. <code>http://xbrl.us/us-gaap/2024-01-31#RevenueRecognition</code> Map CEP <code>categorization</code> fields to XBRL when possible. <code>value.currencyCode</code> ISO 4217 Currency codes exactMatch <code>https://www.iso.org/iso-4217-currency-codes.html</code> Already enforced by regex. <code>categorization.naicsCode</code> NAICS NAICS activity code exactMatch <code>https://www.census.gov/naics/</code> Already included in schema. <code>categorization.cfdaNumber</code> Assistance List CFDA / Assistance Listing number exactMatch <code>https://sam.gov/content/assistance-listing</code> For federal assistance programs. <code>categorization.gtasAccountCode</code> US GTAS Treasury Account Symbol (TAS) exactMatch <code>https://fiscal.treasury.gov/gtas/</code> Connects to federal reporting. Provenance &amp; Attestation W3C PROV <code>Entity</code>, <code>Activity</code>, <code>Agent</code>, <code>wasGeneratedBy</code>, <code>wasAttributedTo</code>, etc. relatedMatch <code>https://www.w3.org/TR/prov-o/</code> CEP is PROV-aligned but more specialized. <code>attestation.attestorId</code> W3C PROV <code>Agent</code> / <code>prov:wasAttributedTo</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasAttributedTo</code> The attesting node is the Agent. <code>attestation.attestationTimestamp</code> W3C PROV <code>generatedAtTime</code> exactMatch <code>https://www.w3.org/TR/prov-o/#generatedAtTime</code> When the record (Entity) was generated. <code>previousRecordHash</code> W3C PROV <code>wasRevisionOf</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasRevisionOf</code> Revision chain between CEP records. <code>provenanceChain.fundingChainTag</code> W3C PROV <code>wasDerivedFrom</code> chain relatedMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Human-readable representation of a PROV derivation path. <code>provenanceChain.parentExchangeId</code> W3C PROV <code>wasDerivedFrom</code> exactMatch <code>https://www.w3.org/TR/prov-o/#wasDerivedFrom</code> Parent exchange is the immediate predecessor in the flow. Events, Bills, Votes OCD / Popolo <code>Bill</code>, <code>VoteEvent</code>, <code>Event</code> relatedMatch <code>https://opencivicdata.org/specs/</code> Linked via <code>sourceReferences</code>. <code>sourceReferences</code> (bill) OCD <code>ocd-bill/*</code> exactMatch <code>https://opencivicdata.org/id/bill</code> For authorizing legislation. <code>sourceReferences</code> (vote) OCD / Popolo <code>ocd-vote/*</code> or Popolo <code>VoteEvent</code> exactMatch <code>https://opencivicdata.org/id/vote</code> For authorization votes. <code>sourceReferences</code> (event) OCD / Popolo <code>Event</code> exactMatch <code>https://opencivicdata.org/id/event</code> Meetings, hearings tied to relationships or exchanges. Human Services / Programs (optional) HSDS <code>Service</code>, <code>Organization</code>, <code>Funding</code> relatedMatch <code>https://github.com/openreferral/specification</code> For social services and community programs. <code>entityTypeUri</code> <code>#service-provider</code> HSDS <code>Organization</code> exactMatch <code>https://github.com/openreferral/specification</code> For agencies and nonprofits providing services. <code>relationshipTypeUri</code> <code>#service-delivery-agreement</code> (future) HSDS <code>Service</code> / <code>Funding</code> relatedMatch HSDS docs If added."},{"location":"en/concepts/interoperability/#vocabulary-notes","title":"Vocabulary Notes","text":"<p>prime-contract</p> <ul> <li>USAspending contract is a close conceptual match.</li> <li>OCDS contract is the canonical public procurement concept, so exactMatch.</li> </ul> <p>subcontract</p> <ul> <li>OCDS does not have a first-class subcontract object, but it is conceptually a specialized contract under a main award, so narrowMatch.</li> </ul> <p>grant-award</p> <ul> <li>USAspending grant is a direct match to federal grants.</li> <li>OCDS award is broader (covers procurements and grants), so relatedMatch.</li> <li>Schema.org MonetaryGrant is almost exactly, so exactMatch.</li> </ul> <p>loan-agreement</p> <ul> <li>FIBO Contracts and Loans ontologies give similar semantic neighborhood but more general, so relatedMatch.</li> </ul> <p>subsidiary</p> <ul> <li>Schema.org subOrganization is close but not strictly legal-definition match, so relatedMatch.</li> <li>FIBO Subsidiary is semantically close but in financial-industry framing; so relatedMatch.</li> </ul> <p>board-membership and employment</p> <ul> <li>Both are specializations of Popolo Membership (person\u2013organization relationship with roles and time-bounds), so narrowMatch.</li> </ul>"},{"location":"en/concepts/related-domains/","title":"Related Research Domains","text":"<p>This standard operates at the intersection of three major, yet often separate, academic research domains:  - Formal Entity Resolution (CS),  - Campaign Finance/Policy Analysis (Political Science), and - Global Data Standards (Information Systems).</p>"},{"location":"en/concepts/related-domains/#prior-work-entity-resolution-data-standards-and-civic-transparency","title":"Prior Work: Entity Resolution, Data Standards, and Civic Transparency","text":"<p>This standard advances the state-of-the-art by bridging the gap between three distinct bodies of work: high-fidelity entity resolution, policy-driven data harmonization, and the development of open standards for public accountability.</p>"},{"location":"en/concepts/related-domains/#1-entity-resolution-and-data-quality-methodology","title":"1. Entity Resolution and Data Quality Methodology","text":"<p>Research in Entity Resolution (ER), also known as record linkage or deduplication, has been a cornerstone of computer science and database theory.</p> <p>Carnegie Mellon University (CMU) has contributed foundational work in formalizing the ER problem, such as the ENRES framework, which provides a semantic model to represent and relate various ER research models. This work highlights the crucial need for formal reasoning and explicit assumptions regarding entities and their references, which directly informs our Category Theory approach. Other CMU-related research has addressed Generic Entity Resolution with Data Confidences, underscoring the necessity of associating numerical confidence with merged records, a feature we implement via the Splink-generated confidence_score.</p> <p>The computational methodology behind our implementation relies heavily on advancements in probabilistic record linkage, particularly the Fellegi-Sunter model, which allows for high-accuracy linking of data without labeled training sets, critical for messy public data. The use of the open-source Splink library (pioneered outside academia and rigorously validated) represents a pragmatic, scalable implementation of these probabilistic principles.</p>"},{"location":"en/concepts/related-domains/#2-campaign-finance-and-policy-data-standardization","title":"2. Campaign Finance and Policy Data Standardization","text":"<p>A parallel track of research has focused on the application of computational methods to clean and analyze fragmented political data.</p> <p>Stanford University's DIME (Database on Ideology, Money in Politics, and Elections) Project exemplifies the effort to centralize and standardize complex political contributions data. DIME has assigned unique identifiers for millions of individual and organizational donors, candidates, and political committees across federal and state elections. This established the value proposition for a persistent, standardized identifier in the campaign finance domain.</p> <p>The University of Chicago MS in Computational Analysis and Public Policy (MSCAPP) and Stanford's Computational Public Policy programs have emphasized the necessary skills, including machine learning, big data, and computational analysis required to address policy issues like public procurement and campaign finance. These programs underscore the academic recognition that robust data infrastructure is the prerequisite for rigorous policy analysis.</p> <p>While these efforts successfully resolve entities within their domain (e.g., within campaign finance), they often use internal, proprietary identifiers that do not readily link to entities in the public procurement or grant domains, creating siloed transparency.</p>"},{"location":"en/concepts/related-domains/#3-open-data-interoperability-and-global-standards","title":"3. Open Data, Interoperability, and Global Standards","text":"<p>The third body of work defines the principles of modern data governance and standardization.</p> <p>Massachusetts Institute of Technology (MIT), through its Research Data Principles, champions the need for researchers to manage data actively and avoid acquiring or generating data that restricts future use and sharing. This principle of \"open by default\" and \"designed for reuse\" informs the design of the our open-source standard and its reliance on the non-proprietary SNFEI.</p> <p>Organizations supporting the Open Data Charter emphasize that data must be comparable and interoperable to enhance governance and accountability. This reflects the global demand for cross-sectoral standards. The existing Legal Entity Identifier (LEI) standard provides the template for a globally harmonized system in the financial sector.</p>"},{"location":"en/concepts/related-domains/#novelty-and-contribution-of-this-standard","title":"Novelty and Contribution of this Standard","text":"<p>This project is novel in three key ways:</p> <ul> <li> <p>Compositional Rigor: We model the civic exchange system as a Category, using Category Theory to formally prove that the SNFEI acts as the Universal Property (Limit) that unifies all messy civic records, helping to guarantee the standard's structural integrity and extensibility.</p> </li> <li> <p>Tiered, Extensible Identity: We address sub-federal identities by explicitly creating the SNFEI (Tier 3) as an open-source bridge to the global LEI (Tier 1) and federal UEI (Tier 2).</p> </li> <li> <p>The Provenance Tag: We enforce a Compositional Provenance Tag that structurally records the Morphism Type (GRANT, CONTRACT_FEE) and the entity hierarchy, enabling automated tracing of the entire funding chain, which goes beyond simple entity deduplication.</p> </li> </ul>"},{"location":"en/governance/evolution-policy-and-versioning/","title":"Standard Evolution Policy and Versioning","text":"<p>This policy defines the process, requirements, and responsibilities for introducing changes to the Protocol.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#1-versioning-system","title":"1. Versioning System","text":"<p>The standard utilizes Semantic Versioning (MAJOR.MINOR.PATCH). The version number applies to the entire monorepo and its core protocol requirements.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#11-major-version-change-x00","title":"1.1 MAJOR Version Change (X.0.0)","text":"<p>A MAJOR change is reserved for non-backwards-compatible modifications that require all certified nodes to update their serialization logic, otherwise, they will lose hash parity.</p> Change Type Impact Example Data Type Change Changing a field type (e.g., transactionAmount from number to string). Field Order Change Modifying the CANONICAL_FIELD_ORDER. Cryptographic Change Switching from SHA-256 to a new algorithm (e.g., SHA-384). Mandatory Field Addition Adding a new field to the required list in the JSON Schema. <p>Requirement: Requires unanimous approval from the Interconnect Standards Board (ISB) and a mandatory 6-month deprecation period.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#12-minor-version-change-0x0","title":"1.2 MINOR Version Change (0.X.0)","text":"<p>A MINOR change is a backwards-compatible modification that adds new functionality or optional fields. Existing certified nodes maintain hash parity, but new nodes may need to account for new optional data.</p> Change Type Impact Example Optional Field Addition Adding a new field to the end of the CANONICAL_FIELD_ORDER (which is omitted if null). Adding funding_source_project_id (optional). Enum Value Addition Adding a new value to an existing enum (e.g., adding TEMPORARILY_SUSPENDED to transactionStatus). Tooling Upgrade Significant upgrade to the build system (build.sh or testing dependencies). <p>Requirement: Requires simple majority approval from the ISB (2 out of 3 votes).</p>"},{"location":"en/governance/evolution-policy-and-versioning/#13-patch-version-change-00x","title":"1.3 PATCH Version Change (0.0.X)","text":"<p>A PATCH change is a small, fully backwards-compatible correction to documentation, tooling, or non-protocol code.</p> Change Type Impact Example Documentation Fix Correcting a typo in the Governance Charter. Test Data Update Adding a new test vector to /test_data that uses only existing fields. Non-Core Bug Fix Fixing a non-critical bug in a reference implementation's example code. <p>Requirement: Can be approved by the ISB Chair alone.</p>"},{"location":"en/governance/evolution-policy-and-versioning/#2-change-submission-and-review-cycle","title":"2. Change Submission and Review Cycle","text":"<ol> <li> <p>Proposal Submission: The contributor submits a Pull Request (PR) against the main branch.</p> </li> <li> <p>Versioning Assignment: The ISB Chair assigns the PR a tentative version bump (MAJOR, MINOR, or PATCH) based on Section 1.</p> </li> <li> <p>ISB Review and Vote: The ISB reviews the proposal (focusing on need and impact) and votes according to the requirement for the assigned version type.</p> </li> <li> <p>Hash Parity Enforcement: Once the vote passes, the PR is merged, and the automated CI system executes the build.sh script to confirm 100% hash parity across all five certified languages (Python, Rust, Java, C#, TypeScript). No release can occur until 100% parity is confirmed.</p> </li> <li> <p>Release: The new version is tagged, and all certified node operators are notified.</p> </li> </ol>"},{"location":"en/governance/objectives-and-vision/","title":"Objectives and Vision","text":"<p>The Civic Exchange Protocol (CEP) is designed to support incremental integration today and strategic planning without requiring architectural changes. The core philosophy is simple:</p> <ul> <li>Optimize for low-cost, low-friction adoption.</li> <li>Provide cryptographic integrity without requiring blockchain.</li> <li>Support regulatory harmonization across jurisdictions.</li> <li>Preserve openness, interoperability, and vendor neutrality.</li> </ul> <p>At its core, CEP ensures that the same payload always yields the same canonical hash, providing a universal identity and attestation mechanism that can span civic, financial, and administrative systems.</p>"},{"location":"en/governance/objectives-and-vision/#1-objectives","title":"1. Objectives","text":""},{"location":"en/governance/objectives-and-vision/#11-lower-the-cost-of-adoption","title":"1.1 Lower the Cost of Adoption","text":"<p>Most public-sector technology initiatives fail due to the cost and complexity of onboarding. CEP minimizes this by:</p> <ul> <li>Requiring only JSON + SHA-256 + a canonical string rule.</li> <li>Avoiding specialized infrastructure (no distributed ledger, no proprietary middleware).</li> <li>Allowing any language, platform, or agency to participate.</li> <li>Transparency by default: schemas and vocabularies are openly published.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#12-decentralized-provenance-without-blockchain","title":"1.2 Decentralized Provenance Without Blockchain","text":"<p>Unlike blockchain-based solutions, CEP:</p> <ul> <li>Requires no consensus algorithm.</li> <li>Does not impose token economics or distributed nodes.</li> <li>Uses a cryptographically linked attestation chain (previousRecordHash), providing tamper evidence at a fraction of the cost.</li> </ul> <p>This provides a cryptographic audit trail suitable for public-sector systems where full decentralization is either unnecessary or impractical.</p>"},{"location":"en/governance/objectives-and-vision/#13-cost-effective-regulatory-compliance","title":"1.3 Cost-Effective Regulatory Compliance","text":"<p>CEP is designed to satisfy emerging demands in:</p> <ul> <li>Transparency and anti-corruption policy  </li> <li>Cross-jurisdiction financial tracking  </li> <li>Federal reporting (XBRL, GTAS)  </li> <li>Global financial identity standards (UEI, LEI)</li> </ul> <p>By structuring the data model around canonical identifiers, provenance, and hash-bound attestations, CEP can adapt naturally to future regulatory frameworks and programmatic audit requirements.</p>"},{"location":"en/governance/objectives-and-vision/#2-vision","title":"2. Vision","text":"<p>The Civic Exchange Protocol is deliberately designed so that incremental adoption today will not conflict with expected future requirements.</p> <p>Possible evolution includes:</p> <ul> <li>National or state-level directives requiring provenance tagging for grant, contract, or procurement systems.</li> <li>Standardization bodies adopting CEP as a formal schema for intergovernmental reporting.</li> <li>Regulatory requirements for immutable audit trails for public money flows.</li> <li>International harmonization with LEI, XBRL, HSDS, PROV, Popolo, or other standards.</li> </ul>"},{"location":"en/governance/objectives-and-vision/#3-voluntary-integration-vs-possible-future-requirements-matrix","title":"3. Voluntary Integration vs. Possible Future Requirements Matrix","text":"<p>This matrix outlines the anticipated pathway from voluntary use to potential regulatory mandate. The protocol is built to operate seamlessly in both contexts.</p> Aspect Current Voluntary Integration Possible Future Requirements Authority Interconnect Standards Board (ISB) governs versions, vocabularies, and hash rules. Department of Governance and Exchange (DOGE) as regulatory authority for compliance and enforcement. Access Policy Peer-to-peer agreements between participating entities. Standardized Digital Roles and Permissions (SDRP), federally or globally recognized. Public Data Best practice for transparency. Agencies may decide which data to publish. Mandatory global disclosures for specific categories (e.g., grants, contracts, campaign finance). Integrity Proof Entity Hash and canonical string provide voluntary integrity guarantee. Same Entity Hash meets any required SSOT-proof for compliance and audits. <p>CEP ensures that the same proof mechanism works in both cases, with no need for new cryptographic infrastructure should mandated requirements arrive.</p>"},{"location":"en/governance/objectives-and-vision/#4-future-proof-architecture","title":"4. Future-Proof Architecture","text":"<p>CEP is explicitly designed to:</p> <ul> <li>Scale from a few adopters to wider integration.</li> <li>Allow community-driven vocabulary evolution.</li> <li>Support new jurisdictions, formats, and regulatory requirements without schema breakage.</li> <li>Provide a secure, verifiable, and interoperable foundation for multi-sector data exchange.</li> </ul> <p>The vision is an interoperable civic identity and provenance network, offering incremental integration and compatibility with existing systems.</p>"},{"location":"en/governance/vocabulary-process/","title":"Vocabulary Governance Process","text":"<p>This document defines how controlled vocabularies in the Civic Exchange Protocol (CEP) are created, reviewed, versioned, and published. CEP vocabularies include:</p> <ul> <li><code>entity-type</code></li> <li><code>relationship-type</code></li> <li><code>exchange-type</code></li> <li><code>exchange-role</code></li> <li><code>party-role</code></li> <li><code>identifier-scheme</code></li> <li><code>source-system</code></li> <li><code>resolution-method</code></li> <li><code>value-type</code></li> </ul> <p>These vocabularies provide the stable semantic backbone for CEP interoperability across government systems, academic research, and third-party implementations.</p>"},{"location":"en/governance/vocabulary-process/#1-purpose-of-vocabularies","title":"1. Purpose of Vocabularies","text":"<p>CEP vocabularies serve three critical functions:</p> <ol> <li> <p>Interoperability:    Terms map to external standards (Popolo, Open Civic Data, OCDS, HSDS, Schema.org, XBRL, W3C PROV).</p> </li> <li> <p>Semantic Stability:    Terms provide canonical meaning for entity types, role types, relationship types, exchange types, etc.</p> </li> <li> <p>Verifiable Behavior:    Terms are referenced in canonical URI form inside attested CEP records, affecting hash parity and revision integrity.</p> </li> </ol>"},{"location":"en/governance/vocabulary-process/#2-versioning","title":"2. Versioning","text":"<p>Vocabulary files follow independent semantic versioning:</p> <p><code>&lt;name&gt;.vMAJOR.MINOR.PATCH.json</code></p> <p>Examples:  </p> <pre><code>entity-type.v1.0.0.json\nidentifier-scheme.v1.0.0.json\n</code></pre>"},{"location":"en/governance/vocabulary-process/#21-major","title":"2.1 MAJOR","text":"<p>Changes that break compatibility or reinterpret existing terms: - renaming or removing terms - redefining meanings - altering term URIs - significant structural changes</p> <p>Requires unanimous ISB approval + 6-month deprecation period.</p>"},{"location":"en/governance/vocabulary-process/#22-minor","title":"2.2 MINOR","text":"<p>Backward-compatible enhancements: - adding new terms - adding new mappings - adding optional properties</p> <p>Requires simple majority vote.</p>"},{"location":"en/governance/vocabulary-process/#23-patch","title":"2.3 PATCH","text":"<p>No semantic change: - fixing typos - adding external references in <code>seeAlso</code> - clarifying descriptions</p> <p>May be approved by ISB Chair alone.</p>"},{"location":"en/governance/vocabulary-process/#3-adding-updating-or-deprecating-terms","title":"3. Adding, Updating, or Deprecating Terms","text":"<p>All vocabulary modifications follow this structured workflow:</p>"},{"location":"en/governance/vocabulary-process/#step-1-proposal-submission","title":"Step 1 \u2014 Proposal Submission","text":"<p>A contributor submits a PR that includes: - updated vocabulary file - accompanying rationale - impact assessment on interoperability - references to external standards (if relevant)</p>"},{"location":"en/governance/vocabulary-process/#step-2-technical-review","title":"Step 2 \u2014 Technical Review","text":"<p>The Interconnect Standards Board (ISB) reviews: - term clarity and definition - hierarchy (<code>parentTermUri</code>) - mappings to external standards (SKOS-style) - URI stability - potential namespace collisions - hash-parity implications</p>"},{"location":"en/governance/vocabulary-process/#step-3-vote","title":"Step 3 \u2014 Vote","text":"<p>Version bump category determines voting requirements (Section 2).</p>"},{"location":"en/governance/vocabulary-process/#step-4-merge-release","title":"Step 4 \u2014 Merge &amp; Release","text":"<p>Upon approval: - CI validates JSON format, unique URIs, and mapping integrity - The vocabulary is merged into <code>main</code> - A new tag is created:</p> <p><code>vocab/&lt;name&gt;/vMAJOR.MINOR.PATCH</code></p>"},{"location":"en/governance/vocabulary-process/#step-5-deprecation-notices","title":"Step 5 \u2014 Deprecation Notices","text":"<p>If a term becomes deprecated: - it is retained with <code>\"status\": \"deprecated\"</code> - <code>\"deprecationNote\"</code> must point to its replacement - canonical JSON schemas continue accepting it unless a MAJOR bump occurs</p>"},{"location":"en/governance/vocabulary-process/#4-design-principles-for-vocabulary-terms","title":"4. Design Principles for Vocabulary Terms","text":""},{"location":"en/governance/vocabulary-process/#41-term-uris-must-be-globally-stable","title":"4.1 Term URIs MUST be globally stable","text":"<p>URIs never change after publication.</p>"},{"location":"en/governance/vocabulary-process/#42-labels-are-human-friendly-codes-are-machine-friendly","title":"4.2 Labels are human-friendly; codes are machine-friendly","text":"<p>Examples: - code: <code>prime-contract</code> - label: <code>Prime Contract</code></p>"},{"location":"en/governance/vocabulary-process/#43-definitions-must-be-unambiguous","title":"4.3 Definitions MUST be unambiguous","text":"<p>Definitions MUST avoid jurisdiction-specific assumptions unless explicitly scoped.</p>"},{"location":"en/governance/vocabulary-process/#44-hierarchies-should-be-used-where-meaningful","title":"4.4 Hierarchies SHOULD be used where meaningful","text":"<p>Example: - <code>subgrant</code> \u2192 parent: <code>grant-award</code> - <code>subcontract</code> \u2192 parent: <code>prime-contract</code></p>"},{"location":"en/governance/vocabulary-process/#45-external-mappings-should-be-included","title":"4.5 External mappings SHOULD be included","text":"<p>Supported mapping types: <code>exactMatch</code>, <code>broadMatch</code>, <code>narrowMatch</code>, <code>relatedMatch</code>.</p>"},{"location":"en/governance/vocabulary-process/#5-file-placement-and-structure","title":"5. File Placement and Structure","text":"<p>All vocabulary files live under <code>vocabularies/</code>.</p> <p>Each file follows the canonical <code>cep.vocabulary.schema.json</code>.</p>"},{"location":"en/governance/vocabulary-process/#6-lifecycle-summary","title":"6. Lifecycle Summary","text":"Stage Description Output Proposal Contributor suggests new/updated term Pull Request Review ISB evaluates definition + mappings Comments Vote Approve/reject based on version category Decision Release Publish new vocabulary version New <code>vX.Y.Z</code> tag Deprecation Old terms marked deprecated Maintained until next MAJOR"},{"location":"en/governance/vocabulary-process/#7-guiding-objective","title":"7. Guiding Objective","text":"<p>The primary objective of CEP vocabulary governance is to stabilize meaning, maximize interoperability, and ensure backward compatibility while allowing the ecosystem to grow with new policy types, relationship structures, data standards, and domain models.</p>"},{"location":"en/implementation/implementation-guide/","title":"Implementation Guide","text":"<p>This guide provides a practical overview for developers building Civic Exchange Protocol (CEP) implementations in any language. It complements the formal schemas and the categorical foundations by describing how to validate, construct, serialize, and verify CEP records in a deterministic and interoperable way.</p>"},{"location":"en/implementation/implementation-guide/#technical-assurance","title":"Technical Assurance","text":"<p>The core technical sanity of the standard is managed through two mandatory components that ensure every implementing system generates an identical cryptographic hash for the same payload:</p>"},{"location":"en/implementation/implementation-guide/#a-the-canonical-string-the-debug-tool","title":"A. The Canonical String (The Debug Tool)","text":"<p>Every implementation must expose a function (e.g., getCanonicalString or generate_canonical_string) that returns the raw, unhashed, deterministic string representation of the data payload.</p> <ul> <li>This function strictly enforces field ordering, date/time precision (microseconds, UTC), and monetary formatting (fixed two decimals, invariant culture).</li> <li>By comparing this raw string across Python, Java, Rust, and C#, implementers can instantly identify byte-for-byte serialization errors that would otherwise result in a cryptic hash mismatch.</li> </ul>"},{"location":"en/implementation/implementation-guide/#b-the-certification-test-suite-the-compliance-gate","title":"B. The Certification Test Suite (The Compliance Gate)","text":"<p>This repo includes shared test vectors that all language implementations must pass.</p> <ul> <li>Any vendor or government agency implementing a CEP Node must execute their system's generateValidationHash function against the payloads provided in the /test_data directory.</li> <li>The resulting SHA-256 hash must exactly match the expected output hash provided in the test vector files. This automated process hopes to help reduce costly manual audits.</li> </ul>"},{"location":"en/implementation/implementation-guide/#getting-certified","title":"Getting Certified","text":"<p>To achieve Node Certification, follow the process below:</p> <ol> <li>Read the /specifications directory.</li> <li>Select the folder corresponding to your primary platform (e.g., src/rust, src/python, src/java).</li> <li>Integrate the TransactionRecord model and the generateValidationHash function into your system.</li> <li>Execute the unit tests using the shared payloads from /test_vectors.</li> <li>Use the getCanonicalString() debugging function to resolve any hash mismatches until all tests pass.</li> </ol>"},{"location":"en/implementation/implementation-guide/#logic-organization","title":"Logic Organization","text":"<p>The core logic is divided into four main packages:</p> Package Name Domain Focus Dependencies Artifacts core Shared Utilities &amp; Types None Common cryptographic helpers (SHA-256 utils), base types (UEI), and error handling definitions. entity Civic Entity (CE) core Defines Entity records (UEI attestation, status). relationship Civic Relationship (CR) core, entity Defines legal relationships between attested entities. exchange Civic Exchange (CX) core, entity, relationship Defines the flow between entities bound by a relationship."},{"location":"en/implementation/implementation-guide/#1-implementation-goals","title":"1. Implementation Goals","text":"<p>A correct CEP implementation MUST:</p> <ol> <li>Produce canonical JSON matching the CEP schemas.</li> <li>Achieve hash parity with all certified implementations.</li> <li>Perform attestation verification using public keys.</li> <li>Maintain a correct immutable revision chain.</li> <li>Support identifier interoperability (UEI, LEI, OCD IDs, etc.).</li> <li>Correctly handle provenance composition using relationships and exchanges.</li> </ol>"},{"location":"en/implementation/implementation-guide/#2-canonical-serialization","title":"2. Canonical Serialization","text":"<p>CEP relies on canonical JSON for: - hash computation - signature generation - signature verification - deterministic comparison across nodes</p>"},{"location":"en/implementation/implementation-guide/#21-requirements","title":"2.1 Requirements","text":"<p>An implementation MUST:</p> <ul> <li>Sort all object keys lexicographically.</li> <li>Sort key-value pairs in <code>termsAttributes</code> and <code>additionalSchemes</code>.</li> <li>Emit no trailing commas.</li> <li>Emit deterministic formatting:</li> <li>UTF-8</li> <li>No extra whitespace outside JSON rules</li> <li>Serialize timestamps in:</li> <li>UTC</li> <li>Always microsecond precision</li> <li>Always <code>Z</code> suffix</li> </ul> <p>Example: <code>2025-09-15T14:03:22.500000Z</code></p>"},{"location":"en/implementation/implementation-guide/#22-canonical-field-order","title":"2.2 Canonical Field Order","text":"<p>Each schema clearly defines required fields and object structure. Field order MUST NOT vary once serialized.</p> <p>This is enforced via CI hash-parity tests across all languages.</p>"},{"location":"en/implementation/implementation-guide/#3-attestation-and-verification","title":"3. Attestation and Verification","text":""},{"location":"en/implementation/implementation-guide/#31-attestation-block","title":"3.1 Attestation Block","text":"<p>Every CEP Entity, Relationship, and Exchange contains an <code>attestation</code> block: - <code>attestorId</code> - <code>attestationTimestamp</code> - <code>proofType</code> - <code>proofValue</code> - <code>verificationMethodUri</code> - <code>proofPurpose</code> - <code>anchorUri</code> (optional)</p>"},{"location":"en/implementation/implementation-guide/#32-verification-workflow","title":"3.2 Verification Workflow","text":"<p>A verifier MUST:</p> <ol> <li>Resolve the public key from <code>verificationMethodUri</code>.</li> <li>Recompute canonical JSON excluding the <code>attestation</code> block.</li> <li>Validate the signature using the declared <code>proofType</code>.</li> <li>Confirm that the signature matches the hash of the canonical record.</li> </ol> <p>If verification fails: - the record MUST be rejected - the node MUST NOT include it in its dataset</p>"},{"location":"en/implementation/implementation-guide/#4-revision-and-hash-chain","title":"4. Revision and Hash Chain","text":""},{"location":"en/implementation/implementation-guide/#41-record-lifecycle","title":"4.1 Record Lifecycle","text":"<p>For each entity or relationship:</p> <pre><code>revision 1: previousRecordHash = null\nrevision 2+: hash of previous canonical record\n</code></pre>"},{"location":"en/implementation/implementation-guide/#42-requirements","title":"4.2 Requirements","text":"<p>Implementations MUST:</p> <ul> <li>Enforce monotonic revision numbers.</li> <li>Reject any record with an incorrect previousRecordHash.</li> <li>Treat each change as a new revision (even minor corrections).</li> </ul>"},{"location":"en/implementation/implementation-guide/#43-why-this-matters","title":"4.3 Why This Matters","text":"<p>This chain forms: - a tamper-evident audit log - the categorical \u201camendment\u201d morphism chain - a verified provenance trail</p>"},{"location":"en/implementation/implementation-guide/#5-identifier-interoperability","title":"5. Identifier Interoperability","text":"<p>CEP Entity identifiers include:</p> <ul> <li><code>samUei</code></li> <li><code>lei</code></li> <li><code>snfei</code></li> <li><code>canadianBn</code></li> <li><code>additionalSchemes</code>: the main interop surface</li> </ul>"},{"location":"en/implementation/implementation-guide/#51-best-practice","title":"5.1 Best Practice","text":"<p>Implementations SHOULD:</p> <ul> <li>Enforce scheme URIs contained in the <code>identifier-scheme</code> vocabulary.</li> <li>Perform validation on well-known schemes (UEI, LEI, OCD IDs).</li> <li>Allow permissive acceptance of unknown schemes if format is valid.</li> </ul>"},{"location":"en/implementation/implementation-guide/#6-provenance-composition","title":"6. Provenance Composition","text":"<p>Relationships and exchanges form directed edges.</p> <p>Implementations MUST:</p> <ul> <li>Validate <code>relationshipId</code> links when constructing exchanges.</li> <li>Build <code>provenanceChain</code> deterministically.</li> <li>Support <code>parentRelationshipId</code> and <code>parentExchangeId</code>.</li> </ul>"},{"location":"en/implementation/implementation-guide/#61-funding-chain","title":"6.1 Funding Chain","text":"<p>Funding chain tags MUST: - use uppercase segments - be separated by <code>&gt;</code> - match the derived provenance graph</p> <p>Example: <code>FEDERAL&gt;STATE&gt;LOCAL</code></p>"},{"location":"en/implementation/implementation-guide/#7-vocabulary-integration","title":"7. Vocabulary Integration","text":"<p>Each URI reference MUST map to a term in the appropriate vocabulary:</p> <ul> <li><code>relationshipTypeUri</code> \u2192 <code>relationship-type</code> vocabulary  </li> <li><code>exchangeTypeUri</code> \u2192 <code>exchange-type</code> vocabulary  </li> <li><code>party-role</code> and <code>exchange-role</code> vocabularies  </li> <li><code>identifier-scheme</code> for external IDs</li> </ul> <p>Implementations SHOULD cache vocabularies locally to avoid network dependencies.</p>"},{"location":"en/implementation/implementation-guide/#8-source-references","title":"8. Source References","text":"<p>A record's <code>sourceReferences</code> connects CEP data to external systems:</p> <ul> <li>Open Civic Data (bills, votes, events)</li> <li>USAspending</li> <li>state procurement portals</li> <li>HSDS registries</li> <li>campaign finance systems</li> <li>XBRL financial filings</li> </ul> <p>Implementation SHOULD: - validate URI format - ensure IDs are nonempty - verify URLs resolve when possible</p>"},{"location":"en/implementation/implementation-guide/#9-example-implementation-pattern","title":"9. Example Implementation Pattern","text":""},{"location":"en/implementation/implementation-guide/#91-pseudocode-workflow","title":"9.1 Pseudocode Workflow","text":"<pre><code>load_schemas()\nload_vocabularies()\n\nrecord = parse_input_json()\nvalidate_schema(record)\nvalidate_vocabulary_uris(record)\n\ncanonical = canonicalize_json(record without attestation)\nvalidate_previous_record_hash()\nverify_attestation(canonical, record.attestation)\n\nstore_record(record)\n</code></pre>"},{"location":"en/implementation/implementation-guide/#10-language-specific-notes","title":"10. Language-Specific Notes","text":""},{"location":"en/implementation/implementation-guide/#python","title":"Python","text":"<ul> <li>Use <code>json.dumps(..., separators=(',', ':'), ensure_ascii=False)</code></li> <li>Ensure key ordering via <code>sort_keys=True</code></li> </ul>"},{"location":"en/implementation/implementation-guide/#typescript","title":"TypeScript","text":"<ul> <li>Avoid <code>JSON.stringify</code> without a stable stringify library</li> </ul>"},{"location":"en/implementation/implementation-guide/#rust","title":"Rust","text":"<ul> <li>Use <code>serde_json::to_writer</code> with sorted maps</li> </ul>"},{"location":"en/implementation/implementation-guide/#java-c","title":"Java / C","text":"<ul> <li>Use custom serializers enforcing sorted keys</li> </ul> <p>All languages MUST produce identical byte output for canonical JSON.</p>"},{"location":"en/implementation/implementation-guide/#11-conformance-levels","title":"11. Conformance Levels","text":"Level Meaning Basic Validates schemas + vocabularies Full Also validates attestations + hash chains Verifying Node Maintains complete verified subcategory Authoritative Node Can generate new attestations"},{"location":"en/implementation/implementation-guide/#12-summary","title":"12. Summary","text":"<p>A complete CEP implementation MUST:</p> <p>\u2714 Validate schemas \u2714 Canonicalize JSON deterministically \u2714 Verify all cryptographic attestations \u2714 Maintain immutable hash chains \u2714 Interpret vocabulary URIs as semantic types \u2714 Support provenance composition \u2714 Preserve hash parity with all certified nodes  </p> <p>Following this guide helps ensure an implementation will integrate into the global Civic Graph and remain interoperable, verifiable, and future-proof.</p>"},{"location":"en/implementation/validator/","title":"Validator","text":"<p>Paste a sample Civic Exchange Protocol record below and validate it against one of the official schemas.</p>"},{"location":"en/implementation/validator/#schema-endpoints","title":"Schema Endpoints","text":"<p>The validator checks your JSON against one of the official Civic Exchange Protocol schemas:</p> <ul> <li> <p>Entity Schema   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.entity.schema.json</p> </li> <li> <p>Relationship Schema   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.relationship.schema.json</p> </li> <li> <p>Exchange Schema   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.exchange.schema.json</p> </li> <li> <p>Identifier Scheme Vocabulary   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.entity.identifier-scheme.schema.json</p> </li> <li> <p>Relationship Type Vocabulary   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.relationship-type.schema.json</p> </li> <li> <p>Exchange Role Vocabulary   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.exchange-role.schema.json</p> </li> <li> <p>Party Role Vocabulary   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.party-role.schema.json</p> </li> <li> <p>Source System Vocabulary   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.source-system.schema.json</p> </li> <li> <p>Value Type Vocabulary   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.value-type.schema.json</p> </li> <li> <p>Resolution Method Vocabulary   https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/schema/cep.resolution-method.schema.json</p> </li> </ul>"},{"location":"en/implementation/validator/#step-1-choose-schema","title":"Step 1. Choose schema","text":"<p> Entity (cep.entity.schema.json) Relationship (cep.relationship.schema.json) Exchange (cep.exchange.schema.json) <p></p>"},{"location":"en/implementation/validator/#step-2-input-json","title":"Step 2. Input JSON","text":"{   \"schemaVersion\": \"1.0.0\",   \"verifiableId\": \"cep-entity:sam-uei:J6H4FB3N5YK7\",   \"identifiers\": {     \"samUei\": \"J6H4FB3N5YK7\",     \"snfei\": \"d41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e\",     \"additionalSchemes\": [       {         \"schemeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/identifier-scheme.json#us-mn-district-id\",         \"value\": \"ISD-0123\"       },       {         \"schemeUri\": \"https://opencivicdata.org/id/division\",         \"value\": \"ocd-division/country:us/state:mn/school_district:123\"       }     ]   },   \"legalName\": \"Springfield Public School District 123\",   \"legalNameNormalized\": \"springfield public school district 123\",   \"entityTypeUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/entity-type.json#school-district\",   \"jurisdictionIso\": \"US-MN\",   \"status\": {     \"statusCode\": \"ACTIVE\",     \"statusEffectiveDate\": \"2001-07-01\",     \"statusTerminationDate\": null,     \"successorEntityId\": null   },   \"naicsCode\": null,   \"resolutionConfidence\": {     \"score\": 1.0,     \"methodUri\": \"https://raw.githubusercontent.com/civic-interconnect/civic-exchange-protocol/main/vocabulary/resolution-method.json#authoritative-sam-sync\",     \"sourceRecordCount\": 1   },   \"attestation\": {     \"attestorId\": \"cep-entity:sam-uei:EDFEDERAL0001\",     \"attestationTimestamp\": \"2025-11-28T15:30:45.123456Z\",     \"proofType\": \"Ed25519Signature2020\",     \"proofValue\": \"BASE64_SIGNATURE_VALUE_HERE\",     \"verificationMethodUri\": \"https://keys.civic-interconnect.org/attestors/edfederal-node-1#primary-key\",     \"proofPurpose\": \"assertionMethod\",     \"anchorUri\": null   },   \"previousRecordHash\": null,   \"revisionNumber\": 1 }"},{"location":"en/implementation/validator/#step-3-validation-result","title":"Step 3. Validation Result","text":"(Waiting for input...)"},{"location":"en/reference/reference-projects/","title":"Reference Projects: GitHub Data Standards","text":"<p>Here are three categories of open-source projects on GitHub that offer excellent parallels to a comprehensive standard like the Unified Entity Identifier and Provenance (UEI-P) Standard, particularly concerning common data schemas, multi-language support, and provenance tracking.</p>"},{"location":"en/reference/reference-projects/#1-interoperability-event-specifications-cross-platform","title":"1. Interoperability &amp; Event Specifications (Cross-Platform)","text":"<p>These standards focus on defining a common data format to ensure different systems and languages can communicate seamlessly. They often define schemas (like UEI-P's Identifier component) and transport rules.</p>"},{"location":"en/reference/reference-projects/#cloudevents-specification","title":"CloudEvents Specification","text":"<p>What it is: A specification for describing event data in a common way. It is designed to dramatically simplify event declaration and delivery across services, platforms, and languages (Go, Java, Python, C#, etc.).</p> <p>Parallel: Excellent example of a cross-platform specification managed openly on GitHub. It defines a mandatory set of attributes (like a base entity identifier) that must be present in every data payload.</p> <p>Link: https://github.com/cloudevents/spec</p>"},{"location":"en/reference/reference-projects/#cdevents-specification","title":"CDEvents Specification","text":"<p>What it is: A common specification for Continuous Delivery events, extending CloudEvents by introducing purpose and semantics to the event data.</p> <p>Parallel: Shows how a standard is built on top of another standard (CloudEvents), specializing the common metadata for a specific domain (CI/CD provenance and flow).</p> <p>Link: https://github.com/cdevents/spec</p>"},{"location":"en/reference/reference-projects/#2-provenance-and-data-tracking-standards","title":"2. Provenance and Data Tracking Standards","text":"<p>These projects directly relate to the Provenance part of the UEI-P, focusing on tracking the history, inputs, and derivation of data.</p>"},{"location":"en/reference/reference-projects/#prov-cpl-core-provenance-library","title":"PROV-CPL (Core Provenance Library)","text":"<p>What it is: A Core Provenance Library for collecting data provenance with multiple language bindings (C/C++, Java, Python, R). It uses the W3C PROV standard as its foundation.</p> <p>Parallel: Demonstrates a multi-language implementation of a provenance standard, providing APIs to record who/what/when/where data was created, which is central to provenance.</p> <p>Link: https://github.com/ProvTools/prov-cpl</p>"},{"location":"en/reference/reference-projects/#3-general-data-schemas-and-monorepo-structure","title":"3. General Data Schemas and Monorepo Structure","text":"<p>These focus on using JSON Schema to define strict data structures and managing them in a versioned repository.</p>"},{"location":"en/reference/reference-projects/#json-schema-specification","title":"JSON Schema Specification","text":"<p>What it is: The official specification for JSON Schema, which is a declarative language used to annotate and validate JSON documents.</p> <p>Parallel: This is the foundational tool used by many standards (including CloudEvents) to define the specific fields and types (like a UEI-P structure). Looking through this repo shows how a core schema standard is defined and versioned.</p> <p>Link: https://github.com/json-schema-org/json-schema-spec</p>"},{"location":"en/reference/reference-projects/#consumer-data-standards-australian-dsb-schemas","title":"Consumer Data Standards (Australian DSB Schemas)","text":"<p>What it is: A repository holding a collection of JSON schema files derived from the Australian Consumer Data Standards, used for robust schema validation in banking and energy sectors.</p> <p>Parallel: A great practical example of a large-scale data standard implementation in a monorepo (single repository), organized by release version, providing strict, enforceable JSON schemas for real-world data exchange.</p> <p>Link: https://github.com/ConsumerDataStandardsAustralia/dsb-schema-tools</p>"},{"location":"en/reference/reference-standards/","title":"Reference Standards","text":""},{"location":"en/reference/reference-standards/#associated-standards","title":"Associated Standards","text":"Standard/Acronym Purpose Why We Interface XBRL (eXtensible Business Reporting Language) The international standard for electronic transmission of business and financial data (e.g., SEC and FDIC filings use it). We map its transactional fields directly to the relevant XBRL taxonomy elements for regulatory compliance reporting. LEI (Legal Entity Identifier) Global standard for identifying parties to financial transactions worldwide. While the UEI is authoritative in the U.S. government space, our protocol needs to contain a field for the LEI if the entity is globally registered, ensuring compliance for any international transactions. W3C PROV (Provenance) The World Wide Web Consortium standard for recording the historical lifecycle and data quality of a piece of information. Our core value is Provenance. We adopt the principles of W3C PROV to formally define how data history, revisions, and sources are timestamped and logged. GTAS (Government-wide Treasury Account Symbol) The framework used by the Treasury for standardized federal financial reporting. Transactional data (e.g., amounts, categories) must be translatable into GTAS fields for seamless reporting up to the Treasury level."},{"location":"en/reference/reference-standards/#bridge","title":"Bridge","text":"<ul> <li>Official U.S UEI: The U.S. government already uses a Unique Entity Identifier (UEI), a 12-character alphanumeric ID assigned by SAM.gov, for all entities receiving federal financial assistance or doing business with the federal government (Source 3.1, 3.2). Often does not appear on state/local campaign finance reports or local school district consultant contracts unless federal funds are directly involved.</li> <li>Open-Source Data Cleaning Tools: Tools like Splink, OpenRefine, and Python/Pandas to manually clean and standardize messy names (\"Acme Consulting, LLC\" vs. \"Acme Consulting\") (Source 2.1, 2.3).</li> </ul>"}]}